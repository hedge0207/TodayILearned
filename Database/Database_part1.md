# 데이터 베이스의 기본 개념

- 주요 개념
  - 데이터: 현실 세계에서 단순히 관찰하거나 측정하여 수집한 시실이나 값
  - 정보: 의사 결정에 유용하게 활용할 수 있도록 **데이터를 처리한** 결과물
  - 정보 처리: 데이터에서 정보를 추출하는 과정 또는 방법
  - 정보 시스템: 조직 운영에 필요한 데이터를 수집하여 저장해두었다가 필요할 때 정보를 만들어주는 수단
  - 데이터베이스: 정보 시스템 안에서 데이터를 저장하고 있다가 필요할 때 제공하는 역할을 담당



- 데이터베이스의 정의 및 특징
  - 정의: 특정 조직의 여러 사용자가 공유하여 사용할 수  있도록 통합해서 저장한 운영 데이터의 집합
  - 특징
    - 실시간 접근: 사용자의 데이터 요구에 실시간으로 응답
    - 계속 변화: 데이터의 계속적인 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지
    - 동시 공유: 서로 다른 데이터의 동시 사용뿐만 아니라 같은 데이터의 동시 사용도 지원
    - 내용 기반 참조: 데이터가 저장된 주소나 위치가 아닌 내용으로 참조



- 데이터의 분류
  - 정형 데이터
    - 구조화된 데이터, 미리 정해진 구조에 따라 저장된 데이터
    - 엑셀의 스프레드 시트, DB의 테이블
  - 반정형 데이터
    - 구조에 따라 저장된 데이터지만 데이터 내용 안에 구조에 대한 설명이 함께 존재
    - 구조를 파악하는 파싱 과정이 필요
    - HTML, XML, JSON 등의 문서
  - 비정형 데이터
    - 정해진 구조가 없이 저장된 데이터
    - 워드나 PDF 문서와 같은 멀티미디어 데이터



- 데이터베이스의 용어
  - 스키마: 데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것
  - 인스턴스: 스키마에 따라 데이터베이스에 실제로 저장된 값
  - 데이터 독립성
    - 하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않는 특성
    - 논리적 데이터 독립성: 개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않음
    - 물리적 데이터 독립성: 내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않음



## DBMS

- DBMS(DataBase Management System)
  - DBS(DataBase Sysytem): 데이터 베이스에 데이터를 저장하고 이를 관리하여 조직에 필요한 정보를 생성해주는 시스템
  - 파일 시스템의 문제를 해결하기 위해 제시된 소프트웨어
  - 조직에 필요한 데이터를 DB에 통합하여 저장하고 관리



- DBMS의 발전 과정
  - 1세대: 네트워크 DBMS(그래프 형태), 계층 DBMS(트리 형태)
  - 2세대: 관계 DBMS(DB를 테이블로 구성, 오라클, MS SQL 서버, MySQL 등)
  - 3세대: 객체 지향 DBMS, 객체 관계 DBMS
    - 객체 지향 DBMS: 객체를 이용하여 데이터베이스를 구성(O2, ONTOS, GemStone)
    - 객체 관계 DBMS: 객체 DBMS+관계 DBMS
  - 4세대: NoSQL, NewSQL DBMS
    - NoSQL DBMS : 비정형 데이터를 처리하는데 적합하고 확장성이 뛰어남(MongoDB, Cassandra)
    - NewSQL DBMS: 관계 DBMS의 장점+NoSQL의 확장성 및 유연성(Google Spanner, VoltDB, NuoDB)



## 데이터베이스 설계

- 설계 단계
  - 1단계: 요구사항 분석
    - DB 용도 파악
    - 결과물: 요구 사항 명세서
  - 2단계: 개념적 설계
    - DBMS에 독립적인 개념적 구조 설계
    - 결과물: 개념적 스키마(ERD)
  - 3단계: 논리적 설계
    - DBMS에 적합한 논리적 구조 설계
    - 결과물: 논리적 스키마(릴레이션 스키마)
  - 4단계: 물리적 설계
    - DBMS로 구현 가능한 물리적 구조 설계
    - 결과물: 물리적 설계
  - 5단계: 구현
    - SQL문을 작성한 후 이를 DBMS에서 실행하여 데이터베이스 생성







# 데이터 모델링

- 데이터 모델링
  - 현실 세계에 존재하는 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 변환 과정
  - 데이터베이스 설계의 핵심 과정



- 2단계 데이터 모델링
  - 개념적 데이터 모델링(conceptual modeling)
    - 현실 세계의 중요 데이터를 추출하여 개념 세계로 옮기는 작업
    - 학생을 개념적으로 모델링 한다면 학번, 학과, 성별, 학년 등으로 개념적 모델링이 가능하다.
  - 논리적 데이터 모델링(logical modeling)]
    - 개념 세계의 데이터를 데이터베이스에 저장하는 구조로 표현하는 작업
    - 학생의 이름과 학과는 String으로, 학번과 학년은 Int로, 성별은 Boolean 값으로 저장한다고 논리적 모델링이 가능하다.



## 데이터 모델

- 정의: 데이터 모델링의 결과물을 표현하는 도구



### 개념적 데이터 모델

- 사람의 머리로 이해할 수 있도록 현실 세계를 개념적 모델링하여 데이터베이스의 개념적 구조로 표현하는 도구



- 개체-관계 모델

  - 개체와 개체 간의 관계를 이용해 현실 세계를 개념적 구조로 표현
  - 핵심 요소: 개체, 속성, 관계
  - 개체-관계 다이어그램(ERD): 개체-관계 모델을 활용하여 모델링한 결과물을 그림으로 표현한 것
  - 개체(entitiy)
    - 현실세계에서 조직을 운영하는데 꼭 필요한 사람이나 사물과 같이 구별되는 모든 것.
    - 저장할 가치가 있는 중요 데이터를 가지고 있는 사람, 사물, 개념, 사건 등
  - 속성(attribute)
    - 개체가 가지고 있는 고유의 특성.
    - 의미 있는 데이터의 가장 작은 논리적 단위
    - 단일 속성 값과 다중 속성 값: 단일한 값을 가지는지 여부
    - 단순 속성 값과 복합 속성 값: 복합적인 값을 가지는지 여부
    - 유도 속성: 기존의 다른 속성 값에 의해서 유도되어 결정되는 속성
    - 널 속성: 널 값이 허용되는지 여부
    - 키 속성: 각 개체 인스턴스를 식별하는 데 사용되는 속성
  - 개체 타입
    - 개체를 고유의 이름과 속성들로 정의한 것
    - 파일 구조의 레코드 타입에 대응됨
  - 개체 인스턴스
    - 개체를 구성하고 있는 속성이 실제 값을 가짐으로써 실체회된 개체
    - 파일 구조의 레코드 인스턴스에 대응됨
  - 개체 집합
    - 특정 개체 타입에 대한 개체 인스턴스들을 모아놓은 것
  - 예를 들어 고객이 있을 경우 
    - 고객은 개체에 해당
    - 고객이름, 주소, 연락처는 속성에 해당
    - 개체와 속성을 합하여 개체 타입이라 부른다.
    -  `<홍길동,대전,010-1234-5678>`은 개체 인스턴스에 해당
    -  홍길동과 같이 저장된 여러 인스턴스를 합해서 개체 집합이라 한다.

  - 관계
    - 개체와 개체가 가지고 있는 의미 있는 연관성
    - 개체 집합들 사이의 대응 관계, 매핑을 의미
    - 관계에 참여하는 개체 타입의 수를 기준으로 이항/삼항/순환 관계로 분류
    - 관계가 묶여 있는 방식에 따라 일대일/일대다/다대다 관계로 분류



### 논리적 데이터 모델

- 논리적 데이터 모델
  - 개념적 구조를 논리적 모델링하여 데이터베이스의 논리적 구조로 표현하는 도구
  - ERD로 표현된 개념적 구조를 데이터베이스에 저장할 형태로 표현한 논리적 구조



- 종류
  - 계층 데이터 모델
    - 데이터베이스의 논리적 구조가 트리 형태
    - 루트 역할을 하는 개체가 존재하고 사이클이 존재하지 않음
  - 네트워크 데이터 모델
    - 데이터베이스의 논리적 구조가 그래프 형태

  - 관계 데이터 모델
    - 일반적으로 많이 사용되는 논리적 데이터 모델
    - 데이터베이스의 논리적 구조



- 관계 데이터 모델

  - 개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델, 하나의 개체에 대한 데이터를 하나의 릴레이션에 저장
  - 행과 열에 대한 정의, 각 속성 별 도메인(타입)에 대한 정의
  - 기본 용어
    - 릴레이션(relation): 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것
    - 속성(attribute): 릴레이션의 열
    - 튜플(tuple): 릴레이션의 행
    - 도메인(domain): 하나의 속성이 가질 수 있는 모든 속성의 집합, 속성 값을 입력 및 수정할 때 적합성 판단의 기준이 되고, 일반적으로 속성의 특성을 고려한 데이터 타입으로 정의
    - 널(null): 속성 값을 아직 모르거나 해당 되는 값이 없음을 표현
    - 차수(degree): 하나의 릴레이션에 해당하는 속성의 전체 개수
    - 카디널리티(cardinality): 하나의 릴레이션에서 튜플의 전체 계수
    - 스키마: 애트리뷰트들의 집합
  - 데이터 베이스의 구성
    - 테이블을 만든다.
    - 테이블 마다 스키마를 만든다.
    - 해당 스키마에 따라 데이터를 넣어 인스턴스를 만든다.
  - 제약조건
    - 무결성: 데이터를 결함이 없는 상태로 유지하는 것 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
    - 개체 무결성: 기본키를 구성하는 모든 속성은 널 값을 가질 수 없다.
    - 참조 무결성: 참조하는 테이블의 외래키에 해당하는 값은 반드시 참조되는 테이블의 기본키로 존재해야 한다.
    - 도메인 무결성: 속성 값은 해당 속성 도메인에 속한 값들 중 하나여야 한다(예를 들어 성별 도메인에는 남, 여 외에는 입력할 수 없다).



- 키(Key)

  | 카드 번호 | 이름     | 주민번호       | 주소 |
  | --------- | -------- | -------------- | ---- |
  | 1         | 파이리   | 780111-1248795 | 서울 |
  | 2         | 꼬부기   | 940712-2111548 | 대전 |
  | 3         | 이상해씨 | 881112-1248246 | 부산 |

  - 릴레이션에서 튜플을 유일하게 구별하는 속성 또는 속성들의 집합
  - 키의 특성: 유일성, 최소성(꼭 필요한 최소한의 속성들로만 키를 구성)
    - 유일성: 행을 고유하게 식별할 수 있는 속성 또는 속성의 집합.
    - 최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
  - 슈퍼키: 유일성을 만족하는 속성 또는 속성들의 집합
    - 카드번호, 주민번호는 튜플을 고유하게 식별 가능하므로 슈퍼키이다.
    - {카드번호,이름}이라는 집합은 튜플을 고유하게 식별할 수 있는 집합이므로 슈퍼키에 해당
  - 후보키: 유일성과 최소성을 만족하는 속성들의 집합
    - 카드번호, 주민번호는 각기 하나만 있어도 튜플을 고유하게 식별 가능하므로 후보키이다.
    - {카드번호,이름}이라는 집합은 튜플을 고유하게 식별가능하지만 최소성을 만족하지는 못하므로 후보키는 되지 못한다.
    - 최소성이란 반드시 하나만으로 튜플을 고유하게 식별해야 한다는 것이 아니다. 고유하게 식별할 수 있는 키들 중에서 수가 가장 적은 것을 뜻한다.
    - 예시의 경우 카드 번호와 주민번호는 둘 중 하나만 있어도 튜플을 고유하게 식별이 가능하지만 {카드번호, 이름은} 2개가 있어야 고유하게 식별이 가능하다. 둘 보다는 하나가 더 적으므로 후보키는 하나로도 식별 가능한 카드 번호와 주민번호가 된다.
  - 기본키: 후보키 중에서 기본적으로 사용하기 위해 선택한 키
    - 카드번호와 주민등록 번호 모두 후보키로서 튜플을 고유하게 식별 가능하다.
    - 둘 중 어떤 것을 기본 키로 사용할지는 개발자의 선택이다.
  - 대체키: 기본키로 선택되지 못한 후보키
    - 카드번호를 기본키로 선택했다면 주민등록번호는 대체키가 된다.
  - 외래키: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합



# 데이터베이스의 언어, SQL

- 데이터 베이스 언어(SQL)
  - 데이터 정의어(DDL, Data Definition Language)
    - 스키마를 정의하거나, 수정 또는 삭제하기 위해 사용
  - 데이터 조작어(DML, Data Manipulation Language)
    - 데이터의 삽입, 삭제, 수정, 검색 등의 처리를 요구하기 위해 사용
    - 절차적 데이터 조작어와 비절차적 데이터 조작어로 구분
  - 데이터 제어어(DCL, Data Control Language)
    - 내부적으로 필요한 규칙이나 기법을 정의하기 위해 사용
    - 보안을 위해 데이터에 접근 및 사용 권한을 사용자별로 부여하거나 취소하는 기능 등



- 뷰
  - 정의: 기본 테이블을 들여다 볼 수 있는 창의 역할을 담당
  - 장점
    - 질의문을 좀 더 쉽게 작성할 수 있음
    - 데이터의 보안 유지에 도움이 됨
    - 데이터를 좀 더 편리하게 관리할 수 있음





# 정규화

> https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency/ 참고

- 이상현상

  - 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입, 수정, 삭제 연산을 수행할 때 발생할 수 있는 부작용
  - 아래 표는 모든 학생이 포함된 테이블이라고 가정
    - 학번과 과목 코드는 기본키이다.

  | 학번     | 이름 | 학과         | 과목 코드 | 성적 |
  | -------- | ---- | ------------ | --------- | ---- |
  | 21322258 | 짱구 | 컴퓨터공학과 | ZXC1234   | A+   |
  | 21322258 | 짱구 | 컴퓨터공학과 | ASD8795   | A    |
  | 21322258 | 짱구 | 컴퓨터공학과 | QWE4412   | B    |
  | 21354879 | 철수 | 심리학과     | PSY1248   | A    |
  | 21148789 | 맹구 | 경영학과     | VCX1875   | C    |

  - 삽입 이상: 새 데이터를 삽입하려면 불필요한 데이터도 함께 삽입해야 하는 문제
    - 위 테이블에는 해당 학교의 모든 학생이 포함되어야 한다.
    - A라는 신입생이 입학을 했을 때, 모든 학생은 위 테이블에 추가되어야 하므로 A는 입학과 동시에 위 테이블에 추가가 된다.
    - A는 아직 신청한 과목도, 받은 성적도 없다.
    - 기본키인 과목 코드는 NULL이 될 수 없다.
    - 따라서 이 학생을 테이블에 추가하려면 "미수강"과 같은 과목 코드를 새로 만들어서 삽입해야 한다.
    - 이처럼 불필요한 데이터를 함께 삽입해야 하는 문제가 발생한다.
  - 갱신 이상: 릴레이션의 중복된 튜플들 중 일부만 수정하여 데이터가 불일치하게 되는 모순이 발생하는 문제
    - 짱구는 컴퓨터공학과가 마음에 들지 않아 물리학과로 전과를 하려 한다. 
    - 이 때 테이블상에 짱구가 컴퓨터공학과로 입력된 모든 값을 물리학과로 변경해 주어야 한다.
    - 이 때 모두 변경하지 않고 일부만 변경하게 되면 짱구가 컴퓨터공학과인지 물리학과인지 알 수 없게 된다.
  - 삭제 이상: 릴레이션에서 튜플을 삭제하면 꼭 필요한 데이터까지 손실되는 연쇄 삭제 현상이 발생하는 문제
    - 철수는 딱 1과목만 수강하고 있다.
    - 철수는 해당 과목이 마음에 들지 않아 수강 취소를 하려 한다.
    - 위 테이블에 수강 취소를 반영하기 위해서는 철수에 대한 데이터를 모두 날리는 방법 밖에는 없다.



- 정규화(Normalization)
  - 정의
    - 이상 현상을 제거하면서 데이터베이스를 올바르게 설계해 나가는 과정
    - 이상 현상이 발생하지 않도록 하기 위해, 릴레이션을 관련 있는 속성들로만 구성하기 위해 릴레이션을 분해 하는 과정
    - 함수적 종속성을 판단하여 정규화를 수행하며 이 과정을 통해 릴레이션은 무손실 분해되어야 한다.
    - 함수 종속성을 이용하여, 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해하여 이상 현상이 발생하지 않는 바람직한 릴레이션으로 만들어 나가는 과정
    - 정규화된 정도를 정규화(Normal Form)로 표현한다.
  - 비정규화(반정규화, Denormalization)는 사용의 편의를 위해 정규화 된 설계를 다시 비정규화 하는 것이다.



- 함수적 종속성

  - X, Y가 있을때, "X이면 Y이지만, Y이면 반드시 X인 것은 아니다"와 같은 상태를 함수적 종속성이라 한다.
    - 예를 들어 X를 학번, Y를 이름이라고 한다면 X를 알면 반드시 Y를 알 수 있지만 Y를 안다고 X를 반드시 알 수 있는 것은 아니다(동명이인 등).

  | 학번     | 과목 코드 | 이름   | 성적 |
  | -------- | --------- | ------ | ---- |
  | 21322258 | D103E3B   | 홍길동 | A+   |
  | 21322258 | C213R1Q   | 홍길동 | B+   |

  - 결정자와 종속자
    - 학번을 알면 이름을 알수 있지만 이름을 안다고 학번을 알 수는 없다.
    - 이 때 학번을 결정자, 이름를 종속자라 하고 "학번이 이름을 함수적으로 결정한다." 또는 "이름이 학번에 함수적으로 종속되어 있다"고 표현한다.
    - 학번 -> 이름과 같이 표현이 가능하다.
  - 완전 함수적 종속
    - 위 표에서 학번과 과목 코드를 알면 성적을 알 수 있다(`{학번, 과목코드}-> 성적`)
    - 완전 함수적 종속은 속성 집합 Y가 속성 집합 X의 전체에 대해서만 함수적으로 종속되는 경우를 말한다.
    - 위 예에서 성적이 속성 집합 Y, {학번, 과목 코드}가 속성집합 X라고 할 때, 성적은 X의 어떤 부분집합에도 함수적으로 종속되어 있지 않다. 학번만으로 성적을 알 수 없고, 과목 코드만으로 성적을 알수 없기 때문이다.

  - 부분 함수적 종속
    - 위 표에서 학번을 알면 이름을 알 수 있고 학번과 과목 코드를 알면 이름을 알 수 있다(`학번->이름` / `{학번,과목코드}->이름`)
    - 완전 함수적 종속은 속성 집합 Y가 속성집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다.
    - 위 예에서 이름이 속성 집합 Y, {학번, 과목 코드}가 속성집합 X라고 할 때, 이름은 {학번, 과목 코드}에도 함수적으로 종속되며, 그 일부인 학번에도 함수적으로 종속된다.
  - 이행 함수적 종속
    - X->Y, Y->Z 라는 종속 관계가 있을 경우 X->Z가 성립될 때 이행적 함수 종속이라 한다.





## 정규형

- 정규형
  - 정규화 된 정도를 정규형이라 부른다,
  - 릴레이션이 정규화된 정도로 각 정규형마다 제약 조건이 존재
  - 릴레이션의 특성을 고려하여 적합한 정규형을 선택
    - 비공식적으로 3NF 정도가 되면 정규화가 되었다고 말한다.
    - 모든 정규형이 제 5 정규형에 속해야만 바람직한 것은 아니다.



- 정규형의 종류(아래로 갈수록 조건이 까다로워 진다)

  - 제 1 정규형(1NF, First Normal Form)

    - 릴레이션의 모든 속성이 더는 분해되지 않는 원자 값만 가지면 제 1정규형을 만족함
    - 아래 표는 제 1 정규형을 만족하지 못했다.

    | 학번     | 과목 번호                 | 성적     | 이름   |
    | -------- | ------------------------- | -------- | ------ |
    | 21322258 | ASD1234, ZXC4321, QWE6789 | A+,B+,C+ | 홍길동 |

    - 아래와 같이 수정해야 제 1 정규형을 만족한다고 할 수 있다.

    | 학번     | 과목 번호 | 성적 | 이름   |
    | -------- | --------- | ---- | ------ |
    | 21322258 | ASD1234   | A+   | 홍길동 |
    | 21322258 | ZXC4321   | B+   | 홍길동 |
    | 21322258 | QWE6789   | C+   | 홍길동 |

  

  - 제2정규형(2NF, Seconmd Normal Form)

    - 릴레이션이 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2 정규형을 만족함
  
    | 학번     | 과목코드 | 성적 | 학과         | 등록금 |
    | -------- | -------- | ---- | ------------ | ------ |
    | 21322258 | ASD1234  | A+   | 컴퓨터공학과 | 450    |
    | 21322258 | ZXC4321  | B+   | 컴퓨터공학과 | 450    |
    | 21322258 | QWE4877  | B+   | 컴퓨터공학과 | 450    |
    | 21348898 | TRE4856  | A+   | 심리학과     | 300    |
    | 21978755 | HTF1575  | C+   | 무역학과     | 350    |
    | 21764876 | YKT4878  | A+   | 컴퓨터공학과 | 450    |
  
    - 위 표에서 `{학번, 과목 코드}->학과, {학번,학과}-> 등록금`인데, 학과와 등록금은 학번만 있어도 알 수 있다(성적은 과목코드를 함께 알아야 한다)
    - 따라서 이를 완전 함수 종속되게 만드려면 다음과 같이 릴레이션을 분리하여 완전 함수 종속되도록 만들어야 한다.
  - 아래와 같이 학생 릴레이션과 성적 릴레이션을 따로 만든다.
  
    | 학번     | 학과         | 등록금 |
    | -------- | ------------ | ------ |
    | 21322258 | 컴퓨터공학과 | 450    |
    | 21348898 | 심리학과     | 300    |
    | 21978755 | 무역학과     | 350    |
    | 21764876 | 컴퓨터공학과 | 450    |

    | 학번     | 과목코드 | 성적 |
    | -------- | -------- | ---- |
    | 21322258 | ASD1234  | A+   |
    | 21322258 | ZXC4321  | B+   |
    | 21322258 | QWE4877  | B+   |
    | 21348898 | TRE4856  | A+   |
    | 21978755 | HTF1575  | C+   |
    | 21764876 | YKT4878  | A+   |
  
    - 그러나 이행적 함수 종속이 존재하기에 이상현상은 여전히 발생할 것이다.
    - 삽입이상: 새로운 학부가 생기는 경우 등록된 학생이 없다면 학번 속성이 NULL이 되므로 학번에 "미기재" 등의 불필요한 데이터를 함께 삽입해야 한다.
    - 갱신이상: 컴퓨터공학과 등록금이 400으로 감소하는 경우 21764876 학번과, 21322258 학번의 등록금을 모두 바꿔줘야 하는 문제가 발생한다.
    - 삭제이상: 21978755 학생이 자퇴하는 경우, 무역학과에 대한 정보가 함께 사라지게 된다.
  
  
  
  - 제3정규형(3NF, Third Normal Form)
  
    - 릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속되지 않으면 제 3 정규형을 만족함
    - 제 2 정규형을 만족하도록 다시 짠 위 테이블은 학번을 알면 학과를 알 수 있고, 학과를 알면 등록금을 알 수 있도록 설계되어 있다(학번만 가지고는 바로 등록금을 알 수 없다. 등록금은 학과에 종속된 값이지 학번에 종속된 값은 아니다).
    - 따라서 아래와 같이 학생 릴레이션을 학생 릴레이션과 학과 릴레이션으로 다시 분리한다.
  
    | 학번     | 학과         |
    | -------- | ------------ |
    | 21322258 | 컴퓨터공학과 |
    | 21348898 | 심리학과     |
    | 21978755 | 무역학과     |
    | 21764876 | 컴퓨터공학과 |
  
    | 학과         | 등록금 |
    | ------------ | ------ |
    | 컴퓨터공학과 | 450    |
    | 심리학과     | 300    |
    | 무역학과     | 350    |
  
    
  
  - 보이스/코드 정규형(BCNF, Boyce/Codd Normal Form)
  
    - 3NF를 만족하는 릴레이션 R의 후보키가 1개 밖에 없고 R의 후보키가 기본키인 경우 BCNF를 만족한다. 
    - 간단하게 말하면 모든 결정자가 후보키인 경우이다.
    - Strong 3NF라고 부르기도 한다.
    - 하나의 릴레이션에 여러 개의 후보키가 존재하는 경우, 제 3 정규형까지 모두 만족해도 이상 현상이 발생할 수 있다.
    - 아래 표에서 한 명의 강사는 한 개의 강좌만 개설 할 수 있다고 가정한다.
    
    | 학번     | 강좌명   | 강사번호 |
    | -------- | -------- | -------- |
    | 21978456 | 프랑스어 | FR7854   |
    | 21784595 | 영어     | EN1578   |
    | 21875485 | 영어     | EN1578   |
    | 21875485 | 일본어   | JP1217   |
    
    - `{학번,강좌명}->강사번호`, `{학번,강사번호}->강좌명`을 식별할 수 있다.
    - 즉 후보키는 위 2가지가 된다. 그 중 {학번,강좌명}을 기본키로 선택한다고 가정할 때 아래와 같은 이상현상이 발생한다.
    - 삽입이상: 중국어 강좌가 CN1818에 의해 열렸을 때 아직 수강하는 학생이 없으므로 학번이 NULL로 들어가야 하는데 이는 참조무결성을 위배한다.
    - 갱신이상: EN1578이라는 강사가 영어 강좌가 아닌 스페인어 강좌를 맡게 되었다고 할 때 총 2개의 튜플을 변경해야 하는데 만일 1개의 튜플만 변경할 경우 데이터의 불일치 현상이 발생하게 된다.
    - 삭제 이상: 21978456 학생이 프랑스어 강좌를 수강 취소한다면 해당 튜플 전체가 삭제되어 강좌명과 강사 번호까지 전부 삭제되게 된다.
    - 따라서 아래와 같이 릴레이션을 분리하면 모든 결정자가 후보키가 되므로 BCNF를 만족한다.
    
    | 학번     | 강사번호 |
    | -------- | -------- |
    | 21978456 | FR7854   |
    | 21784595 | EN1578   |
    | 21875485 | EN1578   |
    | 21875485 | JP1217   |
    
    | 강좌명   | 강사번호 |
    | -------- | -------- |
    | 프랑스어 | FR7854   |
    | 영어     | EN1578   |
    | 일본어   | JP1217   |
    
    - 위 예시는 사실상 3NF랑 다를 것이 없다. 또한 예시가 좀 이상한데 그럴 수 밖에 없는 것이 위 예시와 같은 DB 모델링은 정말 엉망으로 짜려고 작정하지 않는 한 잘 나오지 않기에 적잘한 예시를 들기도 힘들기 때문이다.
  
  
  
  - 제 4 정규형(4NF)
  
    - BCNF 정규형을 만족하면서, 비단순 다치 종속을 제거한 경우
    - 비단순 다치 종속성(MVD, MultiValued Dependency)을 제거하면 제 4 정규형에 속한다.
    - 다치 종속: 두 개의 독립된 애트리뷰트가 1:N 관계로 대응하는 관계로 `↠`로 종속성을 나타낸다.
    - 단순 다치 종속: A↠B일 때 B가 A의 부분집합이거나, A∪B가 전체 테이블이 될 경우 단순 다치 종속이다.
    - 비단순 다치 종속: 단순 다치 종속이 아닌 다치 종속
    - `학번↠수강과목`, `학번↠동아리`인데 문제는 수강 과목과 동아리는 아무런 연관이 없다는 것이다. 
    - 즉 다치 종속의 진짜 문제는 아래와 같이 아무 연관이 없는 어트리뷰트들 끼리 한 릴레이션으로 묶여 있는 경우에 발생한다.
  
    | 학번 | 수강과목    | 동아리 |
    | ---- | ----------- | ------ |
    | 0001 | 물리학 개론 | 낚시   |
    | 0002 | 건축학 개론 | 카메라 |
    | 0002 | 심리학 개론 | 자전거 |
    | 0003 | 심리학 개론 | 자전거 |
    | 0003 | 이상심리학  | 요리   |
  
    - 따라서 아래와 같이 릴레이션을 과목과 동아리로 분리한다.
  
    | 학번 | 과목        |
    | ---- | ----------- |
    | 0001 | 물리학 개론 |
    | 0002 | 건축학 개론 |
    | 0002 | 심리학 개론 |
    | 0003 | 심리학 개론 |
    | 0003 | 이상심리학  |
  
    | 학번 | 동아리 |
    | ---- | ------ |
    | 0001 | 낚시   |
    | 0002 | 카메라 |
    | 0002 | 자전거 |
    | 0003 | 자전거 |
    | 0003 | 요리   |
  
    - 위 두 테이블의 `학번↠수강과목`, `학번↠동아리`으로 다치 종속 이지만 `학번∪과목`, `학번∪동아리`가 모두 전체 집합이므로 단순 다치 종속에 해당해 제 4 정규형을 만족한다.
  
  
  
  - 제 5 정규형(5NF)
    - 제 4 정규형을 만족하면서, 후보키를 통하지 않는 조인 종속(JD, Join Dependency)을 제거하면 제 5 정규형에 속한다.
    - 즉 조인 종속 자체를 제거하는 것이 아닌 후보키를 통하지 않는 조인 종속을 제거하면 제 5 정규형에 속하는 것이다.
    - 조인 종속: 하나의 릴레이션을 여러개의 릴레이션으로 분해하였다가, 다시 조인했을 때 데이터 손실이 없고 필요없는 데이터가 생기지 않는 것