# 그리디 알고리즘

- 그리디 알고리즘(Greedy Algorithm)
  - 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘.
  - 그리디 알고리즘은 최적화 문제를 대상으로 한다.
    - 최적해를 찾을 수 있으면 그것을 목표로 삼는다.
    - 최적해를 찾기 어려운 경우에는 주어신 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.



- 그리디 알고리즘의 조건
  - 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들이다.
    - 이 조건을 만족해야만 최적해를 찾을 수 있다.
    - 이 조건을 만족하지 않더라도 정답을 근사하게 찾는 용도로 활용할 수 있으며, 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.
  - 탐욕 선택 속성
    - 앞의 선택이 이후 선택에 영향을 주지 않는 것.
    - 즉 선택을 다시 고려하지 않는다.
  - 최적 부분 구조
    - 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우.



- 그리디 알고리즘 풀이 전략
  - 풀이 흐름
    - 관찰을 통해 탐색 범위를 줄이는 방법을 고안한다.
    - 탐색 범위를 줄여도 올바른 결과를 얻을 수 있다는 사실을 증명한다.
  - 정말 그리디 알고리즘으로 풀 수 있다는 확신이 없다면 그리디로 풀어선 안 된다.



- 동전 문제 풀기

  - 그리디 알고리즘으로 풀 수 있는 문제 중에서 가장 유명한 문제가 동전문제이다.
    - 여러 종류의 동전이 있을 때 최소한의 동전을 사용해서 값을 지불하는 문제이다.

  - 문제
    - 500, 100, 50, 10 네 종류의 동전이 있을 때, 1780원을 최소한의 동전으로 만들려고 한다.
    - 500원 짜리 3개, 100원 짜리 2개, 50원 짜리 1개, 10원 짜리 3개를 사용하면 최소 개수로 1780원을 만들 수 있다. 
  - 증명
    - 동전을 최소한으로 사용하면서 원하는 가격을 맞추기 위해서는 10원과 100원짜리 동전은 4개 이하, 50원 짜리 동전은 1개 이하로 사용해야한다.
    - 10원 짜리를 5개를 사용할 경우 50원 짜리 하나를 사용하는게 낫고, 100원짜리 5개를 사용할 경우 500원 짜리 하나를 사용하는 것이 나으며, 50원 짜리 2개를 사용할 경우 100원짜리 하나를 사용하는 것이 낫기 때문이다.
    - 동전을 최소한으로 사용하면서 원하는 가격을 맞추기 위해서는 500원 동전을 최대한 많이 사용해야한다. 
    - 10원짜리의 최대 개수인 4, 100원짜리 최대 개수인 4, 50원 짜리 최대 개수인 1을 모두 더해 봐야 490원이 한계이므로, 500원짜리 동전을 사용할 수 있음에도 사용하지 않을 경우 각 동전의 최대 상한보다 더 많은 양을 사용해야만 한다.
    - 500원을 최대한 사용해야하는 이유와 동일한 이유가 100, 50, 10원에도 적용된다.





## 탐욕 알고리즘 분석 기법

> https://gazelle-and-cs.tistory.com/59
>
> https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf
>
> http://www.cs.cornell.edu/courses/cs482/2007su/ahead.pdf



- 탐욕 알고리즘의 분석
  - "현재로써 최선인 선택을 취한다."는 매우 단순한 원리를 가지고 있지만 탐욕 알고리즘으로 최적해를 구할 수 있다는 것을 증명하는 것은 매우 까다롭다.
    - 직관적으로 그럴 것 같은 것과 정말 그렇다는 것을 증명하는 것은 매우 다르다.
  - 분석이 까다로운 탐욕 알고리즘을 분석할 수 있는 기법들이 몇 가지 있는데 대표적으로 아래와 같은 것들이 있다.
    - Greedy stays ahead
    - Certificate argument
    - Exchange argument

  - Greedy 알고리즘을 사용하여 다양한 문제의 최적해를 구할 수 있다는 것을 각 기법으로 확인해 볼 것이다.



- Interval Scheduling 문제
  - 여러 작업들의 시작 시간과 종료 시간이 주어질 때, 기계가 처리할 수 있는 작업의 최대 개수를 구하는 문제이다.

    - 여러 작업을 처리해야하는 상황에서, 작업을 처리할 수 있는 기계는 하나 뿐이다.
    - 기계는 한 번에 하나의 작업만을 처리할 수 있지만, 한 작업이 끝남과 동시에 다른 작업을 시작할 수 있다.

    - 백준의 [회의실 배정](https://www.acmicpc.net/problem/1931) 문제도 이와 동일한 문제이다.

  - Interval scheduling 문제를 풀기 위한 greedy 알고리즘
    - 모든 작업을 종료 시각의 오름차순으로 정렬한 후 각 작업을 순서대로 고려하면서 기계에 할당할 수 있으면 넣고 그렇지 않으면 버린다.
    - 만일 작업의 종료 시각이 같다면 작업의 시작 시간을 기준으로 정렬한다.



### "Greedy stays ahead" arguments

- 방식
  - 최적해를 출력하는 가상의 알고리즘이 있다고 가정한다. 
  - 이 가상의 알고리즘이 알고리즘이 매번 선택을 할 때 탐욕 알고리즘이 어떤 선택을 하는지 살펴본다. 
  - 만약 탐욕 알고리즘의 선택이 최적 알고리즘의 선택보다 항상 (특정 기준에 따라) 뒤쳐지지는 않는다면, 전체적으로 봤을 때도 탐욕 알고리즘의 출력이 최적 알고리즘의 출력만큼은 좋다고 볼 수 있다.
  - 따라서 탐욕 알고리즘이 내놓은 답이 최적해가 된다.



- 과정
  - Solution 정의
    - greedy algorithm을 구현한다.
    - 구현한 greedy algorithm을 통해 얻을 수 있는 해들과 임의의 최적의 알고리즘을 통해 구할 수 있는 해들을 가정한다.
  - 척도(measure)를 정의
    - greedy algoritm을 통해 구할 수 있는 해들과, 임의의 최적 알고리즘을 통해 구할 수 있는 해들을 하나씩 비교할 수 있는 척도를 정의한다
    - 두 알고리즘을 통해 구한 해의 개수는 경우에 따라 같을 수도 있고 다를 수도 있다.
  - Greedy stays ahead를 증명
    - greedy로 구한 해가, 최적 알고리즘을 통해 구한 해 보다 위에서 정의한 척도 보다 모든 경우 뒤쳐지지는 않는 다는 것을 증명한다.
  - 최적성(optimality) 증명
    - 위에서 증명한 greedy stays ahead를 기반으로 greedy 알고리즘이 반드시 최적해를 산출해 낸다는 것을 증명한다. 
    - 이는 주로 greedy가 최적해를 구할 수 없다는 것을 가정했을 때 모순이 발생한 다는 것을 확인함으로써 이루어진다.



- Solution 정의
  - 작업들의 집합 T가 있으며, T의 원소들은 시작 시각과 종료 시각에 대한 정보를 가지고 있다.

  - 그리디 알고리즘은 집합 T를 종료 시각을 기준으로 오름차순으로 정렬하여 각 작업을 처음부터 순회하면서, 기계에 할당할 수 있으면 자신의 집합에 넣고, 그렇지 않으면 버린다.
    - 이를 통해 처리한 작업들의 집합을 S := {p<sub>1</sub>, p<sub>2</sub>, ... , p<sub>k</sub>}라 하며, 이는 기계에서 처리된 순서로 정렬되어 있다.
  - 임의의 최적의 알고리즘 역시 나름의 방식으로 집합 T에서 처리할 수 있다고 판단하는 작업들을 자신의 집합에 넣는다.
    - 이를 통해 처리한 작업들의 집합을 O := {q<sub>1</sub>, q<sub>2</sub>, ... , q<sub>k</sub>}라 하며, 이 역시 기계에서 처리되는 순서로 정렬되어 있다.



- 척도 정의

  - 어떤 작업 p에 대해 이 작업이 시작하는 시각을 s(p), 끝나는 시각을 f(p)라 한다.
    - 탐욕 알고리즘을 통해 얻은 집합 S의 원소들은 s(p<sub>1</sub>) <= f(p<sub>1</sub>) <= s(p<sub>2</sub>) <= f(p<sub>2</sub>) <= ... <= s(p<sub>k</sub>) <= f(p<sub>k</sub>)를 만족한다.
    - 임의의 최적의 알고리즘을 통해 O의 원소들도 s(p<sub>1</sub>) <= f(p<sub>1</sub>) <= s(p<sub>2</sub>) <= f(p<sub>2</sub>) <= ... <= s(p<sub>k</sub>) <= f(p<sub>k</sub>)를 만족한다.
    - 두 집합의 개별 원소들을 작업 시작 시각과 종료 시각으로 비교할 것이다.
  - 증명하고자 하는 명제는 k >= l 이라는 것이다.
    - 만약 탐욕 알고리즘을 통해 처리한 작업들의 개수가, 최적해를 통해 처리한 작업의 개수보다 크거나 같다면, 탐욕 알고리즘을 통해 최적해를 구할 수 있다는 것이다.
    - 즉, S 집합에 속한 작업의 개수 k가, O집합에 속한 작업의 개수 l보다 크다면, 탐욕 알고리즘을 통해 최적해를 구할 수 있음이 증명된다.



- Greedy stays ahead 증명

  - 집합 S와 집합 O 내에 있는 개별 원소들을 하나씩 비교하면서 개별 원소들에서 greedy로 구한 해가 최적 알고리즘으로 구한 해 보다 특정 척도(종료 시각)에서 뒤쳐지지 않는지를 확인할 것이다.
  - 정리: 1<= i <=m을 만족하는 모든 i에 대해 f(p<sub>i</sub>) <= f(q<sub>i</sub>)가 성립한다.
    - 이는 너무 분명한 사실로, 탐욕 알고리즘은 선택 가능한 작업들 중 종료 시간이 가장 빠른 작업을 선택한다.
    - 따라서 같은 순서(i번째)에 있는 S에 속한 작업 p<sub>i</sub>와 q<sub>i</sub>중 p<sub>i</sub>가 더 빠르거나, 최소한 q<sub>i</sub>와 같을 것이다. 
    - 즉, S에 속한 모든 i번째 작업의 종료 시각은 O에 속한 모든 i번째 작업의 종료 시각보다 빠르다.

  - Base case
    - 만약 i=1이라면 탐욕 알고리즘은 주어진 작업들 중 가장 빨리 끝나는 작업을 할당할 것이므로, f(p<sub>1</sub>) <= f(q<sub>1</sub>)을 만족할 것이다.
    - S는 작업을 처리하는 순서대로 정렬되어 있으므로 f(p1)은 모든 작업들 중 종료 시간이 가장 빠른 값일 수 밖에 없다. 
    - 따라서 f(p<sub>1</sub>)은 f(q<sub>1</sub>)보다 작거나 같을 수 밖에 없다.



- 최적성 증명
  - 반박될 가정: S가 최적해의 집합이 아니라면, S에 속한 작업의 개수 k는 O에 속한 작업의 개수 l보다 작을 것이다.
    - 만약 이 가정이 참이라면, S의 마지막 작업이 k번째 작업이기 때문에, O에는 k+1번째 작업이 있다는 말이 된다.
  - O의 k+1번째 작업인 q<sub>k+1</sub>은 q<sub>k</sub> 이후에 실행되어야 한다.
    - 그런데, 우리는 "모든 i = 1, ..., l에 대해 f(p<sub>i</sub>) <= f(q<sub>i</sub>)를 만족한다."는 사실을 알고 있다.
    - 이를 통해 S의 k번째 작업인 p<sub>k</sub>가 O의 k번째 작업인 q<sub>k</sub>보다 종료 시각이 빠르다는 거나 같다는 알 수 있다.
    - 따라서 f(p<sub>k</sub> ) <= f(q<sub>k</sub>) <= s(q<sub>k+1</sub>)와 같은 상황이 된다.
    - 이는 O의 k+1번째 작업이 S에 추가될 수 있음을 의미하는데, 이는 모순이다.
    - 따라서 S는 O 만큼의 작업의 개수를 가진다는 것을 알 수 있다.





### Certificate argument

- 방식
  - 알고리즘이 답과 함께 그것이 최적해라는 증거를 함께 출력하도록 하는 방식이다.



- 문제 및 그리디를 통한 해결
  - Interval schduling 문제의 변형
    - 여러 작업들의 시작 시간과 종료 시간이 주어질 때, 모든 작업을 처리하기 위한 기계의 개수를 구하는 문제.
    - 이전과는 달리 하나 이상의 기계를 사용할 수 있다.
    - 모든 작업을 처리해야하는데, 최소한의 기계만을 사용하여 모든 작업을 처리하고자한다.
    - 마찬가지로 하나의 기계는 하나의 작업만을 처리할 수 있으며, 한 작업이 끝남과 동시에 다른 작업을 처리할 수 있다.
    - 백준의 [강의실 배정](https://www.acmicpc.net/problem/11000)이 이와 유사한 문제이다.
  - 그리디를 활용한 해결 방법
    - 매 시각 t에 시작하는 작업이 있을 때, 지금까지 구매한 기계에 할당할 수 있으면 그것들 중 아무 것에 할당한다.
    - 현재까지 구매한 기계만으로 불가능하다면, 기계를 하나 더 구매하고 거기에 할당한 다음 t* ← t를 기억한다.



- 증명과정
  - 작업의 집합 P가 주어진다.
    - 각 작업 p ∈ P는 s(p)에 시작하고 f(p)에 끝난다.
    - 수행 시간이 겹치는 작업 두 개를 한 기계에 할당할 수 없다.
    - 그러나 한 작업이 끝날 때 바로 다음 작업을 실행할 수는 있다.
    - 모든 작업의 수행 시간을 [s(p), f(p))로 표현하여, 이러한 조건을 나타낼 수 있다.
  - 이 문제의 목적은 서로 겹치는 작업이 없는 P의 부분 집합들 중 원소의 개수가 가장 작은 부분 집합을 찾아내는 것이다.
    - 서로 겹치는 작업이 없는 P의 부분 집합들의 집합을 S라 한다.
    - 즉 임의의 서로 다른 두 작업 p, p' ∈ S에 대해, $$[s(p), f(p))∩[s(p'), f(p')) = \empty$$이다.
    - 따라서 우리의 목표는 S 중 그 크기가 가장 작은 것을 찾는 것이다.
  - 모든 작업을 소화하기 위해서 최소한 몇 대의 기계가 필요한가?
    - 모든 작업을 수행해야 하므로 어떤 시각에 동시에 수행되는 작업의 개수보다 적지 않아야한다.
    - 즉 임의의 시각 t에 수행되는 작업의 집합을 $$P_t := {p \in P : t \in [s(p),f(p))}$$라고 할 때, 반드시 아래의 정리를 만족해야한다.
  - 정리
    - 모든 작업을 할당하기 위해서는 임의의 시각 t에 대해 $$|P_t|$$ 이상의 기계가 필요하다.
    - 즉, S가 올바른 답이라면 반드시 $$|S|\ge max_t |P_t|$$를 만족한다.
    - 위 정리를 통해 아래와 같은 정리를 이끌어낼 수 있다.
    - 만약 알고리즘이 올바른 답 S와 함께 $$|S|=|P_{t*}|$$인 어떤 시각 t*를 찾는다면, S는 최적해이다.
  - 증명
    - 문제의 최적해를 O라 하자, 이 답은 올바른 답이므로 정리에 의해 $$|O| \ge max_t |P_t| \ge |P_{t*}| = |S|$$를 만족한다.
    - O는 최적해인데, S가 그것보다 크기가 더 작거나 같으므로 S도 최적해이다.
    - 즉, 알고리즘이 S와 함께 $$|S|=|P_{t*}|$$를 만족하는 어떤 시각 t*를 증거로 제출하면, 알고리즘이 최적의 답을 반환한다는 것을 보일 수 있다.



- Interval scheduling 문제에 적용

  - 이전에 살펴본 interval scheduling 문제에 적용하면 아래와 같은 과정을 거친다.
  - 작업들의 집합 P가 주어질 때, OPT(P)는 P의 작업들 중 서로 겹치는 작업이 없는 부분 집합의 최대 원소 개수를 나타낸다.
    - 서로 겹치는 작업이 없는 부분 집합을 S라 한다.
  - OPT(P)의 최솟값은 무엇인가?
    - OPT(P)가 적어도 k보다는 크거가 같다는 사실(즉 k가 OPT(P)의 최솟값이라는 사실)은 S 중 크기가 k 이상인 것이 있음을 보이면 된다.
    - 즉 $$OPT(P) \ge k$$임을 보이기 위해서는 원소의 개수가 k인 S가 있음을 보이면 된다.
    - S가 P의 서로 겹치는 작업이 없는 부분집합일 때, $$OPT(P) \ge |S|$$이 성립한다.
    - 즉 원소의 개수가 k인 S가 있다면 OPT(P)의 최솟값이 k라는 것을 certificate한다.
  - OPT(P)의 최댓값은 무엇인가?
    - Partition이란 P의 원소들 중 서로 시간이 겹치는 작업들을 모아놓은 부분집합이다.
    - 따라서 모든 partition을 합하면 전체 집합(P)가 된다.
    - 하나의 parition 내에서는 작업들 간에 서로 시간이 겹치기 때문에 답을 구하기 위해서는 partition마다 작업을 하나씩만 뽑아야한다(한 partition에서 둘 이상의 작업을 뽑을 경우 서로 겹치는 작업이 생기게 된다).
    - 예를 들어 아래 표에서 작업 시간이 겹치는 p1과 p2를 하나의 partition으로, p3를 하나의 파티션으로, p4, p5를 하나의 파티션으로 묶을 수 있다.
    - 혹은 [p1], [p2,p3], [p4,p5]와 같이 묶을 수도 있다.
    - 만약 $$P_1, ..., P_k$$가 P의 partition이고, 모든 $$i=1, ..., k$$에 대하여 $$P_i$$의 모든 작업들의 쌍이 서로 시간이 겹친다면, $$OPT(P) \le k$$이다.
    - 즉 OPT(P)의 최댓값은 P의 partition의 개수이다.

  |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | p1   | -    | -    | -    |      |      |      |      |      |
  | p2   |      | -    | -    | -    |      |      |      |      |
  | p3   |      |      |      | -    | -    | -    |      |      |
  | p4   |      |      |      |      |      |      | -    | -    |
  | p5   |      |      |      |      |      |      |      | -    |

  - 증명
    - O를 최적해라고 했을 때, 하나의 partition안에 있는 작업들과 O에 있는 작업들 중 겹치는 작업은 최대 1개이다.
    - 한 partition 안에서는 모든 작업들의 시간이 겹치기 때문에, 최적해만 모여있는 O에서는 최대 1개까지만 겹칠 수 있다.
    - 따라서 k개의 partition들 내부의 작업들과  O 내부의 작업들 중 겹치는 것을 모두 합해봐야 k개가 최대이다.
    - $$OPT(P) = O = \sum^k_{i=1} P_i \cap O \le k$$
    - 이렇게 구해진 OPT(P)의 최솟값과, 최댓값을 함께 제시하여 OPT(P)가 최적해임을 보장(certificate)할 수 있다.



### Exchange Argument

> https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf

- Exchange Argument
  - Greedy algorithm의 최적성을 증명하기 위한 강력하고 다재다능한 기법이다.
  - 어떤 최적해를 반복적으로 greedy algorithm이 반환한 해로 변환해준다.
    - 이를 통해 greedy algorithm이 반환한 해가 최적해임을 증명한다.



- 일반적인 과정

  - Solution을 정의한다.
    - Greedy algorithm과 이것이 반환할 해를 정의한다.
    - Exchange Argument는 greedy algorithm이 반환한 해인 X를 최적해인 X*와 비교하는 방식으로 동작하기에 해를 명확하게 정의하는 것이 중요하다.
  - 해들을 비교한다.
    - 만약 X가 X*와 같지 않다면, 어디가 같지 않은지를 보여야한다.
    - 예를 들어 X의 일부가 X*에는 포함되지 않거나, X에 포함되어 있는 2개의 원소가  X\*에도 포함은 되어 있지만, 포함된 순서가 다를 수 있다.

  - Piece들을 교환(exchange)한다.
    - X*의 일부(piece)가 어떻게 X의 일부로 변환되는지를 보여야한다.
    - 일반적으로, 이전 단계에서 정의한 piece를 사용한다.
    - 이렇게 함으로써, X*의 cost를 증가시키거나 감소시키지 않고 최적해를 구할 수 있다.
  - 반복한다.
    - 최적해의 quaility에 영향을 주지 않으면서 교환을 수행함으로써 X와 X*의 차이를 줄이는 작업을 반복적으로 수행하여 X\*를 X로 변환한다.
    - 이를 통해 X는 최적해가 된다.
    - 즉 아래 과정을 통해서 최적해 O가 greedy를 통한 해 G로 순차적으로 변환된다.
    - O(최적) → O'(최적) → O''(최적) → O'''(최적) → ... → A(최적)



- 주의사항
  - X != X*라도 X가 최적해일 수 있다.
    - 한 문제에 대한 여러 개의 최적해가 있을 수 있기 때문이다.
    - 따라서 X!=X*라도 모순이 발생하지 않을 수 있다.
    - 만약 최적해가 단 1개뿐이라면, 모순이 발생할 것이다.
  - 한 번만 변환한다고 X*가 X가 되는 것은 아니다.
    - 한 번의 변환은 X*를 X가 서로 더 유사해지게는 하지만, X와 X\*가 동일한 상태가 된다는 것을 보장하지는 않는다.
    - 따라서 반복적으로 변환을 수행해야 하며, 모든 반복에는 해당 절차가 반복되어야하는 정당한 이유가 있어야한다.
  - X*를 X로 변환해야하는 이유가 명확해야한다.



- Minimize Lateness 문제
  - 수행해야 할 여러 개의 작업이 주어진다.
    - 각각의 작업에는 수행하는 데 걸리는 시간과 서로 다른 마감 기한이 있다.
  - 작업을 수행할 수 있는 기계는 1개 뿐이고, 기계는 여러 개의 작업을 동시에 진행할 수 없을 때, L의 최솟값을 구하라.
    - lateness는 한 작업이 작업 기한을 넘긴 정도중 최대값을 의미한다.
    - 예를 들어 마감 기한이 3인 A 작업을 4에 마쳤다면 lateness는 1이 된다.
    - L은 여러 작업의 lateness 중 최댓값을 의미한다.
    - 예를 들어 마감 기한이 3인 A 작업을 4에 마치고, 마감 기한이 4인 작업 B를 6에 마쳤다면 L은 작업 B가 기한을 넘긴 정도인 2가된다.
    - L의 값 중 최솟값을 찾아야한다.



- Exchange argument 적용

  - 문제 형식화하기

    - $$t_j$$는 작업 j를 완료하는 데 걸리는 시간이다.
    - $$d_j$$는 작업 j의 마감 기한이다.
    - $$s_j$$는 작업 j의 작업 시작 시각이다(이는 알고리즘에 의해 정해진다).
    - $$f_j=s_j+t_j$$는 작업 j가 끝나는 시각이다.
    - $$l_j$$는 작업 j의 lateness이다.

    $$
    l_j = \begin{cases}
    0 & \mbox{if}\ f_j \le d_j \\
    f_j - d_j, & \mbox{if }\ f_j > d_j
    \end{cases}
    $$

    - $$L=max_jl_j$$은 lateness 중 최댓값이다.

  - 목표는  L이 최솟값이 되는 일정을 찾는 것이다.

    - 이를 위해 여러 가지 정렬 방식이 있을 수 있다.
    - 작업 기간($$t_j$$)을 기준으로 정렬
    - 마감 기한($$d_j$$)을 기준으로 정렬
    - $$d_j-t_j$$ 기준으로 정렬
    - 이들 중 마감 기한을 기준으로 정렬했을 때만 최적해를 얻을 수 있다.

  - 증명 방식

    - 최적해 O와 greedy에 의해(마감 기한을 기준으로 정렬) 얻어진 해 G가 있다.
    - O와 G가 같지 않다고 가정한다. 
    - 새로운 해 O'를 얻기 위해 O를 수정할 수 있다.
    - O'는 O보다 나쁘지 않으며, G와 더 유사하다는 두 가지 조건을 만족해야한다.

  - 유휴시간

    - 이전 문제들과는 달리 시작 시각이 정해진 것이 아니다.

    - 시작 시각이 정해진 것이 아니기에 작업과 작업 사이에 아무 작업도 두지 않는 유휴시간은 두지 않는다.

  - Inversion

    - 이 문제에서 inversion이란 마감 기한이 더 느린 작업이 마감 기한이 더 빠른 작업보다 앞에 배치되는 상황을 의미한다.
    - 어떤 최적해 O에 inversion이 있다고 가정해보자.
    - 예를 들어 마감 기한이 1,2,3,4,5인 작업들이 있을 때 최적해 O에서 [1,2,3,5,4] 순으로 일정이 정렬되어 있다고 가정해보자.
    - 마감 기한이 더 느린 5가 4 앞에 왔으므로 inversion이 있는데, 이 두 작업을 swap하면 [1,2,3,4,5]가 되고, 이를 O'라고 해보자.
    - 우리가 보이고자 하는 것은 O를 O'처럼 변경하면 O보다 나빠지지 않으면서, G와 더 유사해짐을 보여야한다.

  - O를 O'처럼 변경하면 G와 유사해지는가?

    - G는 greedy에 의해 얻어진 해이므로 inversion이 있을 수 없다. 
    - 따라서 최적해 O에서 inversion을 제거하는 것은 G에 가까워지는 과정이라고 볼 수 있다.

  - O를 O'처럼 변경하면 O보다 나빠지지는 않는가?

    - 이 문제에서 O'가 O보다 나쁘지 않다는 것의 의미는 L이 더 커지지 않는다는 것을 의미한다.
    - 유휴시간이 없으므로, O가 O'가 된다고 L이 더 커지지는 않기에 나빠지지 않는다.

  - 따라서 O를 G로 변경하는 것이 가능하므로 G는 최적해라고 볼 수 있다.



- Interval scheduling 문제에 적용
  - 기호 정리
    - G = p<sub>1</sub>, ..., p<sub>k</sub>를 greedy algorithm에 의해 선택된 작업들이라고 가정한다.
    - O = q<sub>1</sub>, ..., q<sub>l</sub>를 최적해를 산출하는 algorithm에 의해 선택된 작업들이라고 가정한다.
    - 두 집합 모두 종료 시각을 기준으로 정렬되어 있다.
  - O를 A로 변환하면서 A가 최소한 O가 가지고 있는 만큼의 작업을 가지고 있다는 것을 보이는 것이 목표이다.
  - p<sub>i</sub>, q<sub>i</sub>가 서로 다른 최초의 element들이라고 가정해보자.
    - 즉, p<sub>i-1</sub>, q<sub>i-1</sub>까지는 서로 같았다.
    - p<sub>i-1</sub>, q<sub>i-1</sub>까지는 서로 같았기 때문에,  p<sub>i</sub>와 q<sub>i</sub>는 q<sub>1</sub>, ..., q<sub>i</sub>까지 중 어떤 것과도 작업 시간이 겹치지 않는다.
    - 또한 G는 가장 빨리 끝나는 작업들을 선택하므로,  p<sub>i</sub>의 종료 시각은 q<sub>i</sub>의 종료 시각보다 빠르거나 같다.
    - 따라서,  p<sub>i</sub>는 q<sub>i+1</sub>과 작업 시간이 겹치지 않는다.
    - 따라서 O에서 q<sub>i</sub>를  p<sub>i</sub>로 바꾼다 하더라도 O 집합 내에서 작업들은 여전히 겹치지 않으므로,  q<sub>i</sub>를  p<sub>i</sub>로 교체가 가능하다.
    - 이를 O가 G가 될 때까지 반복하면 된다.
  - O는 G 보다 많은 원소를 가질 수 없다.
    - 위 방식을 반복하면 O의 모든 원소를 G로 변환할 수 있다.
    - 만약 O가 G에 없는 작업을 가지고 있다면, 이 원소는 O에 있는 어떤 작업과도 겹쳐선 안된다.
    - 그런데 이는 G에 있는 어떤 작업과도 겹칠 수 없으므로 만약 그런 작업이 있었다면 G에도 포함되었을 것이다.
    - 그러므로 O는 G보다 많은 원소를 가질 수 없다.







# Raft Consensus Algorithm

> https://seongjin.me/raft-consensus-algorithm/
>
> [Paxos 보다 쉬운 Raft Consensus](https://medium.com/rate-labs/raft-consensus-%EC%9D%B4%ED%95%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%97%AC%EC%A0%95-f7ecb9f450ab)
>
> [In Search of an Understandable Consensus Algorithm](https://raft.github.io/raft.pdf?ref=seongjin.me)

- 뗏목 합의 알고리즘

  - 다수 노드로 이루어진 분산 시스템에서 전체 노드의 최신화 및 동기화 그리고 내결함성(False Tolerance)을 동시에 구현하기 위해 만들어진 합의 알고리즘이다.
    - 내결함성이란 시스템의 일부 구성 요소가 작동하지 않더라도 전체 시스템은 계속 작동할 수 있는 기능을 의미한다.
  - Diego Ongaro와 John Ousterhout이 [In Search of an Understandable Consensus](https://raft.github.io/raft.pdf?ref=seongjin.me)라는 논문을 통해 처음 소개했다.
    - 같은 목적을 위해 고안된 다른 알고리즘보다 이해와 구현이 쉬운 알고리즘을 만드는 것을 목표로 하여 만들어졌다.
  - Raft라는 이름을 붙인 이유
    - 통나무들(logs)을 모아서 무엇을 할 수 있을지를 생각하다 뗏목이 떠올랐다.
    - 기존에 널리 쓰이던 합의 알고리즘은 Paxos 알고리즘이라는 섬으로부터 탈출할지를 생각했다.
  - 합의(consensus)
    - 내결함성을 가진 분산 시스템의 기본이 되는 개념이다.
    - 분산 시스템 내에서 특정 데이터에 대한 동일한 값을 유지하기 위해 고안된 개념이다.
    - 분산 시스템 내의 노드들이 특정 데이터에 대한 동일한 값을 유지함으로써 일부 노드에 장애가 생기더라도 전체 시스템은 일관된 값을 제공할 수 있다.

  - 많은 분산 시스템이 채택한 알고리즘이다.
    - Kubernetes의 etcd
    - Docker swarm
    - MongoDB의 replica set



- Node의 종류
  - Leader
    - 클러스터를 대표하는 하나의 노드.
    - 클라이언트가 클러스터로 보낸 명령의 수신 및 전파, 그리고 클라이언트로의 응답을 처리한다.
    - 자신의 상태 메시지(heartbeat)를 주기적으로 모든 팔로워에게 전파한다.
  - Follower
    - 클러스터 내에서 리더가 아닌 모든 노드들.
    - 리더로부터 전파된 명령을 처리하는 역할을 수행한다.
  - Candidate
    - 리더가 없는 상황에서 새 리더를 정하기 위해 전환된 follower.
    - 리더로부터 일정 시간 이상 상태 메시지(heatbeat)를 받지 못한 팔로워는 candidate로 전환된다.



- 메시지 전파 방식
  - 리더는 수신된 명령에 대한 log를 생성하여 로컬에 저장한 뒤 모든 팔로워에게 복제하여 전달한다.
    - 각 팔로워는 전달받은 로그에 대한 응답을 다시 리더에게 보낸다.
  - 리더가 수신한 정상 응답 수가 클러스터 전체 노드의 과반수에 이르면, 리더는 로그를 통해 전파된 명령을 클러스터의 모든 노드가 동일하게 수행하도록 한다.
    - 그리고 그 결과를 클라이언트에게 반환한다.
    - 리더는 해당 로그를 클러스터 전체 노드가 똑같이 보유할 때 까지 로그 재전송을 주기적으로 반복한다.
  - 제 때 명령을 처리하지 못 한 팔로워가 있더라도, 그 팔로워는 정상 상태로 복구된 뒤 클러스터와의 연결이 재개되면 리더로부터 그동안의 명령 처리 기록이 포함된 로그들을 다시 전달받아 순차적으로 진행한다.



- 리더 선출
  - 관련 용어
    - Term: 새로운 선거가 시작된 시점주터 그 선거로 선출된 리더가 리더로서 기능하는 동안까지의 시간을 의미한다.
    - Election Timeout: 팔로워 상태의 노드가 후보자로 변환되기까지 대기하는 시간으로, 150~300ms 사이의 각기 다른 임의의 값이 주어진다.
    - Heartbeat: 리더가 다른 모든 팔로워에게 일정 시간 간격으로 반복 전달하는 메시지이다.
  - 리더 선출 과정
    - Term 번호가 부여되고, 클러스터 내의 각 노드들에 임의의 election timeout이 부여된다.
    - 리더가 없는 상태에서 모든 노드가 팔로워 상태를 유지하며, 각자에게 주어진 election timeout이 될 때까지 대기한다.
    - Election timeout에 가장 먼저 도달한 노드가 후보자로 전환되고, 새로운 term이 시작된다.
    - 후보자 노드는 자신에게 투표한 뒤 다른 노드들에게 투표 요청 메시지를 전송한다.
    - 만약 투표 요청 메시지를 수신한 노드가 해당 term 중에 아직 투표한 적이 없다면, 해당 메시지의 발신한 후보자 노드에게 투표 메시지를 보낸 후 자신의 election timeout을 초기화한다(이를 통해 선거 기간 중에 다른 후보자가 나오지 않게 된다).
    - 전체 노드 수의 과반에 해당하는 응답을 얻은 노드는 해당 term에 대한 새로운 리더로 선정된다.
  - 리더 노드가 리더 역할을 유지하는 방식
    - 리더 노드는 모든 팔로워 노드들에게 주기적으로 heartbeat를 전송한다.
    - 팔로워 노드는 리더 노드로부터 heartbeat를 받을 때 마다 자신의 election timeout을 초기화한다.
    - 이를 통해 리더가 정상적으로 동작하는 동안에는 새로운 후보자 노드가 나오지 않게 된다.
  - 리더에 문제가 생길 경우
    - 리더에 문제가 생겨 heartbeat를 전송하지 못할 경우 election timeout에 도달하는 노드가 생기게 된다.
    - Election timeout에 도달한 node는 후보자 노드로 전환되고, term 번호가 1 증가하게 된다.
    - 이후 위에서 살펴본 과정대로 리더 선출을 진행한다.
  - Term 번호의 역할
    - 클러스터의 모든 노드는 현재의 term 번호를 저장해두고, 서로 메시지를 주고 받을 때 이 번호도 함께 전송한다.
    - 문제가 생겼던 이전 리더 노드가 복구되면, 이 노드는 클라스터가 공유하는 term 번호와 자신의 term 번호를 비교한다.
    - 현재 클러스터 내에서 공유중인 term 번호가 자신의 번호가 낮은 것을 확인하면, 이전 리더 노드는 팔로워 노드로 전환된다.
  - 과반을 얻지 못하는 경우
    - 예를 들어 4개의 노드로 구성된 클러스터에서 매우 낮은 확률로 두 개의 노드가 동시에 후보자 노드가 되고, 이들이 각 2표씩을 얻는 경우가 있을 수 있다.
    - 이럴 경우 그대로 해당 term을 종료하고 새로운 term 번호와 함께 재선거를 시작한다.



- 정족수(Quorum)

  - 합의 알고리즘에서 일정 합의에 이르기 위해 필요한 수를 의미한다.
    - 뗏목 알고리즘에서 새로운 리더를 선출하기 위해서는 과반(`(N+1)/2`)이상의 응답을 얻어야 하므로, 이 때의 정족수는 `(N+1)/2`이다.
  - 클러스터의 관리 및 내결함성을 유지하는데 사용된다.
    - 정족수가 충족되지 않을 경우 클러스터가 제대로 기능할 수 없게 된다.
  - 내결함성을 위한 최적의 노드 수
    - 대부분의 합의 알고리즘을 채택한 분산 시스템에서는 전체 노드 수를 3 이상의 홀수로 두는 것을 권장한다.
    - 아래 표에서 확인할 수 있듯, 전체 노드 수가 3개일 때 부터 일부 노드에 장애가 발생해도 내결함성을 유지할 수 있다.
    - 또한 짝수로 구성하는 것도 가능은 하지만, 정족수의 비율이 홀수인 경우에 비해 높다는 단점이 있다.
    - 예를 들어 전체 노드가 3개인 경우나 4개인 경우 모두 허용 가능 장애 노드의 수는 1로 동일하지만, 정족수는 4개인 경우가 더 높다.
    - 그리고 짝수일 경우 후보자들이 동일한 수의 표를 얻어 재선거를 해야 하는 경우가 생길 수 있으므로 홀수로 설정하는 것이 좋다.

  | 전체 노드 수 | 정족수 | 허용 가능 장애 노드 수 |
  | ------------ | ------ | ---------------------- |
  | 1            | 1      | 0                      |
  | 2            | 2      | 0                      |
  | 3            | 2      | 1                      |
  | 4            | 3      | 1                      |
  | 5            | 3      | 2                      |
  | 6            | 4      | 2                      |
  | 7            | 4      | 3                      |
  | 8            | 5      | 3                      |
  | ...          | ...    | ...                    |
  | 2k           | k+1    | k-1                    |
  | 2k+1         | k+1    | k                      |



- Log
  - Log
    - Log는 index, term 번호, 상태 변경 명령으로 구성된 entry의 집합이다.
    - index와 term 번호가 같다면 같은 명령을 저장하고 있어야하는데, 이를 Log Matching이라한다.
  - Commit entry
    - Log는 leader가 생성하고, 과반수 이상의 서버에 복제되면 commit 된 것으로 간주한다.
    - 커밋할 때는 이전에 생성한 모든 로그까지 한꺼번에 commit한다.
    - 한 번 commit된 entry는 다음 term의 leader들에게 반드시 포함되는데, 이를 Leader Completeness라 부른다.
  - Log 복제 과정
    - Client가 leader node에게 data를 전송한다.
    - Leader node는 해당 data를 저장하고 있다가 다음 heartbeat를 다른 노드들에게 전송할 때 이 data를 log로 만들어서 함께 전송한다.
    - Follower 들 중 과반 이상이 해당 요청을 정상적으로 받을 경우 값이 commit 된다.
    - Leader는 client에게 응답을 보낸다.



- 구현
  - [simpleRaft](https://github.com/streed/simpleRaft) github repository에서 Python으로 raft algorithm을 구현한 코드를 볼 수 있다.
  - 다른 언어로 구현한 ratf alogrithm은 [링크](https://raft.github.io/?ref=seongjin.me)에서 볼 수 있다.