> 아키텍처도, 깨끗한 코드도, 완벽을 주장하지는 않는다. 단지 최선을 다해 정직하라 요구할 뿐이다. 오류는 인간의 본성이고 용서는 신의 본성이다. 스크럼에서 우리는 모든 것을 드러낸다. 더러운 빨래를 기꺼이 공개한다. 코드는 결코 완벽하지 않으므로 자신의 코드 상태를 정직하게 말한다. 좀 더 인간적이 되고, 좀 더 신의 용서를 받을 자격을 갖추며, 좀 더 세세함에 깃든 위대함에 가까워진다.
>
> -추천사에서 제임스 O. 코플리엔



# 깨끗한 코드

> 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다.
>
> ...
>
> 나중은 결코 오지 않는다.

- 나쁜 코드는 생산성 저하의 원인이다.
  - 개발 일정 등을 핑계로 급하게 짠 나쁜 코드는 언젠가는 개발 속도를 늦추는 원인이 된다.
  - 장기적인 관점에서 볼 때, 개발 일정을 맞추는 유일한 방법은 코드를 깨끗한 상태로 유지하는 일이다.



- 무엇이 깨끗한 코드인가

  - 비야네 스트롭스트룹(C++ 창시자)
    - 우아하고(누구에게나 쉽게 읽히며) 효율적인(속도가 빠르고 자원 낭비가 적은) 코드
    - 논리가 간단해야 버그가 숨어들지 못한다.
    - 의존성을 줄여야 유지보수가 쉬워진다.
    - 오류는 명백한 전력에 의거해 철저히 처리한다.
    - 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.
    - **깨끗한 코드는 한 가지를 제대로 한다.**
  - 그래디 부치
    - 깨끗한 코드는 단순하고 직접적이다.
    - 잘 쓴 문장처럼 읽힌다.
    - 결코 설계자의 의도를 숨기지 않는다.
    - 명쾌한 추상화와 단순한 제어문으로 가득하다.

  - 데이브 토마스
    - 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
    - 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
    - 깨끗한 코드에는 의미 있는 이름이 붙는다.
    - 특정 목적을 달성하는 방법은 여러 가지가 아닌 하나만 제공한다.
    - 의존성을 최소화하며 각 의존성을 명확히 정의한다.
    - API는 명확하며 최소화한다.
    - 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.
  - 마이클 페더스
    - 깨끗한 코드는 누군가 주의 깊게 짰다는 느낌을 준다.
    - 고치려고 살펴봐도 딱히 손 댈 곳이 없다.
  - 론 제프리스
    - 모든 테스트를 통과한다.
    - 중복이 없다.
    - 시스템 내 모든 설계 아이디어를 표현한다.
    - 클래스, 메서드, 함수 등을 최대한 줄인다.

  - 워드 커닝햄
    - 코드를 읽으면서 짐작했던 기능들을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
    - 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
    - 즉 읽으면서 짐작한 대로 동작하는 코드가 깨끗한 코드다.



# 의미있는 이름

- 소프트웨어에서 이름은 어디나 쓰인다.
  - 변수, 함수, 인수, 클래스, 패키지, 소스파일, 파일이 담긴 디렉터리 등 모든 것에 이름을 붙인다.
  - 좋은 이름을 붙이는 데는 시간이 걸리지만 좋은 이름으로 절약하는 시간은 훨씬 더 많다.
  - 이름을 잘 지으면 여러모로 편리하므로 아래에서는 이름을 잘 짓는 몇 가지 원칙을 소개한다.



## 의도를 분명히 밝혀라

- 이름에는 의도가 담겨야한다.
  - 이름은 다음과 같은 질문에 모두 답해야 한다.
    - 변수의 존재 이유
    - 수행하는 기능
    - 사용 방법
  - 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.



- 나쁜 코드

  ```python
  def get_them(the_list):
      list1 = []
      for x in range(the_list):
          if the_list[0]==4:
              list1.append(the_list[x])
  	return list1
  ```

  - 단순한 코드임에도 알아보기 어렵다.
  - 문제는 코드의 단순성이 아니라 함축성이다.
  - 위 코드엔 아래와 같은 정보가 드러나지 않는다.
    - `the_list`에 무엇이 들어있는가
    - `the_list`에서 0번째 값이 왜 중요한가
    - 4는 어떤 의미인가?
    - 함수가 반환하는 `list1`을 어떻게 사용하는가?



- 좋은 코드

  ```python
  def get_flagged_cells(game_board):
      flagged_cells = []
      for cell in game_board:
          if cell[STATUS_VALUE]==FLAGGED:
              flagged_cells.append(cell)
      return flagged_cells
  ```

  - 코드만 보고도 아래의 사실이 유추가 가능하다.
    - game_board 안에는 게임 판의 cell 들이 들어 있다.
    - 각 cell의 STATUS_VALUE번째 값은 칸의 상태를 뜻한다.
    - FLAGGED는 깃발이 꽂힌 상태를 뜻한다.
    - 반환값인 `flagged_cells`는 깃발이 꽂힌 칸이 담긴다.
  - 위 코드만 보고도 지뢰 찾기 게임 코드의 일부라는 사실을 알 수 있다.



## 그릇된 정보를 피하라

- 코드에 그릇된 단서를 남겨서는 안된다.
  - 그릇된 단서는 코드의 의미를 흐린다.



- 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다.
  - 예를 들어 직각 삼각형의 빗변(hypotenuse)을 hp로 줄이는 것은 읽는 사람들에게 그릇된 정보를 제공한다.



- 그룹으로 묶을 때, 실제로 list에 의해 묶여 있는 것이 아니라면 list라 명명하지 않는다.
  - 예를 들어 계정 정보를 묶을 때 실제 list로 묶은 것이 아니라 set 등에 저장했다면 account_list와 같은 이름은 사용하지 않는다.
  - 대신 account_group, bunch_of_account, accounts라 명명한다.



- 서로 흡사한 이름을 사용하지 않도록 주의한다.
  - 흡사한 이름은 보는 사람으로 하여금 혼동을 일으킨다.
  - 예를 들어 한 모듈에서 controller_for_efficient_handling_of_strings라는 이름을 사용하고, 다른 모듈에서 controller_for_efficient_storage_of_strings라고 사용한다면 보는 사람이 혼동일 일으킬 수 있다.



- 유사한 개념은 유사한 표기법을 사용한다.
  - 일관성이 떨어지는 표기법은 그릇된 정보다.



## 의미 있게 구분하라

- 동일한 범위 내에서 다른 두 개념에는 동일한 이름을 사용하지 못한다.
  - 따라서 이 둘의 이름은 개념의 특색에 따라 구분되어야 한다.



- 연속된 숫자를 덧붙이는 방식은 적절하지 못하다.

  ```python
  def some_func(a1, a2):
      pass
  ```



- 불용어를 추가하는 것은 적절치 못하다.

  - 예를 들어 product라는 이름이 이미 존재한다고 해서 아래와 같이 아무런 의미도 없는 불용어를 추가해서 사용하는 것은 문제가 될 수 있다.
  - 이름을 가지고 정확히 무슨 역할을 하는 변수인지 구분이 가지 않는다.

  ```python
  a_product = None
  products = []
  the_product = "product"
  ```

  - 물론 특정한 규칙을 가지고 불용어를 사용하는 것은 문제가 되지 않는다.
    - 예를 들어 모든 지역 변수에는 `a`를 붙이고 모든 함수 인수는 `the`를 붙이는 것과 같이 변수명을 통해 해당 변수의 역할을 유추할 수 있으면 된다.
  - data, info 같은 경우도 마찬가지로 의미가 불분명한 불용어이다.
    - 아래 변수명들이 각기 어떤 데이터를 담고 있는지를 이름만 보고는 파악하기 힘들다.
    - active_account, active_accounts, active_account_info, active_account_data



- 중복을 피해라
  - 코드 이름을 역전앞과 같이 중복되게 지어서는 안된다.
  - 변수명에 variable 같은 단어는 금물이다.
    - name과 구분하기 위해 변수명을 name_variable이라고 짓는다고 해서 name_variable이 name에 비해 추가적인 정보를 제공하는 것은 아무 것도 없다.
  - name_string과 같은 변수명도 마찬가지다.
    - name은 string 이외의 타입을 담고 있다고 생각하기는 힘들기에 사실상 중복된 이름이라고 할 수 있다.





## 맥락



- 의미 있는 맥락을 추가하라

  - 스스로 의미가 분명한 이름이 없지 않다.
    - 하지만 대다수 이름은 그렇지 못하다.
    - 따라서 이름을 클래스, 혹은 함수 내의 맥락에서 해석되도록 할 수 있다.
  - 나쁜 예시
    - 아래 변수명은 끝까지 읽어보면 학생에 대한 정보들을 저장한 변수라는 것을 알 수 있다.
    - 그러나 만일 `get_address` 라는 함수에서 address라는 변수 하나만 사용한다면 해당 address가 어떤 address인지 알 수 없을 것이다.

  ```python
  first_name
  last_name
  age
  address
  grade
  student_number
  ```

  - 좋은 예시
    - 클래스라는 맥락을 부여하여 학생에 관한 정보라는 것을 분명히 해준다.

  ```python
  class Student:
      def __init__(self, first_name, last_name, age, 
                   address, grade, student_number):
          self.first_name=first_name
          self.last_name=last_name
          self.age=age
          self.address=address
          self.grade=grade
          self.student_number=student_number
  ```



- 불필요한 맥락을 없애라
  - 일반적으로 짧은 이름이 긴 이름보다 좋다.
    - 단, 의미가 분명한 경우에 한해서다
    - 이름에 불필요한 맥락을 추가하지 않도록 주의한다.
  - 예를 들어 postal_address와 mac_address, web_address는 인스턴스 이름으로는 적합하지만 클래스 이름으로는 적합하지 못하다.
    - 셋을 구분해야 한다면 PostalAddress, MAC, URI라는 이름이 클래스명으로 더 적합하다.



## 단어

- 한 개념에 한 단어를 사용해라.
  - 추상적인 개념 하나에 단어 하나를 선택해 이를 유지한다.
  - 예를 들어 무언가를 무언가를 조회하는 메서드를 작성할 때 조회라는 동일한 기능을 하면서 아래와 같이 각기 다른 단어를 사용해선 안된다.
    - fetch, retrieve, get



- 힌 단어를 두 가지 목적으로 사용하지 마라

  - "한 개념에 한 단어를 사용해라"라는 규칙을 지키고자 같은 개념이 아닌데도 한 단어를 사용하게 될 수 있다.

  - 예를 들어 기존에 add라는 단어를 두 값을 더해서 새로운 값을 만드는 개념을 표현하기 위해 사용했다고 가정하자.
    - 새로운 메서드는 list에 값 하나를 추가하는 메서드인데, 이 메서드에 add라는 단어를 사용해도 될까?
    - 두 개의 값을 더하는 것과 list에 값을 추가하는 것은 다른 개념이다.
    - 따라서 add가 아닌 insert, append 같이 다른 단어를 사용하는 것이 맞다.



- 코드를 읽을 사람도 프로그래머라는 것을 명심해라
  - 전산 용어, 알고리즘 이름, 자료구조 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.
  - 프로그래머에게 익숙한 기술 개념은 아주 많다.
    - 기술 개념에는 기술 이름이 가장 적합한 선택이다.
    - 예를 들어 순차적으로 저장하여 순차적으로 처리하는 이름이 필요하다면 queue라는 단어를 활용하여 이름을 붙이는 것이 가장 적합한 선택이다.



## 기타

- 발음하기 쉬운 이름을 사용해라
  - 기본적으로 누구나 동일한 발음으로 발음할 수 있는 이름을 사용해야 한다.
  - 만일 같은 이름을 각기 다르게 발음한다면 협업이 힘들어진다.



- 검색하기 쉬운 이름을 사용하라
  - 문자 하나를 사용하는 이름 및 상수는 코드상에서 쉽게 눈에 띄지 않을 뿐더라 검색도 어렵다.
  - 따라서 지나치게 짧은 이름 보다는 긴 이름이 좋다.



- 자신의 기억력을 자랑하지 마라
  - 문자 하나만 사용하는 변수 이름은 문제가 있다.
    - 루프에서 반복 횟수를 세는 i, j, k는 괜찮다.
    - 그 외에는 대부분 적절치 못하다.
  - 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수명은 적절하지 못하다.
    - 즉 자신이 기억하기 쉬운 코드가 아니라 다른 사람이 읽었을 때에도 기억하기 쉬운 이름을 사용해야 한다.
  - 또한 기발한 이름을 피하는 것이 좋다.
    - 기발한 이름은 자신과 유머 감각이 비슷한 사람만 알아들을 수 있다.



- 클래스명과 메서드명

  - 클래스명은 명사나 명사구가 적합하다.

    - 동사는 사용하지 않는다.

    - Customer, WikiPage, Account 등이 좋은 예이다.
    - Manager, Processor, Data, Info 등과 같은 단어는 피해야한다.

  - 메서드명은 동사나 동사구가 적합하다.

    - post_payment, delete_page, save 등이 좋은 예이다.
    - 접근자, 변경자, 조건자 등은 get, set, is 를 붙인다.



# 함수

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

## 작게 만들어라

- 함수를 만드는 첫째 규칙은 '작게!'다.
  - 함수를 만드는 두 번째 규칙은 '더 작게!'다.



- 조건문, 반복문 등에 들어가는 불록은 한 줄이어야 한다.
  - 과장된 표현일 수 있지만, 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.
  - 들여쓰기마다 함수를 새로생성하여 처리한다.
    - 이렇게 하면 바깥은 감싸는 함수(원래 함수)가 더 작아진다.
    - 또한 블록 안에서 호출하는 함수 이름을 적절히 짓는다면 코드를 이해하기도 쉬워진다.



## 한가지만 해라

- 함수가 한 가지만 하는지 판단하는 방법은  추상화 수준이 하나인지 확인하는 것이다.

  - 여기서 추상화란 실제 구현과 얼마나 멀리 떨어져 있는가를 말한다. 
    - 복잡한 실제 구현은 숨기고 목적을 분명히하여 핵심만 드러내는 것이다.
    - 실제 구현과 멀리 떨어져 있을 수록 추상화 수준이 높다고 볼 수있다.
  - 아래 코드는 추상화 수준이 매우 낮은 함수이다(보다 적절한 예시를 찾을 경우 변경).
  
  ```python
  def get_user_name_by_id(user_id):
      user_name_id_pair = []
      for user in users:
          user_name_id_pair.append({user['id']:user['name']})
      
      for id, name in user_name_id_pair.items():
          if id==user_id:
              return name 
  ```
  
  - 위 코드를 추상화하여 아래와 같이 변경할 수 있다.
    - 아래 코드도 `user_name_id_pair = make_name_id_pair()` 부분은 아직 추상화 수준이 높다고 볼 수 는 없다.
    - 추상화 수준이 중간인 `user_name_id_pair = make_name_id_pair()` 부분과 추상화 수준이 높은 `return find_name(user_name_id_pair)`가 혼재되어 있으므로 추상화 수준이 둘이다.
  
  ```python
  def get_user_name_by_id(user_id):
      user_name_id_pair = make_name_id_pair()
      return find_name(user_name_id_pair)
  ```
  
  - 클래스를 활용하면 추가적인 추상화가 가능하다.
    - 맨 처음 작성했던 코드보다 짧아졌을 뿐 아니라 읽기도 편한 코드가 됐다.
    - 함수 안에서 사용된 함수의 이름들을 통해 name과 id의 쌍을 만들고, 해당 쌍을 순회하면서 name을 찾아낸다는 것을 바로 알 수 있게 된다.
  
  ```python
  class User:
      def __init__(self):
          self.name_id_pair = []
  
      def get_user_name_by_id(user_id):
          make_name_id_pair()
          return find_name(self.name_id_pair)
  ```



- 함수가 한 가지만 하는지 확인하는 보다 쉬운 방법
  - 단순히 다른 표현이 아니라 의미 있는 다른 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것이다.
  - 즉 똑같은 내용을 형식만 바꾸는 것이 아니라 함수로 따로 뺐을 때 의미 있는 이름을 붙이는 것이 가능하다면 그 함수는 여러 작업을 하고 있다는 것이다.
  - 또한 한 가지 작업만 하는 함수는 여러 섹션으로 나누기 어렵지만, 여러 가지 작업을 하는 함수는 자연스럽게 여러 섹션으로 나누는 것이 가능하다.



## 함수당 추상화 수준은 하나로

- 한 함수 내에  추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
  - 특정 표현이 근본 개념인지 아니면 세부사항인제 구분하기 어려운 탓이다.
  - 근본 개념과 세부 사항을 뒤섞기 시작하면, 깨어진 창문 처럼 사람들이 함수에 세부사항을 점점 더 추가한다.



- 내려가기 규칙
  - 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
    - 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.
    - 이것을 내려가기 규칙이라 부른다.





## Switch문

- switch문은 작게 만들기 어렵다.
  - case가 증가할 수록 길이는 점점 길어진다.
  - 또한 기본적으로 N가지 일을 처리하기 위한 문이기 때문에 한 가지 작업만 하기도 힘들다.
  - 불행하게도 switch문을 완전히 피할 방법은 없다.
    - 그러나 다형성을 활용하여 그나마 잘 사용하는 방법은 존재한다.



- 다형성을 활용하기

  - 원본
    - 직원 유형에 따라 봉급을 계산해서 반환하는 함수다.

  ```java
  public Money calculatePay(Employee e) throws InvalidEmployeeType{
      switch (e.type){
          case COMMISIONED:
              return calcualteCommissionedPay(e);
          case HOURLY:
              return calculateHourlyPay(e);
          case SALARIED:
              return calculateSalariedPay(e);
          default:
              throw new InvalidEmployeeType(e.type);
      }
  }
  ```

  - 위 함수에는 몇 가지 문제가 있다.
    - 첫째로 함수가 길다. 새로운 직원 유형을 추가할 때마다 switch문이 계속 길어진다.
    - 둘쨰로 한 가지 작업만을 수행하지 않는다.
    - 셋째로 SPR(Single Responseibility Principle)을 위반한다(코드를 변경할 이유가 여럿이기 때문이다).
    - 넷째로 OCP(Open Closed Principle)을 위반한다(새 직원 유형을 추가할 때마다 코드를 변경해야 하기 때문이다).
    - 마지막으로 `calculatePay` 함수와 같이 직원 유형에 기반하여 처리를 해줘야 하는 다른 함수들(`isPayDay`, `deliverPay`) 등이 있을 경우 모두 저런 switch문이 들어가야 한다.
  - 해결
    - switch문을 추상 팩토리에 숨긴다.
    - 팩토리는 switch문을 사용해 적절한 Employee 파생 클래스의 인스턴스를 생성한다.
    - `calculatePay` 등의 함수는 Employee 인터페이스를 거쳐 호출되는데, 다형성으로 인해 실제 파생 클래스의 함수가 실행된다.

  ```java
  public abstract class Employee {
      public abstract boolean isPayDay();
      public abstract Money calculatePay();
      public abstract void deliverPay(Money pay);
  }
  
  public interface EmployeeFactory {
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
  }
  
  public class EmployeeFactoryImpl implements EmployeeFactory {
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;{
          switch (e.type){
              case COMMISIONED:
                  return new CommisionedEmployee(r);
              case HOURLY:
                  return new HourlyEmployee(r);
              case SALARIED:
                  return SalariedEmployee(r);
              default:
                  throw new InvalidEmployeeType(r.type);
          }
      }
  }
  ```



## 서술적인 이름을 사용해라

- 이름이 길어도 괜찮다.
  - 길고 서술적인 이름이 짧고 어려운 이름보다 낫다.
  - 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
  - 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.



- 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
  - 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.



- 이름을 붙일 때는 일관성이 있어야 한다.
  - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.



## 함수 인수

- 함수에서 이상적인 인수 개수는 0개다.
  - 다음은 1개(단항)고, 다음은 2개(이항)다.
  - 3개는 가능한 피하는 편이 좋고, 4개 이상은 특별한 이유가 필요하다.
    - 4개 이상은 특별한 이유가 있어도 사용하면 안 된다.



- 인수가 적어야 하는 이유
  - 인수가 많을 수록 코드를 읽고 직관적으로 이해하기 어렵게 만든다.
  - 테스트도 어렵게 만든다.
    - 갖가지 인수를 가진 함수를 검증하는 테스트 케이스를 작성하는 것은 매우 귀찮은 일이다.
    - 반면에 아예 인수가 없는 함수를 검증하는 것은 매우 간단하다.
    - 인수가 3개를 넘어가면 인수마다 유효한 값으로 모든 조함을 구성해 테스트하기가 상당히 부담스러워진다.



- 많이 쓰는 단항 형식
  - 함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다.
    - 하나는 인수에 질문을 던지는 경우다(e.g.`file_exists("my/file/path")`).
    - 다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다.
  - 다소 드물게 사용하지만 아주 유용한 단항 함수 형식이 이벤트다.
    - 단, 이벤트 함수는 조심해서 사용해야 한다.
    - 이벤트라는 사실이 코드에 명확히 드러나야 한다.
  - 위의 경우들이 아니라면 단항 함수는 가급적 피한다.



- 플래그 인수
  - 플래그 인수는 추하다.
    - 함수에 부울 값을 넘기는 관례는 정말로 끔찍하다.
    - 플레그가 참이면 이걸 하고, 거짓이면 저걸 한다는, 즉 함수가 한 번에 여러 가지를 처리한다는 뜻이기 때문이다.
  - 따라서 플래그 인수를 받는 함수는 되도록 두 개의 함수로 나누는 것이 바람직하다.



- 이항 함수
  - 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
  - 이항 함수가 적절한 경우도 있다.
    - 예를 들어 직선 상의 좌표(x, y)는 일반적으로 인수 2개를 취해야 한다.
    - 위 처럼 한 값(좌표)를 표현하는 데 두 개의 요소가 필요할 경우 또는 두 개의 인수 사이에 자연스러운 순서가 존재할 경우(x좌표는 y좌표보다 항상 앞에 있다) 이항 함수를 쓰는 것이 적절하다.
  - 이항 이상의 함수의 가장 큰 문제 중 하나는 인수의 순서를 헷갈릴 수 있다는 것이다.
    - 예를 들어 x좌표와 y 좌표 사이에는 자연스러운 순서가 존재해서, 인수를 넘길 때 헷갈릴 일이 많지 않다.
    - 그러나 expected와 actual이라는 두 개의 인수를 넘길 때, 두 인수 사이에는 자연스러운 순서가 존재하지 않으므로(혹은 사람마다 자연스러운 순서가 다를 수 있으므로) 첫 번째 인수가 expected인지, 두 번째 인수가 actual인지 헷갈릴 수 있다.
  - 이항 함수가 무조건 나쁘다는 것은 아니다.
    - 프로그래밍을 하다보면 불가피한 경우도 있다.
    - 그러나, 위험이 따른다는 사실을 인지하고 가능하면 단항 함수로 바꾸도록 노력해야 한다.
    - 예를 들어 두 개의 인자를 받아야 하는 경우 하나의 인자를 클래스의 attribute로 만들어 하나만 받도록 할 수 있다.



- 삼항 함수
  - 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
  - 따라서 삼항 함수를 만들 때는 신중히 고려해야한다.



- 인수 객체

  - 인수가 2-3개 필요하다면 인수의 일부를 독자적인 클래스 변수로 선언할 수 있는지 살펴본다.
  - 예시

  ```python
  # 아래와 같이 3개의 인수를 넘겨야 하는 경우에
  def make_circle(x:int, y:int, redius:float):
      pass
  
  # x, y를 Point라는 클래스의 클래스 변수로 묶어 넘기는 것을 고려해볼법하다.
  def make_circle(center:Point, radius:float):
      pass
  ```



- 가변 인수

  - 때로는 인수 개수가 가변적인 함수도 필요하다.
    - 가변적인 인수 전부를 동등하게 취급하면 list 혹은 dict 형 인수 하나로 취급할 수 있다.
    - 즉 가변인수는 전부 묶어 하나의 인수로 취급한다.
  - 예시
    - 아래 두 함수는 각기 고정된 인수 name과 가변인수로 list와 dict를 받는 이항 함수이다. 

  ```python
  def insert_user(name, *args):
      pass
  
  def insert_user(name, **kwargs):
      pass
  ```



- 동사와 키워드
  - 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
  - 단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.
    - 예를 들어 `write(name)`은 누구나 이름을 쓰는 역할을 한다는 것을 알 수 있다.
    - 좀 더 나은 이름은 `write_field(name)`으로, name이 필드명 중 하나라는 것이 보다 분명히 드러나기 때문이다.
  - 함수 이름에 인수의 순서를 기억할 수 있도록 키워드를 추가하는 것도 좋은 방법이다.
    - `assert_expected_equals_actual`이라는 함수 명은 expected가 먼저 오고, actual이 뒤에 온다는 사실을 함수 이름만 보고도 알 수 있게 해준다.



## 부수효과를 일으키지 마라

- 부수효과

  - 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하는 것이다.
  - 예시
    - 아래 함수가 일으키는 부수 효과는 `Session.initialze()`를 통해 세션을 초기화한다는 것이다.
    - `check_password`만 봐서는 이 함수가 세션을 초기화시킬수도 있다는 사실을 짐작도 할 수 없다.

  ```python
  def check_password(user_name, password):
      user=UserGateWay.find_by_name(user_name)
      if user != None:
          coded_phrase = user.get_phrase_encoded_by_password()
          phrase = crytographer.decrypt(codedPhrase, password)
          if "Valid Password"==phrase:
              Session.initialze()
              return True
      return False
  ```



- 위와 같은 부수 효과는 시간적인 결합을 초래한다.

  -  위 예시에서 `check_password`라는 함수는 세션을 초기화해도 될 때에만 호출이 가능해진다.
    - 즉 세션을 초기화해도 될 때라는 시간에 종속되어 버린다.
  - 이러한 시간적인 결합은 혼란을 일으킨다.

  - 만약 불가피하다면 반드시 함수명에 부수효과를 명시해야 한다(`check_password_and_initalize_session`)
    - 물론 이 경우에도 함수는 한 가지만 해야 한다는 원칙을 위반하기는 하지만 명시하고 위반하는 것이 낫다.



## 명령과 조회를 분리해라

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
  - 즉 객체 상태를 변경하거나, 객체 정보를 반환하거나 둘 중 하나만 해야 한다.
  - 둘 다 하면 혼란을 초래한다.



- 예시

  - `set` 함수는 이름이 attr인 attribute를 찾아, 그 값을 value로 설정한 후 성공하면 true, 실패하면 false를 반환한다.
  - 수행과 응답을 둘 다 하므로 `if set(attr, value)`와 같은 괴상한 코드가 나오게 되는 것이다.

  ```python
  def set(attr, value):
      pass
  
  if set(attr, value):
      pass
  ```



- 올바른 코드

  - set이라는 혼라스러운 함수를 2개의 함수로 분리한다.

  ```python
  if attr_exists("username"):
      set_attr("username", "theo")





## Try/Catch

- try/catch 블록은 코드 구조에 혼란을 일으키며 정상 동작과 오류 처리 동작을 뒤섞는다.

  - 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
  - 예시
    - 아래 코드에서 실제 삭제는 `delete_page_and_all_references` 함수가 담당하지만 `delete_page_and_all_references` 함수 내부에 try/catch문을 넣을 경우 정상 동작과 오류 처리 동작이 뒤섞이게 된다.
    - 따라서 예외 처리를 위한 `delete`함수를 따로 생성하고 호출은 `delete`를 하되, 실제 삭제는 `delete_page_and_all_references`에서 하도록 한다.

  ```python
  def delete_page_and_all_references(page):
      delete_page(page)
      registry.delete_reference(page.name)
  
  
  def delete(page):
      try:
          delete_page_and_all_references(page)
      except Exception as e:
          print(e)
  ```



- 오류 처리도 하나의 작업이다.
  - 오류를 처리하는 함수는 오류만 처리해야 한다.
    - 함수는 한 가지 작업만 해야 한다.
    - 오류처리도 한 가지 작업이다.
  - 예외처리를 하는 함수는 try로 시작해 catch, finally로 끝나야 한다는 말이다.



## 구조적 프로그래밍

- 구조적 프로그래밍
  - 다익스트라가 go to문의 해로움을 주장하면서 대두된 방법론이다.
  - 다익스트라는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 말했다.
    - 즉 함수의 return문은 하나여야 한다.
    - 반복문 안에서 break이나 continue를 사용해선 안된다.
    - go to는 절대로 안된다.



- 구조적 프로그래밍은 함수가 작을 경우 별 이익을 제공하지 못한다.
  - 함수가 아주 클 때에만 상당한 이익을 제공한다.
  - 따라서 함수를 작게 만든다면 간혹 return, continue, break 등을 여러 번 사용해도 괜찮다.
  - 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.
  - 다만 go to문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해야 한다.



## 함수를 어떻게 짜는가

- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다.
  - 먼저 생각을 기록한 후 읽기 좋게 다듬는다.
  - 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.



- 함수를 짤 때도 마찬가지다.

  - 처음에는 길고 복잡하며, 들여쓰기 단계도 많고, 중복된 루프도 많으며, 인수도 아주 많다. 이름은 즉흥적이고 코드는 중복된다.

  - 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트도 만든다.
  - 그런 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
  - 이 와중에도 코드는 항상 단위 테스트를 통과한다.
  - 최종적으로는 이 장에서 설명한 규칙을 따르는 함수가 얻어진다.





# 주석

> 나쁜 코드에 주석을 달지 마라. 새로 짜라.
>
> -브라이언 W. 커니핸, P.J. 플라우거

- 경솔하고 근거 없는 주석은 코드를 이해하기 어렵게 만든다.

  - 잘 달린 주석은 그 어떤 정보보다 유용하다.

  - 그러나 대개의 경우 주석은 순수하게 선하지 못하다.
    - 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다.
    - 사실상 주석은 기껏해야 필요악이다.
    - 우리에게 프로그래밍 언어를 사용해 의도를 표현할 능력이 있다면, 주석은 전혀 필요하지 않을 것이다.
  - 주석은 언제나 실패를 의미한다.
    - 우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다.
    - 주석을 달 때마다 자신에게 표현력이 없다는 사실을 푸념해야 마땅하다.



- 주석은 거짓말을 한다.
  - 주석은 항상 그런 것도 아니고, 고의로 그러는 것도 아니지만 너무 자주 거짓말을 한다.
  - 주석은 오래될수록 코드에서 멀어진다.
    - 오래될수록 완전히 그릇될 가능성도 커진다.
    - 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하기 때문이다.
  - 주석이 언제나 코드의 변화를 따라가는 것은 아니다.
    - 주석이 코드에서 분리되어 점점 더 부정확한 고아로 변하는 사례가 너무도 흔하다.



## 좋은 주석

- 어떤 주석은 필요하거나 유익하다.
  - 그럼에도 주석을 달지 않는 것이 가장 좋다.



- 법적인 주석
  - 때로는 회사가 정한 구현 표준에 맞춰 법적인 이유로 특정 주석을 넣으라고 명시할 때가 있다.
  - 예를 들어, 각 소스 파일의 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다.



- 정보를 제공하는 주석
  - 때로는 기본적인 정보를 주석으로 제공하면 편리하다.
  - 그러나 이 역시 함수명 등을 통해 정보를 유추할 수 있게 짜는 것이 더 낫다.



- 의도를 설명하는 주석
  - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.
  - 얼핏 봤을 때 좀 이상하지만 그런 코드를 짤 수 밖에 없었던 이유를 설명하는 주석이 이에 속한다.



- 의미를 명료하게 밝히는 주석
  - 모호한 인수나 반환값이 있고, 해당 인수나 반환 값을 모종의 이유(외부 라이브러리 사용)로 변경할 수 없을 경우에 주석은 유익할 수 있다.
  - 물론 그릇된 주석을 달아 놓을 위험이 상당히 높으므로 주의해야 한다.



- 결과를 경고하는 주석
  - 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용할 수 있다.
  - 시간이 굉장히 오래 걸리거나, 자원을 많이 사용하거나, 시스템 전체에 영향을 미치는 코드의 경우 주석으로 경고를 남기는 것이 도움이 된다.



- TODO 주석
  - 앞으로 할 일을 주석으로 남기면 편하다.
    - 주로 TODO 주석에는 필요하지만 당장 구현하기 어려운 내용을 기술한다.
  - 뿐만 아니라 코드를 읽는 다른 프로그래머들에게 요청할 내용을 적을 수도 있다.
    - 특정 문제를 봐 달라.
    - 개선점을 찾아 달라.
    - 더 좋은 이름을 떠올려 달라.



- 중요성을 강조하는 주석
  - 코드를 읽다 보면 필요 없어 보이는 코드가 있을 수 있다.
  - 해당 코드가 왜 꼭 필요한지를 강조하기 위해서 주석을 남길 수 있다.



## 나쁜 주석

- 주절거리는 주석
  - 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다.
  - 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 노력한다.
    - 즉,  간결하게 작성하되, 누가 읽어도 명확히 의미를 파악할 수 있도록 달도록 노력한다.



- 같은 이야기를 중복하는 주석
  - 코드를 보고도 충분히 이해가 되는데 해당 코드를 설명하는 주석은 중복된 주석이다.
  - 이 경우 주석만 읽고 코드를 대충 읽고 넘어갈 가능성도 있으므로 반드시 제거해야한다.



- 의무적으로 다는 주석
  - 모든 메서드에 인수에 대한 설명과 그 반환값에 대한 설명을 다는 것은 코드를 복잡하게 만들며 혼동과 무질서를 초래한다.
  - 또한 모듈 첫 머리에 변경 이력을 기록하고 변경하는 관례는 소스 코드 관리 시스템이 나오기 전 까지는 바람직한 관례였으나 이제는 혼란만 가중할 뿐이므로 모두 삭제하는 것이 바람직하다.
  - 또한 코드의 작성자, 혹은 수정한 사람을 밝히기 위해 코드상에 주석으로 달아놓는 것 또한 주석이 아닌 소스 코드 관리 시스템으로 하는 것이 바람직하다.



- 있으나 마나 한 주석
  - 너무 당연한 사실을 언급하며, 새로운 정보를 제공하지 못하는 주석은 당연히 쓸 필요가 없다.
  - 이러한 주석은 지나친 참견이라 코드를 읽는 사람으로 하여금 정말 중요한 주석도 읽지 않고 넘어가게 만든다.



- 주석으로 처리한 코드
  - 코드를 주석으로 처리해놓고, 해당 코드가 완전히 필요없어졌음에도 주석 처리된 코드를 지우지 않는 것은 매우 잘못된 습관이다.
  - 주석으로 처리된 코드는 다른 사람들이 지우기를 주저하게 한다.
    - 이유가 있으리라, 중요하니까 남겨놓았으리라 생각하게 한다.
    - 결국 쓸모 없는 코드가 점차 쌓이게 된다.
  - 소스 코드 관리 시스템이 있으니 필요 없는 코드는 주석 처리하지 말고 삭제해라.



- 주석과 주석이 설명하는 코드
  - 주석에는 근처에 있는 코드에 관해서만 기술해야 한다.
    - 코드 일부에 달면서 시스템의 전반에 관한 정보를 기술하지 마라.
  - 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.





# 형식 맞추기

> 술취한 뱃 사람 한 무리가 짜놓은 듯 어수선해 보인다면 독자들은 프로젝트의 다른 측면들도 똑같이 무성의한 태도로 처리했으리라 생각할 것이다.

- 형식을 맞추는 목적
  - 형식에 맞춘 코드가 전문 개발자의 일차적인 의무다.
    - 돌아가는 코드가 전문 개발자의 일차적인 의무라 여길지도 모르겠다.
    - 그러나 오늘 구현한 기능이 다음 버전에서 바뀔 가능성은 아주 높지만, 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.
  - 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다.



- 가장 중요한 것은 팀 내에서 일관된 규칙을 사용하는 것이다.
  - 한 소스 파일에서 봤던 형식이 다른 소스파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다.
  - 온갖 스타일을 뒤섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피한다.



## 적절한 길이를 유지하라

- 일반적으로 짧은 길이가 긴 길이보다 이해하기 쉽다.	
  - Java를 기준으로 많은 라이브러리가 한 파일 당 500줄을 넘기지 않고 대부분 200줄 정도인 파일들로 라이브러리를 완성했다.
  - 이것이 반드시 지킬 엄격한 규칙은 아니지만 바람직한 규칙으로 삼으면 좋겠다.



- 신문 기사처럼 작성하라
  - 신문 기사는 최상단에 기사를 몇 마디로 요약하는 표제가 나온다.
    - 독자는 표제를 보고 기사를 읽을지 말지 결정한다.
  - 첫 문단은 전체 기사 내용을 요약한다.
    - 세세한 사실은 숨기고 커다란 그림을 보여준다.
  - 아래로 내려갈수록 세세한 사실이 조금씩 드러난다.
  - 코드 역시 상단에서 독자로 하여금 자신이 원하는 모듈이 맞는지 판단할 수 있는 대략적인 정보를 제공하고 아래로 내려갈수록 구체적인 구현이 담기게 작성되어야 한다.



- 개념은 빈 행으로 구분하라
  - 거의 모든 코드는 왼쪽에서 오른쪽, 그리고 위에서 아래로 읽힌다.
  - 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다.
    - 생각 사이는 빈 행을 넣어 분리해야 마땅하다.



- 세로 밀집도
  - 줄바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미한다.
  - 즉, 서로 밀집한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.



- 수직 거리

  - 서로 밀집한 개념은 세로로 가까이 둬야 한다.
    - 함수 연관 관계와 동작 방식을 이해하려고 이 함수에서 저 함수로 오가며 소스 파일을 위아래로 뒤진 경험을 해봤다면 이 말이 무슨 말인지 보다 쉽게 와닿을 것이다.
  - 따라서 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.
  - 변수 선언
    - 변수는 사용하는 위치에 최대한 가까이 선언한다.
  - 인스턴스 변수
    - 인스턴스 변수는 클래스 맨 처음에 선언헌다.
    - 언어마다 인스턴스 변수를 선언하는 위치가 다를 수 있지만 핵심은 일반적으로 선언되는 위치에 선언되어야 한다는 것이다.

  - 종속 함수
    - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
    - 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
  - 개념적 유사성
    - 개념적인 친화도가 높을 수록 가까이 배치한다.
    - 한 함수가 다른 함수를 호출하거나, 변수와 그 변수를 사용하는 함수는 개념적 친화도가 높다고 할 수 있다.



- 세로 순서
  - 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
    - 즉, 호출되는 함수를 호출하는 함수보다 나중에 배치해야한다.
  - 단, 함수를 미리 정의해야 사용할 수 있는 언어에서는 이것이 불가능하다.



## 가로 형식 맞추기

- 짧은 행이 바람직하다.
  - 예전에는 오른쪽으로 스크롤할 필요가 없게 코드를 짰다.
    - 그러나 요즘은 모니터가 아주 크고, 글꼴 크기를 줄이면 200자까지도 한 화면에 들어간다.
    - 그러나 120자를 넘어가는 행은 주의부족이다.
  - Java의 경우 1~60자 사이의 코드가 전체 코드의 70%를 차지한다.
    - 80자 이후부터는 급격히 감소한다.



- 가로 공백과 밀집도
  - 가로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.
    - 공백을 넣으면 공백 좌우의 요소가 확실히 나뉘며, 공백을 넣지 않으면 훨씬 밀접해 보인다.
  - 수식에서 연산자의 우선 순위를 강조하기 위해서도 공백을 사용한다.
    - 일반적으로 우선순위가 높은 수식의 경우 공백 없이 사용하고, 우선 순위가 낮은 수식의 경우 공백을 줘 우선순위가 낮다는 것을 강조한다.

