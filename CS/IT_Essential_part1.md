# 프레임워크와 라이브러리

- 프레임 워크
  - 정의
    - 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합
    - 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 틀이다.
    - 재사용이 가능하도록 소프트웨어 구성에 필요한 기본을 제공한다.
    - 정보 시스템의 개발 및 운영을 지원하는 도구 및 가이드 등을 포함한다.
  - 특징
    - 모듈화: 프레임워크는 구현을 인터페이스 뒤에 감춰 모듈화를 강화한다. 설계와 구현 병경에 따르는 영향을 최소화 한다.
    - 재사용성: 인터페이스를 통해 여러 애플리케이션에서 반복적으로 사용하는 일반적 컴포넌트를 정의하여 재사용성을 높인다.
    - 확장성: 다형성을 통해 애플리케이션이 프레임워크의 인터페이스를 확장
    - 제어의 역행: 프레임워크 코드가 전체 애플리케이션의 처리 흐름을 제어, 외부의 이벤트에 대해 애플리케이션이 어떤 메서드를 수행해야할지 결정
  - 구성 요소
    - 개발환경: 설계, 구현, 테스트 등 개발에 필요한 지원 도구 모음.
    - 실행환경: 라이브러리 코드 모음
    - 운영환경: 표준 프레임워크 기반 개발 시스템에 대한 운영 시 필요한 의사소통 및 모니터링 도구 모음
    - 관리환경: 표준 프레임웤에 대한 기술 지원, 업그레이드 등 관리하기 위한 내부 업무 시스템.
  - 비유하자면 자동차와 같다고 할 수 있다.



- 라이브러리
  - 정의
    - 특정 기능에 대한 도구, 함수를 모은 집합.
    - 소프트웨어 개발 시 공통으로 사용될 수 있는 특정한 기능을 모듈화한 기법
  - 구성
    - 도움말: 라이브러리를 사용할 수 있도록 하는 도움말
    - 설치 파일: 라이브러리 적용을 위해 제공되는 설치 파일
    - 샘플 코드: 라이브러리에 대한 이해를 돕기 위한 샘플 소스 코드
  - 종류
    - 표준 라이브러리: 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리. 기본적인 기능 수행과 더불어 디버깅, 성능 측정 등을 위한 별도의 API가 존재한다.
    - 외부 라이브러리: 표준 라이브러리와 달리 별도의 파일 설치가 필요. 누구나 개발 가능하다.
  - 비유하자면 공구상자와 같다고 할 수 있다.



- 차이점
  - 제어의 권한
    - 프레임워크: 제어의 역전 개념이 적용된 대표적인 기술로 제어의 권한이 개발자가 아닌 프레임워크에게 있다.
    - 라이브러리: 제어의 권한이 라이브러리를 사용하는 개발자에게 있다.
  - 목적성
    - 프레임워크는 그것이 개발되는 단계에서부터 특정한 목적성을 가지고 만들어진다.
    - 라이브러리는 특정한 목적성 없이 편리한 도구들을 모아놓은 것 뿐이다.
    - 예를 들어 자동차는 빠른 이동이라는 분명한 목적이 존재한다. 그러나 공구상자는 용도만 존재할 뿐 특별한 목적성이 존재하지는 않고 상황에 따라 필요한 것을 꺼내서 쓰면 된다.
  - 규칙
    - 프레임워크는 목적성이 존재하기에 사용하는데 일정한 규칙을 지켜야 한다.
    - 라이브러리는 규칙이 존재하지 않으며 사용하는 사람이 임의로 변경시킬 수 있다.



# 아키텍처 그리기(설계하기)

- 아키텍처를 요구하는 대상들
  - 명세서
  - 프로젝트 매니저
  - 고객



- 사전적 정의
  - 아키텍처: 건물이나 다른 구조물을 계획, 설계, 건설하는 과정과 그 결과물
  - SW아키텍처
    - wiki: 소프트웨어 구성요소들 사이에서 유기적 관계를 표현하고, 소프트웨어 설계와 업그레이드를 통제하는 지침과 원칙
    - Software Architecture in Practic(3판): 시스템을 추론하는데 필요한 구조의 집합으로, 시스템은 소프트웨어 요소와 이들 사이의 관계, 그리고 이들 요소와 관계의 속성으로 구성된다.



- 아키텍처가 중요한 이유
  - 초기 설계 과정의 **결정사항**: 구현에 대한 제약사항 검토 및 시스템에 대한 구조 결정
  - 커뮤니케이션의 **기준점**: 서비스나 시스템 이해 당사자들 간의 공통분모
  - 재사용 가능한 **레퍼런스**: 아키텍처를 결정 짓게 한, 유사한 요구사항 및 설계 경험의 재사용



- 학사관리시스템을 예시로 보는 아키텍처 설계 방법

  - 결정요인 도출

    - 이해관계자 선별(시스템에 연관되는 사람이나, 다른 시스템): 학생, 교수, 교직원, 외부 시스템(인사 관리 시스템)
    - 기능요구사항: 학사 관리 기능, 수업 관리 기능, 수강 관리 기능, 사용자 관리 기능
    - 비기능요구사항(품질속성): 강의신청 기간에 원활한 진행, 언제 어디서나 접근 가능, 모바일에서도 접속 가능, 데이터 손실 방지 등.
    - 비기능요구사항(품질속성) 때문에 아키텍처를 그린다고 봐도 될 정도로 비기능요구사항은 매우 중요한 사항이다.
  - 결정요인들의 연관관계를 도식화(유스 케이스 다이어그램 사용)

  > 아래 다이어 그램을 그린 사이트 : https://app.diagrams.net/

  ![](IT_Essential.assets/유스케이스다이어그램-1607178918780.jpg)

  - 비기능 요구사항 기반으로 품질 속성 시나리오 작성

    - 스파이크 성 트래픽에 대한 처리(수강 신청 기간에 몰리는 접속량), public 환경(언제 어디서나 접근 가능),  하이브리드 웹(모바일에서 접속 가능), 권한을 통한 정보 보안, 주기적 데이터 백업(데이터 손실 방지) 등
    - 실제 서비스를 위해서는 기능 구현만을 목적으로 해선 안되며 위와 같은 품질 속성을 고려해야 한다.
    - 스파이크 성 트래픽에 대한 처리: 4000명의 학생이 학년별로 각기 다른 날짜에, 4일에 걸쳐 수강 신청을 한다고 할 때, 최악의 경우를 학생 1100명이 동시에 접속하는 상황을 상정(해당 일자에 수강신청하는 1000명+다른 용무로 접속하는 학생 100명)하여 먼저 신청한 학생 순서대로 5초이내에 처리 완료한다.
    - public환경: 학생과 교수는 본 시스템에 외부, 내부 네트워크 환경에서 모두 접속하여 수강신청을 할 수 있다.
    - 하이브리드 웹: 학생과 교수는 안드로이드, iOS, PC로 접속하여 수강신청을 할 수 있다. 지원 브라우저는 IE 11, Chrome 80, safary 13 버전 이상이다.
    - 권한을 통한 정보 보안: 권한이 있는 교직원 외에는 인사관리 데이터에 아무도 접근할 수 없다. 권한이 없는 교수와 교직원 외에는 학사관리 시스템에 아무도 접근할 수 없다.
    - 주기적 데이터 백업: 수강신청 기간에는 매일 오전 03시에 수강신청 데이터를 백업한다. 수강신청 완료 후에는, 데이터의 영구보존을 위해 수강신청 데이터를 백업하여 별도 디스크에 저장한다.

  - 품질 속성 시나리오에 따른 아키텍처 전략 수립

    ![](IT_Essential.assets/품질속성시나리오전략.jpg)

  - 아키텍처 도식화

    ![](IT_Essential.assets/아키텍처.jpg)

  - 아키텍처 검증(평가)하기





# Server & Client Architecture

- DNS(Domain Name Server)
  - 클라이언트가 서버에 요청을 보낼 때 DNS를 통해 보내게 된다.
  - ISP(Internet Service Provider, 인터넷 서비스 제공) 업체(SKT, KT, LG)별로 DNS의 주소가 다르다.
  - DNS Cache: 매번 DNS에 요청을 보내는 대신 최초로 DNS에 요청을 보냈을 때 그 응답으로 받은 IP를 저장해둔다.
    - 저장 위치: 브라우저, 운영체제, 라우터, ISP 등에 저장한다.
  - TCP(Transmission Control Protocol) 3 Way HandShake
    - SYN(Synch): IP 주소에 해당하는 서버에 요청을 보낸다.
    - ACK(acknowledge)+SYN: 싱크가 맞으면 서버는 요청을 받았다는 확인을 클라이언트에 보낸다.
    - ACK: 클라이언트 역시 서버에 확인 응답을 보낸다.
  - DNS는 반의 모든 사람의 전화번호를 알고 있는 반장과 같고, DNS IP는 반장 직통 번호로 비유했을 때 번호를 모르는 같은 반 친구에게 연락하고자 한다면 아래의 과정을 거치게 된다.
    - 반장에게 연락한다
    - 반장에게 친구의 이름을 알려주고 전화번호를 물어본다.
    - 반장이 해당 학생의 번호를 찾아본다.
    - 전화번호를 전달 받는다.
    - 받은 번호를 저장한다(따라서 이후에는 이 친구의 번호를 얻기 위해서는 굳이 반장에게 연락할 필요가 없다).
    - 받은 번호로 전화한다.
  - 이를 Server & Client의 관계에 대입하여, 주소창에 www.google.com을 입력한 이후의 과정은 다음과 같다.
    - Client는 DNS Resolver에게  www.google.com라는 도메인과 함께 요청을 보낸다.
    - DNS Resolver는 Root Name Server로 www.google.com라는 도메인과 함께 요청을 보내는데,  Root Name Server는 도메인 중 마지막에 달린 `.com`, `.co.kr` 등을 분석하여 이들에 대한 정보를 가진 Server의 IP(TLD Name Server IP)를 DNS Resolver로 반환한다.
    - DNS Resolver는 이 응답을 가지고 www.google.com라는 도메인과 함께 TLD(Top Level Domain) Name Server로 다시 요청을 보낸다.  TLD Name Server는 `google.com`까지 분석하여 이 주소에 대한 정보를 가진 Server의 IP(Authoritative Name Server IP)를 DNS Resolver로 반환한다.
    - DNS Resolver는 이 정보를 가지고 Authoritative Name Server에 www.google.com라는 도메인과 함께 요청을 보내는데 Authoritative Name Server는 이를 분석하여 해당 도메인의 IP 주소를 반환한다.
    - DNS Resolver는 반환 받은  IP 주소를 Client에 반환한다.
    - DNS Cache를 통해 이를 저장한다.
    - TCP 3 Way HandShake를 통해 서버에 요청을 보낸다.



- HTTP request, response
  - 이는 TCP 연결이 이루어진 뒤의 과정이다.
  - HTTP(HyperText Transfer Protocol): HTML을 요청하고 전달 받기 위한 규약
  - Client는 Server에 Request Method(GET, POST 등)와 함께 요청을 보낸다.
  - 일반적으로 최초의 요청은 GET 메서드로 index.html을 요청한다. 서버는 이에 대한 요청으로 index.html과 함께 status code(성공했을 경우 200)를 반환한다.



- 위 내용을 정리하여, 구글 홈페이지가 브라우저에 보여지기까지의 과정은 다음과 같다.
  - 브라우저에 www.google.com을 입력한다.
  - DNS를 통해 IP 주소를 획득한다.
  - 획득한 IP 주소에 있는 서버와 TCP 3 Way Handshake를 진행한다.
  - 통신을 맺은 서버에 HTTP Request를 한다.
  - 서버에 보낸 HTTP Request를 통해 html 파일을 받는다.
  - 브라우저가 html을 분석하여 화면으로 그린다.





# 개발자는 항상 의심해야 한다

- 서버는 클라이언트를 무작정 믿어선 안된다.

  - 악의적인 의도를 가진 클라이언트의 요청을 막을 수 있어야 한다.

  - 서버는 클라이언트에 따라 능동적인 대처가 필요하다.

  - 서버는 클라이언트에서 어떤 사용자가 요청를 보낸 것인지 사용자에 대한 인증이 필요하다(토큰 사용).

  - 서버는 사용자가 보낸 요청이 유효한 것인지 유효성을 검증해야한다.

    - 예시1.회원가입시 비밀번호 검증 같은 경우 백과 프론트 모두에서 검증해야 한다.
    - 예시2.파일 업로드 기능 구현시 파일 유형을 엄격히 제한해야 한다. 현대카드의 경우 게시판에 업로드 기능이 있었는데 `.jsp` 확장자의 업로드도 허용하였다. 이 때문에 서버의 DB를 조회하여 사용자 정보가 유출된 적이 있었다.

  - Sql injection에 주의해야 한다.

  - XSS

    - Cross-Site Scripting

    ```html
    <script>악의적인 해커의 url로 사용자의 주요 정보 전송</script>
    ```

  - 클라이언트에서는 최소한의 처리만 해야하며 중요한 로직은 모두 서버에서 처리해야 한다.

    - 예를 들어 할인 로직의 경우 이를 프론트 단에서 처리할 경우, 악의적으로 이를 조작한다면 서버는 할인된 가격을 적용시킬 수 밖에 없다.
    - 클라이언트는 이러한 악의적인 조작에 서버보다 취약하므로 중요한 로직은 서버에서 처리해야 한다.



- 서버는 항상 자기 자신도 의심해야 한다.
  - 개발자는 개발을 진행하면서 자신이 보낸 요청에 대한 응답만을 확인하지만 실제 서비스는 N명의 요청이 동시에 들어온다는 것을 인식하고 있어야 한다.
    - JMeter와 같은 도구를 사용하요 부하 테스트를 수행한다.
  - 적절한 응답 시간과 데이터의 신뢰성을 확보해야 한다.
    - 응답 시간을 줄이기 위해 캐시를 고려해야 한다.
    - 캐시를 쓴다는 것은 메모리를 사용하겠다는 말이고 이는 결국 코드로 보면 변수 혹은 객체에 저장한다는 말이다.
    - 데이터 신뢰성의 경우 최대한 다양한 상황을 가정하고 테스트를 해봐야 한다. 예를 들어 한 사람만 사용할 때에는 포인트가 정상적으로 쌓이는 것 처럼 보이겠지만 여러 명이 사용할 경우 사실 포인트가 한 사람에게만 쌓이도록 코드가 짜여져 있을 수도 있다. 따라서 테스트를 보다 다양하고 정밀하게 진행해야 한다.
  - 서비스 및 컨텐츠 별로 사용 권한을 명확히 해야 한다.
  - 주요 데이터를 암호화 해야 한다.
  - 트랜잭션
    - 하나의 과정을 잘게 분할하여 분할 된 과정 중 하나만 실패하더라도 전체 과정을 취소시켜야 한다.
    - 여를 들어 상품 구매시 상품권 적용+신용카드 선택+쇼핑몰 포인트 적용의 과정을 거칠 때 쇼핑몰 포인트 적용이 실패했다면 이전의 상품권, 신용카드 선택도 모두 취소되어야 한다.
  - Logging
    - 서버가 작동하면서 발생하는 주요 이슈들을 기록해야 한다.
    - 단순 콘솔 출력 보다는 주요 logger(library)를 사용해야 한다.
    - 이는 서버 운영 시 발생하는 다양한 이슈들을 추적하는 시작점이 된다.
  - 서버 테스트 시나리오
    - 복수개의 요청을 반드시 수행해봐야 한다.
    - 눈에 보이지 않는 비 기능 요소에 대한 테스트 시나리오를 작성해야 한다.
    - 테스트 할 내용을 안다는 것 자체가 SW역량을 인증하는 것이다.



- HTTP(Hyper Text Transfer Protocol)
  - Stateless: HTTP는 stateless하다. 서버는 클라이언트의 상태에 관심이 없고, 클라이언트 역시 서버의 상태에 관심이 없다. 요청과 그에 따른 응답이 끝나면 둘 사이의 연결은 끊어지게 된다.
  - HTTP 서버는 불특정 다수의 요청을 전제(HTTP 서버만의 특성이라기 보다 서버의 특성에 가깝다)
  - Stateless의 단점은 무엇이며 이를 해결하기 위한 방법은 무엇인가
    - 단점: 클라이언트는 서버에 요청을 보낼때 마다 클라이언트에 대한 정보도 담아서 보내야 한다.
    - 해결법: 클라이언트는 상태를 유지하기 위해서 쿠키를, 서버는 상태를 유지하기 위해서 세션을 사용한다.





# 개발자의 나쁜 습관

- 코드관리
  - 무분별한 복붙
    - 무엇인지 모르고 복붙해서 사용하기만 한다면 유지보수에 문제가 발생한다.
    - 사용하는 측에서 문제를 발견하여 수정하더라도 원래의 소스코드에는 해당 내용이 반영되지 않는다.
  - 디버깅 미루기
    - 사소한 버그라도 디버깅을 미루면 후일 큰 문제가 발생할 수 있다.
    - 사소한 버그라도 놓치지 않도록 할 일 목록을 만들어 두어야 한다.
  - 지나치게 축약된 코드
    - 간결한 코드가 좋은것은 사실이다.
    - 그러나 간결성 보다는 가독성, 접근성이 먼저다.
    - 남이 보고 한 번에 파악할 수 있는 코드를 짜야 한다.
  - 이른 최적화
    - 최적화는 가장 마지막 단계에서 해야 한다.
    - 최적화를 마친 후 요구사항이 바뀌면 어차피 최적화도 다시 해야 한다.
  - 남이 알아볼 수 있는 코드를 짜라
    - 코드 스타일을 지켜서 짜야 한다.
    - 변수명, 함수명은 이름만 보고도 무슨 역할을 하는지 알아볼 수 있게 짜야 한다.



- 팀워크
  - 잦은 계획 변경
    - 무분별한 계획 변경은 일정 지연 및 개발 기간 부족으로 이어진다.
    - 계획 변경은 개발기간을 고려하여 신중하게 해야 한다.
  - 실현 가능성이 낮은 계획
  - 아이디어를 공유하지 않고 아이디어에 대한 피드백을 받지 않음
  - 혼자 일하는 개발자
  - 나쁜 코드를 짜는 것을 거부한다.
    - 프로젝트 마감일에 쫒겨 작동만 가능하도록 급조하여 만든 코드를 짜는 것을 무작정 거부하는 개발자
    - 나쁜 코드는 분명 지양해야 하지만 일정에 맞추는 것이 중요하다.
    - 나쁜 코드라도 빠르게 짤 수 있는 능력도 필요하다.
  - 거만한 태도
    - 자신의 실수를 인정하지 않는 태도
    - 다른 팀원에게 자신의 지식을 공유하지 않음
    - 자신의 코드에 집착하고 다른 사람의 의견을 수용하지 않음



- 코드 작성
  - 에러 메세지 무시
    - 에러 메세지를 제대로 읽지 않고 에러의 원인을 다 이해했다고 착각
    - 에러 메세지 분석에 시간을 들이는 것이 길게 보면 시간을 단축하는 일이다.
  - 하나의 개발자 툴 킷만 사용
    - 개발 스타일에 따라 잘 맞는 IDE가 있다.
    - 특정 언어, 특정 조직에 특화된 IDE가 있다.
  - 무분별한 라이브러리 사용
    - 예제 몇 가지를 보고 라이브러리를 마스터 했다고 생각
    - 프로젝트에 맞지 않는 라이브러리의 사용



- 테스트 및 유지보수
  - 통과할 정도의 테스트 만들기
    - 통과하지 못할 테스트도 만들어야 한다.
    - 테스트는 에러를 잡기 위해서 하는 것임을 기억해라.
  - 기능구현에만 집중하기
    - 기능 구현에만 몰두하면 성능, 보안 문제를 소홀히 하기 쉽다.
    - 기능 구현을 하면서도 끊임 없이 해당 기능과 관련하여 어떤 문제들이 있을지 생각하고 리스트화 해야 한다.





# 프로젝트 DB 설계

- DB 설계의 목적
  - 관련 조직의 정보 요구에 대한 정확한 이해
  - 분석자, 개발자, 사용자간 원활한 의사소통 수단
  - 데이터 중심의 분석 방법에서 DB 설계는 굉장히 중요한 부분
  - 현행 시스템만이 아닌 신규 시스템 개발의 기초 제공



- 설계 과정

  - 설계를 위한 요구사항 분석
    - DB에 대한 사용자의 요구사항을 수집하고 분석하여, 요구사항 명세서를 작성해야 한다.
    - 마구잡이로 설계한다면 기능 하나를 추가할 때마다 DB를 다시 설계해야 한다.
  - 개념적 설계
    - 작성한 요구사항 명세서에서 DB를 구성하는데 필요한 개체, 속성, 개체 간의 관계를 추출하여 ERD 작성
    - 개체와 속성을 추출(대부분 명사로 선별한다)
    - 개체는 테이블, 속성은 컬럼에 해당한다.
    - 개체 간의 관계를 추출(대부분 개체 사이의 관계를 나타내는 동사로 선별한다)
    - 분석 내용을 ERD로 작성
  - 논리적 설계
    - 모든 개체는 릴레이션으로 변환(개체의 속성을 정의)
    - N:M 관계는 릴레이션으로 변환(중계 테이블 생성)
    - 1:N 관계는 외래키로 표현
    - 1:1 관계는 외래키로 표현
    - 다중 값 속성은 독립 릴레이션으로 변환(회원 1명당 여러 명의 자녀가 있다고 하면 자녀를 독립 릴레이션으로 전환, 즉 한 컬럼의 데이터가 2 이상이라면 독립 릴레이션으로 변환)

  - 물리적 스키마 수현
    - ERD를 실제 테이블로 생성



- 반정규화
  - 정규화된 엔티티 타입, 속성, 관계를 시스템의 성능 향상, 개발과 운영의 단순화를 위해 모델을 통합하는 프로세스
  - 정규화 모델
    - 이상적인 논리모델은 모든 엔티티 타입, 속성, 관계가 반드시 한 개만 존재한다.
    - 따라서 입력, 수정, 삭제도 한 곳에서만 발생하므로 데이터 값이 변질되거나 이질화 될 가능성이 없다.
    - 반면 여러 테이블이 생성되어야 하므로 SQL 작성이 용이하지 않고 과다한 테이블 연결이 발생하여 성능이 저하될 가능성이 높다
  - 반정규화 모델
    - 반정규화는 여러 개의 테이블을 단순화시켜 SQL 작성이 용이하고 성능이 향상될 가능성이 높아진다.
    - 그러나 같은 데이터가 여러 테이블에 걸쳐 존재하므로 무결성이 깨질 우려가 있다.
  - 테이블 반정규화
    - 1:1 관계의 테이블 병합
    - 1:N 관계의 테이블 병합
    - 수퍼/섭 타입 테이블 병합
    - 수직 분할(집중화된 일부 컬럼을 분리)
    - 수평 분할(행으로 구분하여 구간별 분리)
    - 테이블 추가(중복테이블, 통계테이블, 이력테이블, 부분테이블)
  - 컬럼 반정규화
    - 중볼 컬럼 추가(자주 조회하는 컬럼이 있을 경우, 예를 들어 지점 테이블이 있고, 지점과 1:N 관계를 가지는 직원 테이블이 있다고 할 때,  지점 테이블에는 지점 위치라는 컬럼이 존재한다고 가정하면, 직원을 통해 지점위치를 알기 위해서는 직원 테이블에 있는 지점 위치 FK 값으로 지점을 조회하여 지점 위치를 조회해야 한다. 그러나 만일 직원이 근무하는 지점의 위치를 빈번히 조회해야 한다면, 아예 직원에 지점위치 컬럼을 넣는다.)
    - 파생 컬럼 추가(미리 계산한 값)
    - PK에 의한 컬럼 추가
    - 응용시스템 오작동을 위한 컬럼 추가(이전데이터 임시 보관)





# 데이터 크롤링

- 인터넷에서 데이터를 수집하는 방법
  - OpenAPI 등을 통해 공개된 데이터를 얻는 방법
  - HTTP GET Method를 사용해 HTML을 가져오는 방법
  - Selenium Web Driver 등을 사용해 사람이 하는 것과 유사한 자동화 방법
  - 사람이 수작업으로 데이터를 수집하는 방법



- 크롤러와 스크래퍼
  - 크롤러: 조직적, 자동화 된 방법으로 웹을 탐색/수집하는 프로그램
    - 구글, 네이버 등의 검색엔진 결과 데이터를 수집하기 위한 봇(Bot)
  - 스크래퍼: 웹 사이트에서 정보를 추출하는 프로그램
    - 상품별 가격을 알기 위해 해당 상품을 파는 페이지들의 가격을 추출
  - 크롤러 보다는 대부분 단순 스크래퍼 개발 수요가 많다.
  - 우리나라에서는 많은 기업들이 같은 의미로 혼용



- 구글은 어떻게 크롤링을 하는가?
  - 사용자가 검색하기 전, 수천억 개에 달하는 웹페이지에서 정보를 수집
  - 수집한 정보를 바탕으로 검색 색인에 정리
  - 과거 정보 수집으로 만들어진 웹 URL 목록과 웹사이트 소유자가 제공한 사이트맵에서 대상 페이지 목록 수집 후 페이지의 내용 수집
  - 사이트에 있는 링크를 사용하여 다른 페이지를 색인
  - 해당페이지를 수집하는 동안 새로운 사이트, 기존 사이트의 변경사항, 깨진 링크를 주의 깊게 확인



- 크롤링의 적법성

  - 주소 뒤에 /robots.txt를 붙이면 배제 표준 규칙을 확인 가능하다(e.g. https://www.google.com/robots.txt).
  - 홈 디렉토리에 위치한 robots.txt 파일에 포괄적인 크롤링 금지 또는 특정 검색엔진의 크롤링 금지, 특정 디렉토리에 대한 크롤링 금지 등을 표시하였음에도, 그 표시를 무시하고 크롤링하였다면 사이트 운영자의 의사에 반한 크롤링에 해당한다.
  - 운영자는 robots.txt 외에 페이지 하단 약관 등에 크롤링 금지 표시를 할 수 도 있다.
  - 크롤링의 매너
    - robots.txt를 열어보고 서버의 로봇 배제 표준을 준수 할 것
    - UserAgent를 속이지 않을 것
  - robots.txt의 로봇 배제 표준 규칙

  | 규칙                                                         | 내용                                              |
  | ------------------------------------------------------------ | ------------------------------------------------- |
  | User-agent:*  ,  Disallow: /                                 | 모든 검색엔진이 긁어가는 것 모두 막기             |
  | User-agent:*  ,  Disallow:                                   | 모두 허용하기                                     |
  | User-agent:*  ,  Disallow: /cgi-bin/, Disallow: /tmp/, Disallow: /private/ | cgi-bin, tmp, private 디렉토리 긁어가는 것만 막기 |
  | User-agent:BadBot ,  Disallow: /                             | 배드봇 검색로봇만 긁어가기 제외                   |
  | User-agent:WebCrawler  ,  Disallow:                          | 웹크롤러 검색로봇만 긁어가기 허락                 |

  - User Agent의 종류는 크게 다음의 두 가지다.
    - 인간이 조작하는 웹 브라우저 형식
    - 자동화된 에이전트(봇)의 형식



- Web Abusing
  - Web Abusing: 데이터 크롤링을 응용하여 데이터 수집이 아닌 다른 용도로 사용
  - 검색엔진과 쇼핑몰 등은 Web Abusing과의 전쟁 중이다.
    - 특정 검색어를 여러 번 검색하여 검색어 순위 조작을 하거나, 특정 상품을 여러 번 클릭하여 많이 본 제품으로 등록되게 하는 등 여러 문제가 발생한다.
  - 일반 사용자와 Abuser를 판단하는데 많은 자원이 투입된다. 





# 클라우드

- 클라우드(cloud)
  - 클라우드 컴퓨팅 또는 클라우드 서비스를 줄인 말
  - 클라우드 컴퓨팅은 인터넷 기반 컴퓨팅의 일종으로 정보를 자신의 컴퓨터가 아닌 인터넷에 연결된 다른 컴퓨터로 처리하는 기술을 말한다(위키백과)
  - 종류
    - 컴퓨터의 CPU와 메모리에 해당하는 컴퓨팅 서비스(컴퓨팅, 서버)
    - 컴퓨터의 하드디스크에 해당하는 저장 장치 서비스(스토리지)
    - 인터넷에 연결할 수 있는 네트워크 서비스(네트워크)



- 가상화
  - 하드웨어 기능을 시뮬레이션하여 애플리케이션 서버, 스토리지 및 네트워크와 같은 소프트웨어 기반 IT 서비스를 생성하는 기술
  - 클라우드는 가상화를 가능하게 하는 IT 환경이라고 할 수 있다.



- 사용처
  - 개인: 대개 저장공간을 빌리는 형식으로 클라우드 서비스를 사용한다.
  - 기업: 다양한 클라우드 서비스를 사용하지만 특히 서버 관련 클라우드 서비스를 많이 사용한다.





# Linux

- 리눅스는 왜 어려운가
  - Command 위주의 환경
    - CLI(Command Line Interface)로 GUI(Graphic User Interface)에 비해 처음 접하는 사람이 막막함을 느낀다.
  - 클라이언트 보다는 서버를 주로 다룬다.
    - 서비스 제공, 디스크 관리, 네트워크 관리, 상태 관리, 보안 관리 등의 다양하고 익숙하지 않은 서버의 역할을 수행해야 한다.
  - OS에 대한 기본 지식 필요
  - 다양한 배포판이 존재



- Linux Kernel
  - Linus Torvalds의 리눅스 재단에서는 Linux Kernel을 만들고 있다.
  - 다양한 개발자들이 개발에 참여하고 있으며 토발스는 maintainer를 맡고 있다.



- Linux Distro
  - Linux Kernel이 리눅스의 핵심 내용들을 담고 있다면 Linux Distro는 이를 사용 가능하도록 한 배포판이다.
  - 다양한 계열이 존재한다.
    - RedHat 계열에는 일반적으로 기업용으로 제공하는 CentOS와 개인용으로 제공하는 fedora가 있다.
    - debian 계열에는 ubuntu와 Linux Mint가 있다.
    - slacware 계열에는 SUSE가 있다.







# 캐싱

- 캐시
  - 데이터나 값을 미리 복사해 놓는 임시 장소
  - 캐시를 사용하는 경우
    - 데이터에 접근하는 시간이 캐시에 접근하는 시간에 비해 오래 걸리는 경우
    - 값을 다시 계산하는 시간을 절약하고 싶은 경우
  - 캐시에 데이터를 미리 복사해 놓으면 계산, 접근 시간 없이 빠른 속도로 데이터에 접근 가능
  - 캐시에는 공간 지역성(데이터의 근접성), 시간 지역성(데이터를 최근에 사용 했는지)을 고려하여 필요한 것들을 저장하게 된다.



- 바람직한 캐싱
  - Write가 빈번하고 Read는 거의 없는 경우 보다는 Read가 빈번하고 Write는 거의 없는 경우에 캐시를 사용하는 것이 좋다.
  - 메모리는 매우 중요한 자원이므로 신중하고 선별적으로 캐싱하는 정책이 필요하다.
  - 메모리는 한정적이며 휘발성이다. 따라서 메모리에 부하가 걸리게 된다면 메모리에 저장된 데이터가 모두 날아가 버릴 수 있다. 뿐만 아니라 메모리를 사용하는 다른 작업들에도 큰 영향을 미칠 수 있다. 따라서 메모리는 매우 신중하게 다뤄야 한다.





# 소프트웨어 테스팅

- 소프트웨어 테스팅
  - 사람이 만든 소프트웨어를 테스트 하는 작업
  - 하드웨어와 소프트웨어의 융합 제품이 많아 하드웨어 테스트와 소프트웨어 테스트의 경계는 점점 없어지는 추세
  - 수정사항 발생시 수정이 쉬움
  - 제작 과정에서 요구사항 변경이 빈번함



- 하드웨어 테스팅
  - 기계가 만든 하드웨어를 테스트 하는 작업
  - 수정사항 발생시 수정이 매우 어려움
  - 제작 과정에서 요구사항 변경이 어려움



- 소프트웨어 테스트의 7가지 원칙(ISTQB)
  - 테스트는 결함이 존재함을 밝히는 작업이다.
  - 완벽한 테스트는 불가능하다.
    - 비용 관점에서 완벽한 테스트는 불가능하다.
    - 효율적인 테스트 전략을 수립해야 한다.
  - 개발 초기에 테스트하라
    - 통합, 릴리즈 이후 진행되는 디버깅은 범위가 커져 매우 어렵다.
    - 또한 개발 후반부에 발견될 결함을 예방할 수 있다.
    - 개발 초기에만 하라는 것이 아니라 개발 초기부터 테스트 계획을 짜라는 것이다.
  - 결함은 집중된다.
    - 개발자, 환경, 모듈 등 여러 가지 원인으로 발생할 수 있다.
    - 그러나 그 원인을 중심으로 결함은 몰려서 발생하는 성향이 있다.
  - 살충제 패러독스
    - 동일한 테스트 케이스를 오래 사용하면 개발자들은 내성이 생기게 된다.
    - 환경, 시간에 맞게 테스트를 변경하는 작업이 필요하다.
  - 테스팅은 정황 의존적이다.
    - 상황에 따라 동일한 대상도 테스트 범위가 달라진다. 정황에 대한 파악 작업이 중요하다.
    - 예를 들어, 로그인 페이지를 수정했을 경우(정황)에 로그인, 회원가입, 회원 정보 수정 등에 대한 테스트를 해야 할 것이다.
  - 오류 부재의 궤변
    - 사용자 똔느 비즈니스의 요구를 충족시키지 못한다면, 결함을 모두 발견하여 제거하였다고 하더라도 품질이 높다고 볼 수 없다.
    - 개발한 시스템이 사용자의 필요와 기대에 부응하지 못한다면 결함을 찾는 활동도 의미가 없다.



- Verification, Validation
  - Verification
    - 요구 사항, 기본 설계, 상세 설계 등 문서화된 사항들을 충실히 구현했는지 여부
  - Validation
    - 고객 입장에서 정말 원하는 방식되로 구현이 되었는지를 평가
  - 만일 흔들리는 의자를 만들어 달라는 고객의 요구가 있었을 때, 고객이 원한 것은 흔들의자지만 개발자가 만든 것은 오뚜기처럼 모든 방향으로 흔들리는 의자라면 Verification은 충족(의자가 흔들린다)하지만 Validation은 충족하지 못한 것이다.



# 쿠키, 세션, 웹 스토리지, IndexedDB

- HTTP의 특징 
  - 상태를 가지고 있지 않다(Stateless)
    - 웹 사이트를 사용하다보면 다양한 종류의 정보(상태)를 알고 있어야 한다.
    - 예를 들면 사용자의 로그인 상태인지를 알고 있어야 함에도, 혹은 사용자의 계정에 관한 정보를 알고 있어야 함에도 HTTP는 상태를 가지고 있지 않으므로 로그인 여부, 누가 로그인 했는지 여부를 알 수 없다.
  - 연결 상황을 알지 못한다(Connectless)
    - 요청과 응답이 오고 나면 클라이언트와 서버의 요청은 끊어지게 된다.
    - 예를 들어 클라이언트가 서버에 로그인 요청을 보내고 서버가 이에 대한 응답을 줄 경우 서버가 응답을 준 순간 연결은 끊어지게 된다. 그러나 사용자가 계속 로그인 상태인지 여부를 서버와의 교신 없이도 알고 있어야 한다.
  - 따라서 상태를 저장할 무언가가 존재해야 한다.



- 쿠키

  - 정의: 인터넷 사용자가 어떠한 웹사이트를 방문할 경우 그 사이트가 사용하고 있는 서버를 통해 인터넷 사용자의 컴퓨터에 설치되는 작은 기록 정보 파일

  - 종류

    - Session Cookie: 만료 시간을 설정하고 웹 클라이언트 메모리에만 저장되며 브라우저 종료시 삭제 되는 쿠키
    - Persistent Cookie: 장기간 유지되는 쿠키(최대 1년), 파일로 저장되어 브라우저 종료와 무관하게 유지 되는 쿠키
    - Secure Cookie: HTTPS에서만 사용 가능, 쿠키 정보가 암호화 되어 전송되는 쿠키
    - Third-Party Cookie: 방문한 도메인과 다른 도메인의 쿠키

  - 특징

    - key-value의 쌍으로 존재한다.
    - 이름, 값, 만료 날짜, 경로 정보가 들어있다.

    - 만료 기간이 존재한다.
    - 4KB의 용량 제한이 있다.
    - 세션에 비해 속도는 빠르다.
    - 사용자의 하드 디스크에 저장되기에 보안에 취약하다는 단점이 존재한다.

  - 동작 방식

    - 클라이언트가 페이지를 요청

    - 서버에서 쿠키를 생성 후 HTTP 헤더에 쿠키를 포함시켜 응답
    - 브라우저가 종료되어도 쿠키 만료 기간이 있다면 사라지지 않고 클라이언트에서 보관한다.
    - 같은 요청을 할 경우 HTTP 헤더에 쿠키를 담아 서버로 보낸다.
    - 서버에서 쿠키를 읽어 클라이언트 정보를 찾아서 응답한다.
    - 쿠키의 정보를 변경 할 필요가 있을 경우 서버는 쿠키를 업데이트 하고 HTTP 헤더에 담아서 클라이언트로 보낸다.



- 세션
  - 정의: 클라이언트와 웹서버 간 네트워크 연결이 지속 유지되고 있는 상태(브라우저를 열어 서버에 접속하고 접속을 종료하는 시점 까지의 상태)
  - 특징
    - 쿠키에 기반을 두고는 있으나 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리한다.
    - 서버의 메모리 혹은 DB 등에 저장된다.
    - 서버는 클라이언트를 구분하기 위해 클라이언트에게 고유한 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증 상태를 유지한다.
    - 보안 면에서 쿠키보다 우수하다.
    - 서버에 저장되므로 사용자가 많아질수록(많은 클라이언트와 연결 될 수록) 서버의 리소스를 많이 차지하게 된다.
  - 동작 방식
    - 클라이언트가 서버에 접속 시 세션 ID를 발급 받는다.
    - 클라이언트는 자신에게 할당된 세션 정보를 쿠키에 저장해서 가지고 있는다(쿠키의 종류 중 Session Cookie가 이 쿠키다).
    - 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용한다.
    - 서버는 세션 ID를 전달 받아 해당 세션을 찾은 후 세션에 있는 클라이언트 정보를 가져온다.
    - 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답한다.



- 웹 스토리지
  - 정의: DOM 스토리지라고도하는 웹 스토리지는 웹 애플리케이션에 클라이언트 측 데이터를 저장하는 방법을 제공하는 것(wikipidia)
  - 특징
    - 쿠키의 단점을 보완하기 위해 HTML5부터 지원 시작
    - key-value의 쌍으로 존재한다. value에는 어떤 타입의 데이터를 담든 문자열이 된다.
    - 4KB 밖에 지원하지 않는 쿠키에 비해 5MB라는 저장 공간을 사용 가능
    - 로컬 스토리지와 세션 스토리지가 존재한다.
    - 두 스토리지 모두 JS의 `window`객체 안에 들어 있다.
  - 로컬 스토리지
    - 브라우저 자체에 반영구적으로 데이터를 저장하며, 브라우저가 종료되도 데이터가 유지된다.
    - 도메인이 다른 경우 로컬 스토리지에 접근할 수 없다. 예를 들어 네이버에서 로컬 스토리지에 저장한 데이터는 구글에서는 접근할 수 없다.
  - 세션 스토리지
    - 각 세션(브라우저의 탭)마다 데이터가 개별적으로 저장된다.
    - 세션을 종료할 경우 데이터가 자동으로 제거된다.
    - 같은 도메인이라도 세션이 다르면 데이터에 접근할 수없다.



- IndexedDB

  - 정의: Indexed Database API, WebSimpleDB 등의 이름으로도 불리는데, 색인(index)이 포함된 JSON 객체가 모여있는 트랜잭셔널 로컬 데이터베이스를 위해 W3C 가 권고한 웹 브라우저 표준 인터페이스의 하나 

  - 특징
    - 웹 스토리지 보다도 큰 저장 공간을 제공한다.
    - 많은 양의 구조화된 데이터를 저장하기에 적합하다.
    - SQL을 사용하는 관계형 데이터베이스(RDBMS)와 같이 트랜잭션을 사용하는 데이터베이스 시스템이다.
    - 그러나 IndexedDB는 RDBMS의 고정컬럼 테이블 대신 JavaScript 기반의 객체지향 데이터베이스이다.
    - key-value의 쌍으로 존재한다. key로 색인 된 객체를 저장하고 검색이 가능하다.
    - 모두 문자열로 저장하는 스토리지와 다르게 IndexedDB 는 javascript에서 사용하는 모든 타입의 데이터를 저장 가능하다.
    - 비동기적으로 동작한다.



# SSL과 TLS

> https://kanoos-stu.tistory.com/46
>
> https://12bme.tistory.com/80

- 대칭키와 비대칭키(혹은 공개키)

  > https://12bme.tistory.com/80

  - key
    - 암호를 만드는 행위인 암호화를 진행할 때 사용하는 일종의 비밀번호를 키라 부른다.
    - 이 키에 따라서 암호화된 결과가 달라지기에 키를 모르면 암호를 푸는 행위인 복호화를 할 수 없다. 
  - 대칭키
    - 동일한 키로 암호화와 복호화를 진행하는 암호화 기법에 사용되는 키.
    - 암호를 주고 받는 사람들 사이에 대칭키를 주고 받기 어렵다는 문제가 있다.
    - 대칭키가 유출될 경우 암호화된 내용을 복호화할 수 있기에 암호화가 의미가 없어진다.
  - 비대칭키(혹은 공개키)
    - 암호화할 때와 복호화할 때 각기 다른 키를 사용하는 암호화 방식에 사용되는 키를 의미한다.
    - A, B 두 개의 키가 있을 때, A키로 암호화하면 B키로 복호화할 수 있고, B키로 암호화하면 A키로 복호화할 수 있다.
    - 두 개의 키 중 하나를 비공개키(private key, 개인키, 비밀키)로 하고, 남은 하나를 공개키(public key)로 지정하여 비공개키는 자신만 가지고 있고, 공개키를 타인에게 공개한다.
    - 암호화는 공개키를 사용하고, 복호화에 비공개키를 사용한다.
    - 공개키를 제공받은 타인은 공개키를 사용해서 정보를 암호화하고 암호화한 정보를 비공개키를 가진 사람에게 전송하고, 비공개키를 가진 사람은 비공개키로 이 정보를 복호화한다.
    - 공개키가 유출된다고해도 비공개키를 모르면 복호화가 불가능하기에 대칭키보다 안전한 방식이다.
  - 위와 같은 비대칭키의 원리를 역으로 사용하면 아래와 같은 방식으로도 응용이 가능하다.
    - 비공개키의 소유자는 비공개키를 이용해서 정보를 암호화 한 후에 공개키와 함께 암호화된 정보를 전송한다. 
    - 정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호화한다. 
    - 이 과정에서 공개키가 유출된다면 의도하지 않은 공격자에 의해서 데이터가 복호화 될 위험이 존재함에도 비공개키를 이용하여 정보를 암호화해서 보내는 이유는 이 과정이 데이터를 보호하는 것이 목적이 아니기 때문이다.
    - 암호화된 데이터를 공개키를 가지고 복호화 할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키에 의해서 암호화 되었다는 것을 의미한다. 
    - 즉 공개키로 데이터를 복화할 수 있다는 것은 해당 데이터가 비공개키를 가진 사람으로 부터 온 것이라는 것을 보장한다.
    - 따라서 데이터를 보낸 사람의 신원을 보장해주게 된다.
    - 즉, 공개키로 암호화하고 비공개키로 복호화하는 방식은 데이터의 안전한 전송에 목적이 있고, 비공개키로 암호화하고 공개키로 복호화하는 방식은 데이터를 보낸 사람을 신뢰할 수 있는가를 인증하는 데 목적이 있다.
    - 이 방식은 전자서명에 사용된다.



- SSL(Secure Scokets Layer)
  - 원래 웹상의 데이터는 누구나 읽을 수 있는 일반 텍스트 형식으로 전송되었다.
    - 이러한 문제때문에 인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 Netscape가 1995년 처음으로 SSL을 개발하였다.
  - SSL은 암호화 기반 인터넷 보안 프로토콜이다. 
    - 전달되는 모든 데이터를 암호화하고 특정한 유형의 사이버 공격도 차단한다.
  - 다만 1996년 3.0 이후 업데이트가 되지 않고 있으며, 알려진 취약점들이 다수 존재해 앞으로 사라질 것으로 보인다.



- TLS

  - TLS 는 SSL의 업데이트 버전으로 SSL의 최종버전인 3.0과 TLS의 최초버전의 차이는 크지않다.
    - 그럼에도 이름이 바뀐것은 SSL을 개발한 Netscape가 업데이트에 참여하지 않게 되어 소유권 변경을 위해서이다.
    - 아직까지는 SSL이라는 명칭이 더 널리 사용된다.

  - SSL/TLS 를 사용하는 웹사이트 URL은 HTTP 대신 HTTPS가 사용된다.



- SSL 인증서
  - 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서.
  - SSL 인증서의 역할
    - SSL 인증서는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. 
    - SSL 통신에 사용할 공개키를 클라이언트에 제공한다.
  - SSL인증서를 발급하는 역할을 하는 민간 기업들을 CA(Certificate Authority)라고 부른다.
    - 당연히 아무 기업이나 될 수는 없고 엄격하게 공인된 기업들만 참여가 가능하다.
    - 그 중에서도 모든 사람들이 신뢰할수 있다고 공인된 기관은 root CA라 부른다.
  - 인증서에는 다음과 같은 정보가 담겨있다.
    - 인증서를 발급한 CA 관련 정보.
    - 서비스의 도메인 등의 서비스 관련 정보.
    - 공개키의 암호화 방법 등 서버측의 공개키에 대한 내용.
    - 인증서의 유효 기간.
    - 서비스의 도메인, 공개키 등의 정보는 서비스가 CA로부터 SSL 인증서를 구매할 때 제출해야한다.
    - 당연히 위의 정보들은 CA의 비공개키에 의해서 암호화되며, 인증서의 내용을 종합해 해시화한 값을 fingerprint라 부른다.
  - 브라우저는 CA에 대한 정보를 가지고 있다.
    - 브라우저는 공인된 CA들에 대한 정보를 가지고 있다.
    - 웹 브라우저가 서버에 접속할 때 서버는 가장 먼저 인증서를 제공한다.
    - 브라우저는 이 인증서의 발급 기관(CA)가 자신의 CA 리스트에 있는지 확인한다.
    - CA 리스트에 있다면 해당 CA의 공개키를 활용하여 인증서를 복호화한다.
    - CA의 공개키에 의해서 인증서가 정상적으로 복화화 된다는 것은 해당 인증서가 CA의 비공개키에 의해 암호화 되었다는 것을 보장한다.



- SSL의 암호화
  - SSL은 대칭키 방식과 비대칭키 방식(공개키 방식)을 모두 사용한다.
    - 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화한다.
    - 그리고 해당 대칭키를 비대칭키 방식으로 암호화해서 주고 받는다.
  - 두 방식을 모두 사용하는 이유는 다음과 같다.
    - 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문이다. 
    - 만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 할 것이다. 
    - 반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화가 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하다. 
    - 따라서  속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고, 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다.



- SSL의 동작 과정(handshake-session-session 종료)
  - Client hello
    - 클라이언트가 서버에 접속하는 단계
    - 클라이언트에서 생성한 랜덤 데이터, 클라이언트가 지원하는 암호화 방식, 세션 아이디 등을 서버로 전송한다.
    - 클라이언트가 지원하는 암호화 방식을 전송하는 이유는 서버와 클라이언트 사이에 지원하는 암호화 방식에 차이가 날 수 있기에 어떤 방식으로 암호화 할지 합의하기 위해서다.
    - 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하는데, 이 때 사용하기 위해 세션 아이디를 전송한다.
  - Server hello
    - 서버가 Client hello에 대한 응답을 클라이언트로 보낸다.
    - 서버에서 생성한 랜덤 데이터, 서버가 선택한 클라이언트의 암호화 방식, SSL 인증서를 클라이언트로 전송한다.
  - 인증서 확인
    - 서버가 전송한 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. 
    - 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호한다.
    - 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된다.
    - 또한 Client hello 단계에서 클라이언트가 생성한 랜덤 데이터와 Server hello 단계에서 서버가 생성한 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성한다.
    - pre master secret는 실제로 주고 받을 데이터를 암호화 할 때 사용한다.
    - pre master secret는 대칭키이기 때문이 절대 제 3자에게 노출되어서는 안된다.
  - 클라이언트는 pre master secret를 서버의 공개키(서버가 보낸 인증서 안에 담겨 있다)로 암호화해서 서버로 전송한다. 
    - 서버는 자신의 비공개키로 이를 복호화하여 저장한다.
    - 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret값으로 만든다.
    - master secret 값을 사용하여 session key를 생성하는데, 이 session key 값을 사용해서 서버와 클라이언트는 대칭키 방식으로 데이터를 암호화해서 주고 받게 된다.
    - 여기까지 완료되면 클라이언트와 서버 사이의 handshake 단계가 종료된다.
  - 세션 단계
    - 세션은 실제로 서버와 클라이언트가 데이터를 주고받는 단계이다. 
    - 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한 것이다. 
    - 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.
  - 세션 종료
    - 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.
    - 이 때 통신에 사용된 대칭키인 세션키를 폐기한다.



## 인증서의 계층

- 인증서는 보통 3계층 구조로 되어 있고, 이를 인증서 체인(certificate chain)이라 부른다.
  - Root 
  - Intermediate
  - Leaf
- 대부분의 브라우저에는 Root, Intermediate 계층에 속한 CA들의 공개키가 저장되어 있다.
- Root certificate
  - Root CA가 발급한 인증서이다.
  - Root CA의 인증서는 인증 받을 수 있는 상위 기관이 없으므로, 자체 서명(self-signed)한 인증서를 사용한다.
- Intermediate certificate
  - Root 인증서와 leaf 인증서 사이의 중간 다리 역할을 하는 인증서이다.
  - 발급할 인증서의 정보를 해시화 한 값(fingerprint)을 Root CA의 비공개키로 암호화(sign)하고, 이를 자신들이 인증서에 저장한다.
  - 상위 CA의 비공개키로 암호화 하는 과정을 sign이라 부른다.
  - 이 값은 Root CA의 비공개키로 복호화됐으므로, Root CA의 공개키로 복호화 할 수 있게 된다.
  - 이러한 과정을 거치는 이유는 다음과 같다.
  - 특정 데이터가 Root CA의 공개키로 복호화 된다는 것은 해당 데이터가 Root CA의 비밀키로 암호화 된 데이터라는 것을 보장한다.
  - 즉, intermediate 인증서를 전달 받은 기관이 인증서 내부의 암호화된 데이터를 Root CA의 공개키로 복호화했을 때, 정상적으로 복호화가 된다면, 이 인증서는 Root CA의 비공개키로 암호화된, Root CA가 공인한 인증서라는 것이 보장된다.
  - 따라서, 해당  intermediate 인증서를 신뢰할 수 있다고 판단할 수 있다.
  - 이러한 원리를 **Chain of Trust**라 부른다.
  - 추가로, 그냥 암호화를 진행하는 것이 아닌 hash값으로 변환 후 암호화하는 이유는 변조 여부를 판별하기 위해서이다.
  - Root CA의 공개키로 복호화가 되었다는 사실은 인증서가 Root CA에 의해 공인된 기관에서 발급된 것이라는 것만 보장하지, 발급 된 이후에 변경이 있었는지는 보장하지 못한다.
  - 따라서 최종적으로 인증서가 사용 될 때, 인증서에 들어있는 내용을 해시화 한 값과 복호화의 결과로 나온 해시 값이 다르다면, 해당 인증서는 발급된 후 누군가에 의해 변조되었음을 의미한다.
- leaf certificate
  - 다른 인증서를 sign할 수 없는, 인증서 계층의 가장 마지막에 위치한 인증서이다.
  - 이 인증서도 ICA가 발급한 인증서와 마찬가지로 상위 CA(이 경우 ICA)로부터 인증서를 sign받아 Chain of Trust에 의해 신뢰성을 갖게 된다.
  - SSL/TLS 인증서가 이 계층에 속한다.
- 예시
  - Chrom으로 아무 사이트나 들어가서 url 왼쪽에 있는 자물쇠를 클릭하면 `이 사이트는 보안 연결(HTTPS)이 ~`라는 탭을 볼 수 있다.
  - 해당 탭을 누르고 `인증서가 유효함`을 클릭하면 새 창에 인증서 정보가 뜨는데, 인증 경로탭을 보면 Root CA, ICA, leaf의 정보를 모두 볼 수 있다.





# 동시성 병렬성

- 동시성과 병렬성

  > 동시성은 한 번에 많은 것을 다룬다.
  >
  > 병렬성은 한 번에 많은 것을 한다.
  >
  > 똑같지는 않지만, 연관성은 있다.
  >
  > 동시성은 구조, 병렬성은 실행에 관한 것이다.
  >
  > 동시성은 병렬화할 수 있는 문제를 해결하기 위해 해결책을 구조화하는 방법을 제공한다.
  >
  > -롭 파이크(Go 공동 창시자)

  - 동시성과 병렬성은 동시에 일어나는 여러 개의 작업을 처리하기 위한 방식이라는 점에서 공통점이 있다.
  - 그러나 두 방식에는 분명한 차이가 존재한다.
  - 동시성 예시
    - 만약 요리사 한 명이 주문과 요리를 동시에 하는 식당이 있다고 가정해보자.
    - 손님은 와서 요리를 주문하고, 요리가 완성되기 전까지 자리에 가서 기다리면서 핸드폰을 보거나 함께 온 사람과 이야기를 할 수 있다.
    - 요리사 역시 요리를 하는 중간 중간에 다른 손님으로부터 주문을 받을 수 있다.
  - 병렬성 예시
    - 여러 명의 은행원이 은행 업무를 보고 있다고 가정해보자.
    - 여러 명의 은행원이 존재하므로 여러명의 손님을 대상으로 상담은 가능하다.
    - 그러나 한 명의 은행원은 손님과의 상담이 끝날 때 까지 다른 손님을 상대할 수 없다.
  - 동시성이 병렬성보다 나은 것인가?
    - 위의 예시들만 보면 동시성이 병렬성 보다 나은 것 처럼 보이지만 그렇지만은 않다.
    - 예를 들어 방이 8개인 집을 청소해야한다고 생각해보면 한 사람이 이 방, 저 방을 돌면서 동시에 청소하는 것 보다는 8명이 방 하나씩 잡고 청소하는 것이 더 나을 것이다.
    - 이처럼 동시성과 병렬성은 각기 다른 특성을 갖고 있으므로 무엇이 더 우월하다고 할 수는 없다.
  - API 개발에서의 동시성과 병렬성
    - API 개발은 요청과 응답 사이에 대기 시간이 존재한다는 특성으로 인해 일반적으로 동시성이 병렬성 보다는 낫다.
    - 따라서 주로 비동기적으로 코드를 작성하여 동시성을 구현한다.
  - 동시성은 사실 동시에 실행되는 것은 아니다.
    - 동시성은 싱글 코어에서 둘 이상의 스레드가 번갈아가며 실행되는 것이다.
    - 가상 병렬 처리의 한 형태로, 둘 이상의 스레드가 하나의 코어 내에서 빠르게 교차되면서 실행되기에 동시라고 느껴지는 것이다.
    - 각 스레드가 교차는 부분을 **Context Switching**이라 부른다.
    - 이에 반해 병렬성은 둘 이상의 코어가 각기 스레드를 실행하는 것으로 실제로 두 개의 스레드는 동시에 실행된다.





- 동기와 비동기, blocking과 non-blocking
  - 동기(Synchronous)와 비동기(Asyncronous)
    - 동기와 비동기는 호출자가 피호출자의 처리 결과를 확인하는지 여부에 따라 나뉜다.
    - 만약 호출자가 피호출자의 처리 결과를 확인하면 동기, 확인하지 않으면 비동기이다.
  - Blocking과 non-blocking
    - 피호출자의 제어권 반환 여부에 따라 나뉜다.
    - 만약 피호출자가 제어권을 호출자에게 넘기지 않고 task가 종료될 때 까지 계속 가지고 있다면 blocking, 피호출자가 호출된 후 task를 마치지 않았더라도 제어권을 호출자에게 넘긴다면 non-blocking이다.
    - Non-blocking 방식에서는 호출자가 피호출자의 처리 결과를 받을 수 없다. 따라서 호출자가 피호출자의 처리 결과를 확인하고 싶다면(즉, 동기적으로 동작해야 한다면) 지속적으로 완료 상태를 확인하는 요청을 피호출자에게 보내야 하고, 피호출자는 그 때마다 task가 완료되었는지 여부를 응답해야 한다.
  - 제어권을 잃어버린 피호출자가 어떻게 task를 수행하는가?
    - 피호출자가 제어권을 잃어버렸음에도 task를 수행할 수 있는 것은 멀티 스레드 덕분으로, 사용자 스레드가 시스템 콜로 요청을 보내면 커널 스레드가 생성되어 피호출자의 테스크가 수행되고, 호출자에게 제어권을 반환한다.
    - 멀티 스레드를 지원하지 않는 환경에서는 콜백 함수를 사용한다.
  - 동기와 비동기, blocking과 non-blocking로 4가지 조합이 가능하다.
  - 동기 + blocking
    - 가장 흔한 형태로 호출자가 피호출자를 호출하면 피호출자가 task를 마칠 때 까지 제어권을 가진다(blocking).
    - 호출자는 제어권을 피호출자에게 넘겼으므로 다음 작업을 수행할 수 없다.
    - 호출자는 피호출자의 반환 결과를 확인한다(sync).
    - 피호출자의 task가 완료되면 호출자는 제어권을 넘겨 받아 다음 task를 수행한다.
  - 비동기 + non-blokcing
    - 호출자는 콜백 함수와 함께 피호출자를 호출하고, 피호출자는 바로 호출자에게 제어권을 넘긴다(non-blocking).
    - 호출자는 제어권을 넘겨 받았으므로 다음 task를 수행한다.
    - 호출자는 task를 수행하는 중에 피호출자의 작업이 완료됐는지 확인하지 않는다(async).
    - 피호출자의 task가 완료되면 피호출자는 callback 함수를 실행하여 호출자에게 task가 완료되었음을 알린다.
  - 동기 + non-blocking
    - 호출자는 피호출자를 호출하고, 피호출자는 바로 호출자에게 제어권을 넘긴다(non-blocking).
    - 호출자는 제어권을 넘겨 받았으므로 다음 task를 수행하지만 한 task가 끝날 때 마다 피호출자의 task가 끝났는지를 주기적으로 확인한다.
    - 호출자가 피호출자의 task가 완료되었음을 확인하면 확인을 멈춘다.
  - 비동기 + blocking
    - 호출자는 callback 함수와 함께 피호출자를 호출하고, 피호출자는 task가 완료될 때 까지 제어권을 가진다(blocking).
    - 호출자는 피호출자의 task 완료 여부에는 관심이 없다(async).
    - 그러나, 제어권이 피호출자에게 있으므로 호출자는 다음 task를 수행할 수 없고, 어쩔 수 없이 피호출자의 task가 끝나 제어권을 돌려 받기를 기다리며, 피호출자의 task가 끝났는지를 확인하지는 않는다.
    - 피호출자의 task가 완료되면 피호출자는 callback 함수를 호출하여 호출자에게 완료를 알린다.
    - 제어권의 반환을 기다리는 것이지 task의 종료를 기다리는 것이 아니다(결국 결과적으로는 같을 수 있으나 본질은 다르다).
    - 의도적으로 이렇게 프로그래밍 하는 경우는 없다.





- 가시성과 원자성

  > https://rightnowdo.tistory.com/entry/JAVA-concurrent-programming-Overview

  -  Multi-thread programming을 하기 위해서 기본적으로 이해해야하는 개념이다.

  -  가시성 문제의 원인

     - 기본적으로 CPU에서 사용할 데이터는 memory에 저장된다.
     - 그러나, 매 번 memory로부터 데이터를 읽어오는 것이 비효율적이므로, CPU는 CPU cache라는 영역에 데이터를 저장해서 사용한다.
     - 문제는 CPU cache와 memory의 값이 항상 일치하는 것은 아니라는 것이다.
     - CPU cache에서 memory로 data가 옮겨지기까지 약간의 시간이 필요하고, 이 약간의 시간이 multi-thread 환경에서는 가시성 문제를 일으킬 수 있다.

  -  가시성(Visibility) 문제

     - CPU cache와 memory 사이의 data의 불일치에서 오는 문제이다.
     - 예를 들어 두 개의 thread A, B가 `foo`라는 변수를 함께 사용한다고 가정해보자.
     - `foo`의 초기값은 0이었지만 thread A가 `foo`의 값을 3으로 변경하고 이를 CPU cache에 작성한다.
     - 이 시점에서 thread A가 실행되는 CPU의 CPU cache에는 `foo`의 값이 3으로 저장되어 있지만, memory에는 여전히 0으로 저장되어 있다.
     - 이 때, thread B가 `foo`의 값을 memory로부터 읽어 다시 3을 증가시킨다.
     - Thread A가 실행되는 CPU의 CPU cache와 memory에 저장된 data 사이에 차이가 없다면 `foo` 값은 6이 되겠지만, 두 thread에서 모두 `foo` 값은 3인 상태가 된다.
     - 가시성이 보장된다고 해서 동시성이 보장되는 것은 아니다(원자성 문제).
     - CPU cache가 없이 바로 memory에 쓴다고 해도 유사한 문제가 발생할 수 있다.
     - 예를 들어 thread A가 `foo`의 값을 3으로 변경하고 바로 메모리에 쓴다.
     - 그런데 thread B가 `foo`의 값이 갱신되기 직전에 memory에서 `foo`의 값을 읽어온다면, 이 값은 thread A에 의해 변경 된 3이 아닌 0이 될 것이다.

  -  원자성(Automic) 혹은 원자 연산(Automic operation)

     - Programming language로 작성된 프로그램은 일련의 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 변경된다.
     - 이 때 원자 연산이란 타 CPU의 개입이 없는 최소한의 연산단위이다.
     - 예를 들어 `cnt++`이라는 Java 코드는 (간소화해서 표현하면) memory에서 cnt를 읽어 오고, cnt에 1을 더하고, 1이 더해진 cnt를 다시 저장하는 과정을 거친다.
     - 이 각 단계를 원자 연산이라고 할 수 있다.

  -  원자성(Automic) 문제

     - 문제는 원자 연산 자체는 다른 CPU(thread)의 개입이 있을 수 없지만, 각 원자 연산 사이에는 다른 CPU의 개입이 있을 수도 있다는 것이다.

     - Thread A가 memory에서 0으로 초기화된 `cnt`를 읽어온다.
     - 그 후 cnt에 1을 더하는데, 이 때 thread B가 `cnt` 값을 읽어온다.
     - Memory의 cnt 값은 아직 0이므로 thread B는 thread A에 의해 갱신되지 않은 값을 읽어가게 된다.
     - 이로 인해 각 thread 간에 data의 불일치가 발생하게 된다.
     - 가시성이 보장되더라도 원자성이 보장되지 않으면 thread-safe하지 않다.

