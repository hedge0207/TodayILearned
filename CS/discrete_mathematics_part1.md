# 수의 체계

- 수의 정의

  - 기수(base)

    - 10진수, 2진수와 같이 수 표현의 근거를 알려주는 수.
    - 숫자의 끝에 아래 첨자로 표기하며, 일반적으로 10진수는 표기를 생략한다.

  - 자릿수

    - 수를 표현할 때 사용하는 각 숫자의 위치
    - 아래 표와 같이 소수점을 기준으로 정한다.

    | 10진수 실수 123.456 | 1    | 2    | 3    | .    | 4    | 5    | 6    |
    | ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
    | 자릿수              | 2    | 1    | 0    |      | -1   | -2   | -3   |

  - 자연수(natual number:ℕ)

    - 0보다 큰 양의 정수

    $$
    n,\  a_i,\  b ∈ ℕ이고, b > 1, 0 \le a_i < b일때,\\ n = a_kb^k+a_{k-1}b^{k-1}+\cdots+a_1b^1+a_0b^0\\ a_i는 자연수\ n을\ 구성하는\ i번째\ 숫자(i\ge0),\ b는\ 기수,\ k는\ 자릿수.
    $$

  - 
  
  - 정수(interger:ℤ)
  
    - 양의 정수, 0, 음의 정수로 구성된 수
  
  - 유리수(rational number:ℚ)
  
    - a, b가 정수이고, a는 0이 아닐때 b/a로 표현할 수 있는 수.
    - 하한항(lowest): 1이외의 공약수가 존재하지 않는 분모와 분자.
  
    $$
    a, b \in ℤ이고\ a \neq 0일때\ {b\over a}인\ 수
    $$
  
  - 무리수(irrational number: I)
  
    - a,b가 정수아고, a는 0이 아닐 때 b/a로 표현할 수 없는 수.
    - 유리수는 소수로 표현했을 때 소수부의 숫자가 유한하게 나열되거나 규칙성을 갖고 무한히 나열되는 형태로 나타나 분수로도 표현이 가능하지만, 무리수는 소수부의 숫자가 규칙성 없이 무한히 나열되어 분수로 표현할 수 없다.
  
    $$
    a, b \in ℤ이고\ a \neq 0일때\ {b\over a}로\ 표현할\ 수\ 없는\ 수
    $$
  
  - 실수(Real number: ℝ)
  
    - 유리수와 무리수를 모두 포함하는 수 체계.
    - 소수점을 기준으로 정수부와 실수부로 표현한다.
  
    $$
    r \in ℝ,\ \ \  a_i \in ℤ,\ \ \  b>1,\ \ \ 0 \le a_i<b(a_i:실수\ r을\ 구성하는\ i번째\ 숫자, i \in ℤ)일때,\\
    r=a_kb^k + a_k-1b^k-1 + \cdots + a_1b^1 + a_0b^0 + a_{-1}b^{-1} + a_{-2}b^{-2} + \cdots(b:기수,k:자릿수)
    $$
  
    - 예를 들어 실수 34.81<sub>10</sub>은 다음과 같이 표현할 수 있다.
  
    $$
    34.81_{10} = 3 \times10^1+4 \times10^0+8 \times10^{-1}+1 \times10^{-2}
    $$
  
  - 허수 단위(imaginary unit)
    $$
    i^2=-1을\ 만족하는\ 수\ i
    $$
    
  
    - 제곱하여 음수가 되는 실수는 없으나, 물리학, 전자공학 등에서는 제곱했을 때 0보다 작은 값아 되는 가상의 수가 필요한 경우가 있어 이러한 허수의 개념을 사용한다.
  
  - 복소수(complex number: C)
  
    - 실수와 허수를 모두 포함하는 수 체계
    - 복소수 c는 실수부 a와 허수부 bi로 분리할 수 있다.
    - b=0이면 실수, 0이 아니면 허수이다.
  
    $$
    c = a + bi\ \ \ \ (a,b \in R, c \in C)
    $$
  



# 수의 연산

- 연산의 성질

  - 수를 연산한 결과는 수의 체계와 연산자의 종류에 따라 결정된다.
    - 연산자에 피연산자로 사용한 수, 연산 결과로 나오는 수의 체계와 연산자의 관계는 닫힘 성질로 정의할 수 있다.
    - 닫힘 성질이란 수 체계 S에 속하는 어떤 수 a, b를 연산자 O로 연산한 결과가 S에 속하면 "수 체계 S는 연산자 O에 대해 닫혀있다(closed)고 하고, 그렇지 않으면 수 체계 S는 연산자 O에 대해 닫혀 있지 않다"고 한다.
    - 예를 들어 자연수 a, b를 더한 결과인 a+b는 자연수이므로, 수 체계 자연수는 연산자 덧셈에 대해 닫혀 있다고 할 수 있다.
    - 반면에 자연수 a, b(a <= b)에 대하여 a에서 b를 뺀 결과인 a-b는 자연수가 아닐 수 있으므로 자연수는 뺄셈에 대해 닫혀있지 않다.

  - 수 체계별 사칙연산의 닫힘 성질

  |        | +    | -    | *    | /    |
  | ------ | ---- | ---- | ---- | ---- |
  | 자연수 | O    | X    | O    | X    |
  | 정수   | O    | O    | O    | X    |
  | 유리수 | O    | O    | O    | O    |
  | 무리수 | X    | X    | X    | X    |
  | 실수   | O    | O    | O    | O    |
  | 복소수 | O    | O    | O    | O    |

  - 위 표를 통해 무리수를 제외한 모든 수 체계가 덧셈과 곱셈에 닫혀있다는 것을 알 수 있다.
    - 덧셈과 곱셈 연산의 특징을 정리하면 다음과 같다.
    - a, b, c가 모두 무리수가 아닐 때, 아래 법칙이 성립한다.
    - 교환법칙: a+b = b+a, ab=ba
    - 결합법칙: (a+b)+c = a+(b+c), (ab)c = a(bc)
    - 분배법칙: a(b+c) = ab+ac
  - 또한 합과 곱에 대해서는 항등원(identity element)과 역원(inverse element)이 존재한다.
    - 항등원: a, b가 무리수가 아니고 연산자 O에 대해 닫혀 있을 때, 모든 수 a에 대하여 `a O b = b O a = a`를 만족하는 b.
    - 합에 대한 항등원은 0, 곱에 대한 항등원은 1이다.
    - 역원: a,b,c가 무리수가 아니고, 연산자 O에 대해 닫혀 있으면서 c가 연산자 O에 대한 항등원일 떄, `a O b = b O a = c`를 만족하는 b
    - a의 합에 대한 역원은 -a, a의 곱에 대한 역원은 1/a(단, a != 0).
    - 결국 역원은 어떤 수 a와 연산했을 때, 항등원이 나오게 만드는 수로, `a + (-a) = (-a) + a = 0`이므로, a의 합에 대한 역원은 -a이고, `a*1/a = 1/a*a = 1`이므로, a의 곱에 대한 역원은 1/a다.



- 합 연산 Σ(Sigma)

  - 일정한 규칙이 있는 수열의 합을 나타낸다.

  $$
  \sum_{i=1}^n a_i = a_1+a_2+\cdots+a_{n-1}+a_n\ \ \ (i:합의\ 색인)
  \\
  \\
  예시: 1보다\ 크거나\ 같고\ 20보다\ 작거나\ 같은\ 홀수의\ 합
  \\
  \sum_{i=1}^{10}(2i-1) = 1+3+\cdots+17+19
  $$

  - 시그마 기호를 이용한 합 연산의 규칙

    - c는 상수, x~i~, y~i~은 실수, k,n은 자연수일 때, 아래 규칙들이 성립한다.
    - 규칙1.
  
    $$
    \begin{align}
    \sum_{i=1}^n c &= nc
    \\
    \sum_{i=1}^n c &= c+c+\cdots+c+c = nc
    \end{align}
    $$
  
    - 규칙2.
  
    $$
    \begin{align}
    \sum_{i=1}^n cx_i &= c\sum_{i=1}^n x_i
    \\
    \sum_{i=1}^n cx_i&=cx_1 + cx_2 + \cdots + cx_{n-1}+cx_n\\
    &=c(x_1+x_2+\cdots+x_{n-1}+x_n)\\
    &=c\sum_{i=1}^n x_i
    \end{align}
    $$
  
    - 규칙3.
  
    $$
    \begin{align}
    \sum_{i=1}^n (x_i+y_i) &= \sum_{i=1}^n x_i +\sum_{i=1}^n y_i
    \\
    \sum_{i=1}^n (x_i+y_i)&= (x_1+y_1)+(x_2+y_2)+\cdots+(x_{n-1}, y_{n-1})+(x_n+y_n) \\
    &= (x_1+x_2+\cdots+x_{n-1}+x_n)+(y_1+y_2+\cdots+y_{n-1}+y_n)\\
    &=\sum_{i=1}^n x_i +\sum_{i=1}^n y_i
    \end{align}
    $$
  
    - 규칙4.
  
    $$
    \begin{align}
    \sum_{i=1}^n x_i &= \sum_{i=1}^k x_i + \sum_{i=k+1}^n x_i
    \\
    증명: \sum_{i=1}^n x_i&=(x_1+x_2+\cdots+x_k+x_{k+1}+\cdots+x_{n-1}+x_n)\\
    &=(x_1+x_2+\cdots+x_k)+(x_{k+1}+\cdots+x_{n-1}+x_n)
    \end{align}
    $$
  
- 



- 곱연산 𝚷(Pi, Product)

  - 일정한 규칙이 있는 수열의 곱
    - n개의 항을 나열한 수열의 모든 항을 곱한다.

  $$
  \prod_{i=1}^n a_i = a_1 × a_2 × \cdots × a_{n-1} × a_n\ \ \ \ (i:곱의\ 색인)
  \\
  \\
  예시: 1보다\ 크거나\ 같고\ 20보다\ 작거나\ 같은\ 홀수의\ 곱
  \\
  \prod_{i=1}^{20} = (2i-1)
  $$

  - 프로덕트를 이용한 곱연산의 규칙들

    - c는 상수, x~i~, y~i~는 실수, n은 자연수일 때 아래 규칙이 성립한다.

    - 규칙1.

    $$
    \begin{align}
    \prod_{i=1}^n c &= c^n\\
    \prod_{i=1}^n c &= c × c × \cdots × c × c = c^n
    \end{align}
    $$

    - 규칙2.

    $$
    \begin{align}
    \prod_{i=1}^n {x_iy_i} &= \prod_{i=1}^n x_i × \prod_{i=1}^n y_i\\
    \prod_{i=1}^n {x_iy_i} &=x_1y_1 × x_2y ()_2 × \cdots × x_{n-1}y_{n-1} × x_ny_n\\
    &=(x_1 × x_2 × \cdots × x_{n-1} × x_n) × (y_1 × y_2 × \cdots × y_{n-1} × y_n)\\
    &=\prod_{i=1}^n x_i × \prod_{i=1}^n y_i
    \end{align}
    $$

    - 규칙3.

    $$
    \begin{align}
    \prod_{i=1}^n x_i &= \prod_{i=1}^k x_i × \prod_{i=k+1}^n x_i\\
    \prod_{i=1}^n x_i &=x_1 × x_2 × \cdots × x_k × x_{k+1} × \cdots × x_{n-1} × x_n\\
    &=(x_1 × x_2 × \cdots × x_k) × (x_{k+1} × \cdots × x_{n-1} × x_n)\\
    &=\prod_{i=1}^k x_i × \prod_{i=k+1}^n x_i
    \end{align}
    $$



- 팩토리얼 !(계승)

  - n이 자연수일 때, 1부터 n까지 1씩 증가하는 수열의 곱

  $$
  n! = 1 × 2 × 3 × \cdots × n = \prod_{i=1}^n i
  $$

  - $0!$
    - 팩토리얼 연산에 사용되는 수는 1보다 크거나 같은 자연수지만, 연산식에 따라 0!을 계산할 수 있도록 0!을 1로 정의한다.



- 나누기 연산 $\mid$, div, mod

  - 수를 나누면 몫(quotient)과 나머지(remainder)를 구할 수 있다.

    - 이 때 나머지가 0이면 '나누어떨어진다'고 하고, 나머지가 0이 아니면 '나누어떨어지지 않는다'고 한다.

    - 정수 n을 자연수 d로 나누었을 때의 몫을 q, 나머지를 r이라고했을 때 아래와 같다.
    - $n = dq+r(n,q \in Z,\  d,r \in N,\ 0 \le r < d)$ 
    - r=0 일 때, n은 d로 나누어떨이진다고 하고, $d\mid n$으로 표기한다.
    - r != 0일 때, n은 d로 나누어떨어지지 않는다고 하고, $d \nmid n$으로 표기한다.

  - 나누어떨어진다에 관한 정리

    - $a,b,c,d,m,n \in Z$에 대하여,
    - 정리1.

    $$
    d \mid m\ 이고\ d \mid n\ 이면,\ d \mid (m+n)\\
    d \mid m\ 이고\ d \mid n\ 이면,\ d \mid (m-n)
    \\
    \\
    증명\\
    d \mid m\ 이면,\ m=dk(k\in Z)이다.\\
    m+n=dk+dl=d(k+l)이므로,\ m+n은\ d로\ 나누어떨어진다.\\
    m-n도\ 마찬가지다.
    $$

    

    - 정리2.

    $$
    d \mid m이면,\ d \mid mn
    \\
    \\
    증명\\
    d \mid m\ 이면,\ m=dk(k\in Z)이다.\\
    mn=dkn이므로,\ mn은\ d로\ 나누어떨어진다.
    $$

    

    - 정리3.

    $$
    a \mid b이고\ b \mid c이면,\ a \mid c
    \\
    \\
    증명\\
    a \mid b이면\ b=ak(k \in Z)이고,\ b \mid c이면\ c=bl이다.\\
    c=bl에\ b=ak를\ 대입하면\ c=bl=akl이므로,\ c는\ a로\ 나누어떨어진다.
    $$

  - 몫을 구하는 연산 div

    - $n=dq+r\ (n \in Z,\ d \in N,\ 0 \le r < |d|)$을 만족하는 목 q를 구하는 연산은 아래와 같다.
    - $q=n\ div\ d$

  - 나머지를 구하는 연산 mod

    - $n=dq+r\ (n \in Z,\ d \in N,\ 0 \le r < |d|)$을 만족하는 나머지 r을 구하는 연산은 아래와 같다.
    - $r=n\ mod\ d$





# 컴퓨터에서의 수의 연산 표현과 연산

- 보수(complement)
  - 기본적으로 2진수 표현만으로는 덧셈과 곱셈 연산만 가능하다.
    - 2진수 표현에 뺄셈과 나눗셈을 가능하게 해주는 것이 보수 표현이다.
  - 보수는 보충해주는 수를 의미하는 것으로, 어떤 수 a에 대한 n의 보수는 a와의 합이 n이 되는 수를 말한다.
    - 혹은 기수가 n인 어떤 수 a에 대한 n의 보수는 n으로부터 a까지 떨어진 거리라고도 할 수 있다.
    - 예를 들어, 10진수 1에 대한 10의 보수는 9이고, 5진수 3에 대한 5의 보수는 2이다.
  - n진수에서의 보수는 n의 보수와 n-1의 보수가 존재한다.
    - 10진수에서는 10의 보수와 9의 보수가 존재하고, 5진수에는 5의 보수와 4의 보수가 존재한다.
    - 2진수에도 마찬가지로 2의 보수와 1의 보수가 존재한다.



-  2진수의 보수
  - 1의 보수
    - 어떤 2진수 a와의 합이 1(즉 1~2~)이 되는 수.
    - 2진수를 구성하는 숫자 0~2~과 1~2~에 대한 1의 보수는 다음과 같다.
    - 0~2~에 대한 1의 보수: $0_2 + x = 1_2\ ∴ x=1_2$
    - 1~2~에 대한 1의 보수: $1_2 + x = 1_2\ ∴ x =0_2$
    - 즉, 2진수의 각 자리 숫자를 0은 1로, 1은 0으로 바꾸면 주어진 2진수의 1의 보수가 된다.
    - 예를 들어 110101~2~에 대한 1의 보수는 001010~2~이다.
  - 2의 보수
    - 어떤 2진수 a와의 합이 2(즉 10~2~)이 되는 수.
    - 2진수를 구성하는 숫자 0~2~와 1~2~에 대한 2의 보수는 다음과 같다.
    - 단, 두 수의 합이 2가 나와야 하고, 2의 2진수 표현은 10~2~이므로, 합의 결과의 마지막 비트가 0인지만 확인한다.
    - 0~2~에 대한 2의 보수: $0_2+x=0_2\ ∴x=0_2$
    - 1~2~에 대한 2의 보수: $1_2+x=10_2\ ∴x=1_2$
  - 2의 보수는 1의 보수에 1~2~를 더한 결과와 같다.
    - 0~2~에 대한 2의 보수는 0~2~로, 0~2~에 대한 1의 보수 1~2~에 1~2~를 더한 결과와 같다(1~2~+1~2~=10~2~)
    - 1~2~에 대한 2의 보수는 1~2~로, 1~2~에 대한 1의 보수 0~2~에 1~2~를 더한 결과와 같다(0~2~+1~2~=1~2~)
    - 예를 들어 110101~2~에 대한 1의 보수는 001010~2~이고, 1의 보수에 1~2~를 더한 001011~2~는 2의 보수이다.



- 컴퓨터에서의 수의 표현

  - 컴퓨터는 데이터를 처리할 때 워드(word) 단위로 처리하는데, 워드의 기분 구조는 아래와 같다.
    - 최상위 비트는 수자에 대해서는 부호로, 문자에 대해서는 구분 기준으로 사용되며, 워드의 나머지 비트는 데이터 값을 표현하는 데 사용된다.
    - 1byte(8bit)일 경우 최상위 bit를 제외한 7개의 bit로 데이터를 표현한다.

  | 최상위 비트 | ···  | ···  | ···  | ···  | 최하위 비트 |
  | ----------- | ---- | ---- | ---- | ---- | ----------- |

  - 컴퓨터에서는 정수 데이터를 부호-절댓값, 부호-1의 보수, 부호-2의 보수 형태로 표현한다.



- 부호- 절댓값 표현(sign-magnitude)

  - 워드의 데이터 비트를 정수 데이터의 절댓값으로 표현하는 방식
  - 양수 53과 음수 -53은 각기 아래와 같이 표현한다.
    - 최상위 비트는 부호를 의미하므로, 양수에 대해서는 0, 음수에 대해서는 1로 표시한다.
    - 그리고 나머지 7비트의 데이터 비트 영역에는 절댓값 |53|의 2진수 표현이 표시될 것이다.
    - 그런데 |53|의 2진수인 110101~2~는 6bit로, 7bit를 모두 채우지 못한다.
    - 이 때 왼쪽의 남는 비트는 0으로 채운다.

  | +53  | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | -53  | 1    | 0    | 1    | 1    | 0    | 1    | 0    | 1    |



- 부호-1의 보수(sign-1's complement) 표현

  - 워드의 데이터 bit를 정수 데이터의 절댓값에 대한 1의 보수로 표현하는 방식
  - 워드를 구성하는 bit 중 데이터 bit의 영역이 1의 보수로 채워지고, 부호 비트의 값은 바뀌지 않는다.
  - 양수의 경우 부호-1의 보수 표현은 부호-절댓값 표현과 같다.
  - 양수 53과 음수 -53에 대한 부호-1의 보수 표현은 다음과 같다.

  | +53  | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | -53  | 1    | 1    | 0    | 0    | 1    | 0    | 1    | 0    |



- 부호-2의 보수(sign-2's complement) 표현

  - 워드의 데이터 bit를 정수 데이터의 절댓값에 대한 2의 보수로 표현하는 방식
  - 양수일 경우에는 부호-2의 보수 표현과 같지만, 음수일 경우 다르다.

  | +53  | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | -53  | 1    | 1    | 0    | 0    | 1    | 0    | 1    | 1    |



- 부호-2의 보수 표현을 사용하는 이유

  - 부호-절댓값 방식의 문제점
    - 1워드가 4bit인 컴퓨터에서 -3-4 = (-3)+(-4)를 연산해보자.
    - 10진수 -3과 -4의 세 가지 표현 방식에 따른 덧셈 연산 결과는 다음과 같다.
    - 부호-절댓값은 10111~2~, 부호-1의 보수는 10111~2~, 부호-2의 보수는 11001~2~로 모두 4bit를 초과(overflow)하게 된다.
    - 초과란 입력이나 연산의 결과가 1워드를 넘는 경우로, 1워드가 n 비트일 때 n+1비트가 되는 경우를 말한다.
    - 이 때, 어떤 방식을 사용하느냐에 따라 초과에 대한 처리 방식이 달라진다.
    - 부호-절댓값 표현과, 부호-2의 보수 표현을 이용한 연산에서 발생하는 초과는 무시한다.
    - 반면 부호-1의 보수 표현을 이용한 연산에는 1차 연산 결과의 최하위 비트에 초과한 비트를 더하여 연산을 완료한다.
    - 따라서 위의 경우 부호-1의 표현의 결과값은 10111~2~에 초과분인 1을 더하고 초과분을 버린 1000~2~가 된다.
    - 각 연산 결과의 정확성은 다음과 같다.
    - 우선 부호-1의 보수 표현의 연산 결과인 1000과 부호-2의 보수 표현의 연산 결과인 1001은 10진수로 변환하면 -7로, 정확하다(변환 방법은 이후에 살펴본다).
    - 그러나 부호-절댓값 표현의 연산 결과인 0111은 10진수로 변환하면 7로, 틀린 결과가 나온다.
    - 따라서 부호-절댓값 표현을 이용한 연산은 정확한 결과를 출력하지 못한는 문제가 있다.
  - 각 방식별 표현할 수 있는 데이터의 범위
    - 부호-절댓값 표현: $-(2^{n-1}-1)$~$(2^{n-1}-1)$
    - 부호-1의 보수 표현: $-(2^{n-1}-1)$~$(2^{n-1}-1)$
    - 부호-2의 보수 표현: $-2^{n-1}$~$2^{n-1}-1$

  - 부호-1의 보수 표현의 문제점
    - 0은 양수도 아니고, 음수도 아니므로 +0, -0이라는 표현은 존재하지 않는다.
    - 그런데 0의 부호-절댓값 표현은 0000(+0~10~)과 1000(-0~10~)으로 두 가지이며, 부호-1의 보수표현 또한 0000(+0~10~)과 1111(-0~10~)으로 두 가지이다.
    - 즉 +0과 -0이라는 표현이 존재하지 않음에 위배된다.
    - 그러나 부호-2의 보수 표현에서는 초과되는 비트를 무시하므로, 10진수 0은 0000 하나로 표현된다.
    - 0이 -0과 +0의 두 개의 값을 가지게 됨에 따라 부호-절댓값 표현과 부호-1의 보수 표현의 경우 표현할 수 있는 범위가 부호-2의 보수 표현보다 1개 작다.



- 보수의 10진수 변환

  - 보수 표현과 부호-절댓값 표현이 동일한 양수의 경우 일반적인 방법을 사용하여 2진수를 10진수로 변환한다.

    - 반면, 보수 표현과 부호-절댓값 표현이 다른 음수의 경우 다음 방법을 이용하여 10진수로 변환한다.

  - 부호-1의 보수로 표현한 값의 10진수 변환

    - 부호-1의 보수로 표현한 값을 10진수로 변환하는 방법은 두 가지가 있다.
    - $-(2^{n-1}-1)$+(데이터 비트의 10진수 표현).
    - 1의 보수 표현의 데이터 비트 부분을 다시 1의 보수로 변환한 후, 이를 10진수로 변환.
    - 예를 들어 1워드가 8bit이면서 부호-1의 보수로 표현된 11001010을 각 방식을 사용하여 변환하는 과정은 아래와 같다.

    $$
    -(2^{8-1}-1)+(1 \times 2^6 + 0 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2)\\
    =-127+(64+0+0+8+0+2+0) \\
    = -53
    \\
    \\
    11001010에\ 대한\ 1의\ 보수:10110101\\
    10110101=-(0 \times 2^6 + 1 \times 2^5 + 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2)\\
    =-(0+32+16+0+4+0+1) \\
    = -53
    $$

  - 부호-2의 보수로 표현한 값의 10진수 변환

    - 부호-2의 보수로 표현한 값을 10진수로 변환하는 방법 역시 두 가지가 있다.
    - $-2^{n-1}$+(데이터 비트의 10진수 표현)
    - 2의 보수 표현의 데이터 비트 부분을 다시 2의 보수로 변환한 후, 이를 10진수로 변환
    - 예를 들어, 1워드가 8bit이면서 부호-2의 보수로 표현된 11001011을 각 방법을 이용해 변환하는 과정은 아래와 같다.

    $$
    -2^{8-1}+(1 \times 2^6 + 0 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2)\\
    =-128+(64+0+0+8+0+2+1)\\
    =-53
    \\
    \\
    11001011=-(1 \times 2^6 + 0 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2)\\
    =-(0+32+16+0+4+0+1)
    $$



- 보수의 연산
  - 부호-2의 보수는 연산도 정확하고, 0에 대한 표현도 한 가지라서 컴퓨터에서는 2의 보수를 이용해 표현하고, 연산한다.
    - 그리고 부호-1의 부소는 0에 대한 표현이 통일되지 않지만, 연산은 정확하다.
    - 그러므로 이 두 가지 표현을 이용하여 연산을 처리하는 방법을 살펴볼 것이다.
  - 예시
    - 1워드가 8bit일 때, -15-66을 구해보자, |15|는 2진수로 표현했을 때 00001111~2~이고, |66|은 2진수로 표현했을 때, 01000010~2~다. 
    - 부호-절댓값 표현은 각각 -15의 2진수 표현은 10001111~2~, -66의 2진수 표현은 11000010~2~이다.
    - 이를 이용하여 부호-1의 보수를 연산하면 다음과 같다.
    - 11110000+10111101 = 110101101인데, 초과분인 1을 더하면 10101110이 된다.
    - 부호-2의 보수를 연산하면 다음과 같다.
    - 11110001+10111110 = 110101111인데, 초과분인 1을 무시하면 1010111이 된다.







# 명제와 논리

- 명제
  - 명제는 현실 세계를 간략하고 정확하게 판별하도록 표현한 문장이며, 수학적 논리를 구성하는 가장 기본적인 단위이다.
    - 그러므로 명제는 누구나 객관적으로 참과 거짓을 구분할 수 있어야 한다.
  - 진릿값(truth value)
    - 참이나 거짓을 가리키는 값
  - 명제(proposition)
    - 객관적인 기준으로 진릿값을 구분할 수 있는 문장이나 수식
    - 일반적으로 명제는 소문자 p, q, r, ··· 로 표현
    - 객관적으로 참과 거짓을 구분할 수 있는 문장이어야 하므로, 미지수 x값에 따라 값이 달리지는  'x+1=2'와 같은 식은 명제라고 볼 수 없다.
    - 단, '정수 x에 대하여 |x|<=0을 만족하는 정수가 적어도 한 개는 있다'와 같은 문장은 x 값에 따라 진릿값이 결정되는 것이 아니라 |x|<=0을 만족하는 정수가 존재하느냐 존재하지 않느냐에 따라 진릿값이 결정되므로, 명제이다.



- 논리 연산자
  - 합성명제(compound proposition)
    - 하나 이상의 명제들이 논리 연산자에 의해 결합된 명제
    - 일반적으로 명제 하나를 단순명제(simple proposition)라 한다.
    - 하나 이상의 단순명제를 부정, 논리곱, 논리합, 배타적 논리합과 같은 논리 연산자로 결합하면 새로운 하나의 명제가 되기도 하는데, 이를 합성명제라고 한다.
  - 진리표
    - 합성명제를 구성하는 단순명제의 진릿값에 따른 논리 연산 결과를 나타낸 표.



- 부정(not, ￢p 또는 ~p)

  - 명제 p에 대하여 'p가 아니다'를 의미한다.
    - 명제 p와 반대의 진릿값을 갖는 연산.
    - 부정 ￢은 명제 하나에 대해 사용하는 단항 연산자이다.
    - 명제 ￢p는 명제 p와 반대의 의미를 가지므로, 'p가 아니다', 'not p' 혹은 'p의 부정'이라고 읽는다.
  - 진리표

  | p    | ￢p  |
  | ---- | ---- |
  | T    | F    |
  | F    | T    |



- 논리곱(AND: p∧q)

  - 명제 p, q에 대하여, 'p 그리고 q'를 의미
    - 명제 p, q의 진릿값이 모두 참일때만 결과가 참인 연산
    - 두 명제를 결합하는 데 사용하는 이항연산자로, '그리고'의 의미를 갖는다.
    - 명제 p ∧ q의 진릿값은 두 단순명제 p, q의 진릿값이 모두 참일 때만 참이고, 두 단순명제 중 하나라도 거짓이면 거짓이다.

  - 진리표

  | p    | q    | p∧q  |
  | ---- | ---- | ---- |
  | T    | T    | T    |
  | T    | F    | F    |
  | F    | T    | F    |
  | F    | F    | F    |



- 논리합(OR: p∨q)

  - 명제 p, q에 대하여 'p 또는 q'를 의미
    - 명제 p, q의 진리값 중 하나라도 참이면 결과가 참인 연산.
  - 진리표

  | p    | q    | p∨q  |
  | ---- | ---- | ---- |
  | T    | T    | T    |
  | T    | F    | T    |
  | F    | T    | T    |
  | F    | F    | F    |



- 배타적 논리합(Exclusive OR, XOR: p ⊕ q)

  - 두 명제 p, q의 진릿값중 하나만 참일 때 결과가 참이고, 그 외의 경우에는 모두 결과가 거짓인 연산.
  - 진리표

  | p    | q    | p⊕q  |
  | ---- | ---- | ---- |
  | T    | T    | F    |
  | T    | F    | T    |
  | F    | T    | T    |
  | F    | F    | F    |



## 조건명제

- 조건명제(conditional proposition, p→q) / 함축(implication)

  - 단순명제에 역할을 부여해 단순명제의 역할에 따라 진릿값이 결정되는 합성명제
  - 명제 p, q에 대하여 명제 p가 전제(premise) 또는 가정(hypothesis)이고 명제 q가 결론(conclusion) 또는 결과(consequence)인 명제.
  - 조건명제 p→q를 표현하는 문장은 다음과 같다.
    - if p, then q
    - p implies q
    - p only if q
    - p is sufficient for q
    - q is neccessary for p
  - 진리표
    - 조건명제 p→q는 전제 명제가 참이고 결론 명제가 거짓인 경우에만 거짓이고, 그 외의 경우에는 모두 참이다. 

  | p    | q    | p→q  |
  | ---- | ---- | ---- |
  | T    | T    | T    |
  | T    | F    | F    |
  | F    | T    | T    |
  | F    | F    | T    |

  - 역(converse)
    - 조건 명제 p→q에 대하여, q→p 형태의 명제
    - 역은 조건명제에서 전제 명제가 견론이 되고, 결론 명제가 전제가 되는 명제를 말한다.
  - 이(inverse)
    - 조건명제 p→q에 대하여, ￢p→￢q 형태의 명제.
  - 대우(contraposition)
    - 조건명제 p→q에 대하여, ￢q→￢p 형태의 명제.
  - 역, 이, 대우의 진리표
    - 본 명제와 대우의 진리값은 같다.

  | p    | q    | 조건명제 | 역   | 이   | 대우 |
  | ---- | ---- | -------- | ---- | ---- | ---- |
  | T    | T    | T        | T    | T    | T    |
  | T    | F    | F        | T    | T    | F    |
  | F    | T    | T        | F    | F    | T    |
  | F    | F    | T        | T    | T    | T    |



- 쌍방조건명제(biconditional proposition: p ↔ q)

  - 명제 p, q가 모두 전제이면서 동시에 결론인 명제

  - $(p → q) \and (q→p)$에서 논리곱 앞의 조건 명제에서는 p가 전제, q가 결론이고, 논리곱 뒤의 조건명제에서는 q가 전제, p가 결론이다.
    - 그러므로 이 합성명제는 p, q가 모두 전제이면서 결론인 명제이다.
  - 쌍방조건명제 p↔q는 다음과 같이 표현한다.
    - if p then q, and conversely
    - p is neccessary and suffient for q
  - 진리표

  | p    | q    | p↔q  |
  | ---- | ---- | ---- |
  | T    | T    | T    |
  | T    | F    | F    |
  | F    | T    | F    |
  | F    | F    | T    |

  - 합성명제 $(p → q) \and (q→p)$는 쌍방조건명제 p↔q의 다른 표현이다.
    - 진리표를 이용하여 두 명제가 동치임을 확인할 수 있다.

  | p    | q    | p↔q  | p→q  | q→p  | (p→q) ∧(q→p) |
  | ---- | ---- | ---- | ---- | ---- | ------------ |
  | T    | T    | T    | T    | T    | T            |
  | T    | F    | F    | F    | T    | F            |
  | F    | T    | F    | T    | F    | F            |
  | F    | F    | T    | T    | T    | T            |



## 합성명제

- 논리 연산자 우선순위

  - 합성명제는 하나 이상의 단순명제를 논리 연산자로 결합한 명제를 말한다.
  - 합성명제의 진릿값은 각 단순 명제의 진릿값에 따라 달라지지만, 논리 연산자의 연산 순서 또한 합성명제의 진릿값을 결정하는 데 영향을 미친다.

  - 논리 연산자의 우선 순위는 다음과 같다.
    - ( )
    - ￢
    - ∧
    - ∨
    - →
    - ↔



- 합성 명제의 종류

  - 항진명제(tautology: T)

    - 합성명제를 구성하는 단순명제의 진릿값에 상관없이 합성명제의 진릿값이 항상 참인 명제
    - 예시: p∨￢p의 진릿값은 단순명제 p의 진릿값이 참이든 거짓이든 상관 없이 참이므로, p∨￢p는 항진명제이다.

    | p    | ￢p  | p∨￢p |
    | ---- | ---- | ----- |
    | T    | F    | T     |
    | F    | T    | T     |

  - 모순명제(contradiction: F)

    - 합성명제를 구성하는 단순명제의 진릿값에 상관 없이 합성명제의 진릿값이 항상 거짓인 명제

    - 예시:  p∧￢p의 진릿값은 단순명제 p의 진릿값이 참이든 거짓이든 상관 없이 거짓이므로, p∧￢p는 모순명제이다.

    | P    | ￢p  | p∧￢p |
    | ---- | ---- | ----- |
    | T    | F    | F     |
    | F    | T    | F     |

  - 사건명제(contingency)

    - 항진명제도 모순명제도 아닌 합성명제
    - 합성명제를 구성하는 단순명제의 진릿값에 따라 그 진릿값이 달라지는 명제.



## 논리적 동치

- 합성명제는 하나 이상의 단순명제를 논리 연산자로 결합한 형태이므로 복잡한 형태일 수도 있다.
  - 합성명제가 복잡하다는 것은 컴퓨터 시스템에서 표현하고 연산해야하는 논리 연산의 수가 많음을 의미한다.
  - 많은 논리 연산으로 복잡하게 표현된 합성명제를 진리값이 같으면서 단순한 논리 연산으로 표현된 합성명제로 대체한다면, 컴퓨터 시스템에서도 같은 결과를 내면서 간단하고 빠르게 표현이 가능하다.



- 논리적 동치(logically equivalance: P ≡ Q)
  - 두 합성명제 P와 Q의 진릿값이 서로 같은 경우.
  - 두 합성명제 P, Q에 대하여 P ≡ Q일 때 아래와 같이 표현한다.
    - 합성명제 P와 Q는 동치이다.
    - 합성명제 P와 Q는 같다.
  - 동치의 판별 방식은 아래와 같다.
    - 진리표를 이용한 논리적 동치 판별
    - 논리적 동치법칙을 이용한 논리적 동치 판별



- 논리적 동치법칙

  - 합성명제들 중 항상 동치인 합성명제를 모아 법칙으로 정리한 것이 논리적 동치법칙이다.
  - 이를 활용하여 복잡한 합성명제를 단순한 표현의 합성명제로 바꿀 수 있다.

  | p ∧ T ≡ p                       | p ∨ F ≡ p                       | 항등법칙(identity law)             |
  | ------------------------------- | ------------------------------- | ---------------------------------- |
  | p ∧ F ≡ F                       | p ∨ T ≡ T                       | 지배법칙(domination law)           |
  | p ∧￢p ≡ F                      | p ∨￢p ≡ T                      | 부정법칙(negation law)             |
  | ￢(￢p) ≡ p                     |                                 | 이중 부정법칙(double degation law) |
  | p ∧ p ≡ p                       | p ∨ p ≡ p                       | 멱등법칙(idempotent law)           |
  | p ∧ q ≡ q ∧ p                   | p ∨ q ≡ q ∨ p                   | 교환법칙(commutative law)          |
  | (p ∧ q) ∧ r ≡ p ∧ (q ∧ r)       | (p ∨ q) ∨ r ≡ p ∨ (q ∨ r)       | 결합법칙(associative law)          |
  | p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (q ∨ r) | p ∧ (q ∨ r) ≡ (p ∧ q) ∨ (q ∧ r) | 분배법칙(distributive law)         |
  | ￢(p ∧ q) ≡ ￢p∨￢q             | ￢(p ∨ q) ≡ ￢p ∧￢q            | 드 모르간의 법칙(De Morgan's law)  |
  | p ∧ (p ∨ q) ≡ p                 | p ∨ (p ∧ q) ≡ p                 | 흡수법칙(absorption law)           |
  | p→q ≡ ￢p∨q                     |                                 | 함축법칙(implication law)          |

  - 결합법칙과 분배법칙 관련 주의사항
    - 괄호 안의 논리 연산자와 괄호 밖의 논리 연산자가 같은 경우는 결합법칙을 적용해야한다.
    - 괄호 안의 논리 연산자와 괄호 밖의 논리 연산자가 다른 경우는 분배법칙을 적용해야한다.



## 명제함수와 한정자

- 명제함수(propositional function: P(x))

  - 논의영역이 주어진 변수 x를 포함하여 진릿값을 판별할 수 있는 문장이나 수식
  - 명제함수는 일반적으로 P, Q, R과 같은 대문자와 명제함수에 포함된 변수를 함께 표시한다.

  - 논의영역(domain of discource: D)
    - 명제함수에 포함된 변수 x의 범위나 값
  - 예시
    - P(x): 정수 x에 대하여 |x| <= 0 을 만족하는 정수가 적어도 한 개는 있다.



- 한정자
  - 논의영역이 특정 값으로 주어질 수도 있으나, 값이나 원소의 범위 형태로 주어질 수도 있다.
    - 논의 영역이 범위 형태로 주어지는 경우 주어진 범위에 포함되는 값들이 모두 명제함수를 참으로 만드는지, 아니면 일부 값만이 명제함수를 참으로 만드는지, 혹은 범위 내의 어느 값도 명제 함수를 참으로 만들지 않는지에 따라 명제함수의 진릿값이 달라질 수 있다.
    - 따라서 범위 형태로 논의영역이 주어지는 경우 명제함수가 논의영역 전체 값에 대한 것인지, 혹은 일부에 대한 것인지를 표시해야 하는데, 이를 한정자라한다.
  - 결국 논의영역이 범위 형태로 주어지는 경우, 명제함수에 포함되는 모든 변수가 한정자에 의해 제한된 구속변수여야만 정확한 진릿값을 판별할 수 있다.
    - 구속변수(binding variable): 한정자에 의해 범위가 제한되는 변수
    - 자유변수(free variable): 한정자에 의해 범위가 제한되지 않는 변수



- 한정자는 전체 한정자와 존재 한정자로 구분된다.

  - 전체 한정자(universal quantifier: ∀)
    - 논의영역에 포함되는 모든 값(원소)을 의미
    - 논의영역 D에 포함되는 모든 x에 대한 명제 P(x) : ∀ xP(x)
    - 전체 한정자로 논의영역의 범위가 주어진 명제함수 P(x)는 ∀ xP(x)로 표기한다.
    - '모든 x에 대하여 P(x)이다'라고 읽는다.
    - ∀ xP(x)는 명제함수 P(x)의 진릿값이 논의영역에 포함된 모든 원소에 대하여 참이면 명제함수의 진릿값을 참으로 판한단다.
    - 반면에 논의영역에 포함되는 원소 중 하나에 대해서라도 명제함수가 거짓이면 그 명제함수는 거짓으로 판단한다.

  - 존재 한정자(existential quntifier: ∃)
    - 논의영역에 포함되는 모든 값(원소) 중 일부를 의미
    - 논의영역 D에 포함되는 어떤 x에 대한 명제 P(x): ∃ xP(x)
    - 존재 한정자로 논의영역에서 범위가 주어진 명제함수는 ∃ xP(x)로 표기한다.
    - '어떤 x에 대하여 P(x)이다'라고 읽는다.
    - 명제함수 P(x)의 진릿값이 논의영역에 포함된 일부 원소에 대하여 참이면 명제함수의 진릿값을 참으로 판단한다.
    - 반면에 논의영역의 모든 원소에 대하여 명제함수가 거짓이면 그 명제함수는 거짓으로 판단한다.
  - 명제함수에 포함되는 변수가 두 개 이상인 경우에는 모든 변수에 대한 한정자를 표시해야한다.
    - 예를 들어 P(x, y)와 같은 명제함수가 있을 때, ∀x ∀y P(x,y) 혹은 ∃x ∀y P(x,y) 등으로 모든 변수에 대한 한정자를 표시해야만 한다.
    - 또한 표현 순서에 따라서도 의미가 달라진다.

  | 한정된 명제함수 | 문장 표현                                                    |
  | --------------- | ------------------------------------------------------------ |
  | ∀x ∀yP(x, y)    | 모든 x와 모든 y에 대하여, P(x, y)가 성립한다.                |
  | ∀x ∃yP(x, y)    | 모든 x에 대하여, P(x, y)를 만족하는 y가 적어도 하나 존재한다. |
  | ∃x ∀yP(x, y)    | 어떤 x가 존재하여 모든 y에 대해, P(x, y)가 성립한다          |
  | ∃x ∃yP(x, y)    | 어떤 x에 대하여, P(x, y)를 만족하는 y가 적어도 하나 존재한다. |
  | ∀y ∀xP(x, y)    | 모든 y와 모든 x에 대하여, P(x, y)가 성립한다.                |
  | ∀y ∃xP(x, y)    | 모든 y에 대하여, P(x, y)를 만족하는 x가 적어도 하나 존재한다. |
  | ∃y ∀xP(x, y)    | 어떤 y가 존재하여 모든 x에 대해, P(x, y)가 성립한다          |
  | ∃y ∃xP(x, y)    | 어떤 y에 대하여, P(x, y)를 만족하는 x가 적어도 하나 존재한다. |



- 한정자와 논리합/논리곱
  - 명제함수도 명제이므로 논리 연산이 가능하다.
  - 한정자로 제한된 명제함수의 논리합과 논리곱 연산은 다음과 같다,
    - $∀x(P(x) \and Q(x))≡∀xP(x) \and ∀xQ(x)$
    - $∃x(P(x) \or Q(x))≡∃xP(x) \or ∃xQ(x)$
  - 위 연산을 보면 전체 한정자의 경우에는 논리합에 대하여($∀x(P(x) \or Q(x))$), 존재한정자의 경우에는 논리곱에 대하여($∃x(P(x) \and Q(x))$) 논리식이 언급되지 않았음을 알 수 있다.
    - 이는 $∀x(P(x) \or Q(x))$와  $∀xP(x) \or ∀xQ(x)$ 사이에 동치관계가 성립하지 않고,
    - $∃x(P(x) \and Q(x))$와 $∃xP(x) \and ∃xQ(x)$ 사이에 동치관계가 성립하지 않기 때문이다.



- 한정자와 부정
  - 한정자로 제한된 명제함수의 부정 연산은 다음과 같다.
    - $￢∀xP(x)≡∃x(￢P(x))$
    - $￢∃xP(x)≡∀x(￢P(x))$
  - 예시
    - 논의 영역이 $D=\{d|d \in 과일\}$이고, 명제함수 P(x)가 '이 상자에 있는 x는 사과이다'라고 하면 '이 상자에 있는 모든 과일은 사과이다'라는 명제는  ∀xP(x)와 같이 표현할 수 있다.
    - ∀xP(x)의 부정은 ￢∀xP(x)로 표현하고, 이는 '이 상자에 있는 어떤 과일은 사과가 아니다'라는 뜻이다.
    - 이를 기호로 표현하면 ∃x(￢P(x))이다.



## 추론

- 추론(inference) / 논증(reasoning)
  - 참인 명제를 근거로 하여 다른 명제가 참임을 유도하는 과정 또는 방식
  - 추론에서 사용하는 명제는 추론의 근거로 사용하는 명제와 결론으로 나오는 명제로 구성된다.
  - 전제(hypothesis)와 결론(conclusion)
    - 전제: 결론의 근거가 되는 참인 명제
    - 결론: 주어진 전제에 의해 유도된 최종적인 참인 명제



- 유효추론과 허위추론

  - 추론의 결론이 참이냐 아니냐는 그 추론이 정당한지 아닌지를 판단한다.
    - 추론에서 전제로 사용되는 명제는 항상 참이다.
    - 그러나 참인 명제를 전제로 추론한다고 해도 추론 과정의 오류 등으로 인해 결론이 거짓을 수도 있다.
    - 결론이 거짓인 추론은 올바른 추론이 아니므로 결론이 참이 될 수 있도록 다른 전제를 이용하여 새로 추론해야한다.

  - 유효추론(valid inference, 정당한 추론)

    - 진릿값이 참인 주어진 전제를 이용하여 유도한 결론이 모두 참인 추론
    - 예를 들어 '태양이 달보다 지구와 멀면 지구는 자전한다(p→q)', '태양은 달보다 지구와 멀다(p)'는 두 개의 전제가 있고, '지구는 자전한다(q)'는 결론이 있을 때 진리표는 아래와 같다.

    | 전제 | 전제 | 결론 |
    | ---- | ---- | ---- |
    | p→q  | p    | q    |
    | T    | T    | T    |
    | F    | T    | F    |
    | T    | F    | T    |
    | T    | F    | F    |

    - 전제(p→q, p)가 모두 참인 경우에 모든 결론 또한 참이다.
    - 그러므로 이 추론은 유효추론이다.

  - 허위추론(fallacious inference, 부당한 추론)

    - 진릿값이 참인 주어진 전제를 이용하여 유도한 결론이 거짓인 추론
    - 예를 들어 '태양이 달보다 지구와 멀면 지구는 자전한다(p→q)', '지구는 자전한다(q)'는 두 개의 전제가 있고, '태양은 달보다 지구와 멀다(p)'는 결론이 있을 때 진리표는 아래와 같다.

    | 전제 | 전제 | 결론 |
    | ---- | ---- | ---- |
    | p→q  | q    | p    |
    | T    | T    | T    |
    | F    | F    | T    |
    | T    | T    | F    |
    | T    | F    | F    |

    - 전제가 모두 참임에도 결론이 거짓인 경우가 있다.
    - 따라서 이 추론은 허위추론이다.

​	

- 논리적 추론법칙

  - 논리적 동치법칙과 마찬가지로 추론에서 항상 성립하는 유효추론을 논리적 추론법칙이라고한다.
  - 정리
    - 유효추론의 전제들과 결론은 모두 진릿값이 참이다.
    - 따라서 유효추론의 전제에 해당하는 명제들을 논리곱으로 연산한 결과는 항상 참이다.
    - 또한 조건명제에서 조건인 명제가 참이면 결로인 명제도 참이어야 조건명제의 진릿값이 참이다.
    - 이 논리를 이용하여 추론의 전제와 결론을 논리곱 연산과 조건명제로 표현한 것이 아래 표의 항진명제 항목이다.

  | 법칙                                                     | 추론                      | 항진명제                |
  | -------------------------------------------------------- | ------------------------- | ----------------------- |
  | 논리곱<br />(conjunction)                                | p<br />q<br />∴ p ∧ q     | (p ∧ q) → (p ∧ q)       |
  | 선언적 부가<br />(disjunctive addition)                  | p<br />∴ p ∨ q            | p→(p ∨ q)               |
  | 단순화<br />(simplication)                               | p ∧ q<br />∴ p (또는 q)   | (p ∧ q) → p (또는 q)    |
  | 긍정논법<br />(modus ponens)                             | p<br />p → q<br />∴ q     | {p ∧ (p → q)} → q       |
  | 부정논법<br />(modus tollens)                            | ￢p<br />p → q<br />∴ ￢p | {￢q ∧ (p → q)} → ￢p   |
  | 선언적 삼단논법 또는 소거<br />(disjunctive syllogism)   | p ∨ q<br />￢q<br />∴ p   | {(p ∨ q) ∧ ￢q} → p     |
  | 가설적 삼단논법 또는 추이<br />(hyphothetical syllogism) | p→q<br />q→r<br />∴ p→r   | {(p→q) ∧ (q→r)} → (p→r) |





- ￢	
- ∧
- ∨
- →
- ↔
