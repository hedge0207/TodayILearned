# 가상 메모리 기초

- 가상 메모리(Virtial Memory)

  - 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다.
    - 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다.
    - 이러한 메모리 시스템을 가상 메모리라고 부란다.
    - 가상 메모리는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다.
    - 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경쓰지 않고 메모리를 마음대로 사용할 수 있다.
  - 가상 메모리가 필요한 이유
    - 메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 2GB의 메모리에서 동작하는 프로그램이 1GB의 메모리에서는 동작하지 않을 수 있다,
    - 또한 물리 메모리만을 사용해야 한다면 프로그래머 또한 메모리 크기에 맞는 응용프로그램만을 개발해야 하는데, 실제로 메모리 크기를 고려하여 프로그래밍하기란 매우 어렵다.
  - 가상 메모리의 크기와 주소
    - 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지와 무관하게 0번지부터 시작하는 연속된 메모리 공간을 가진다.
    - 논리 주소와 유사하지만 한 가지 차이점이 있는데, 논리 주소는 물리 메모리의 주소 공간에 비례하고, 가상 주소는 물리 메모리 공간이 아닌 가상의 주소 공간을 가진다는 것이다.
    - 가상 메모리는 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉜다.
    - 이론적으로 가상 메모리는 무한대의 크기이나, 실제로 가상 메모리의 최대 크기는 물리 메모리의 최대 크기로 한정되며, CPU의 비트에 따라 결정된다.
    - 32bit CPU의 경우 32bit로 표현할 수 있는 최대값인 2<sup>32</sup>-1(16진수로 FFFFFFFF)으로 약 4GB가 메모리의 최대 크기이고, 가상 메모리의 최대 크기도 약 4GB이다.
  - Swap In과 Swap Out
    - 32bit CPU의 최대 메모리 크기는 4GB이며, 이 시스템에서 각 4GB 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면 운영체제를 포함하여 적어도 40GB의 메모리가 필요하다.
    - 이 경우 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮긴다.
    - 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로, 메모리의 일부이며, 가상 메모리의 구성 영역 중 하나다.
    - 메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충한다.
    - 즉 물리 메모리가 꽉 찼을 때 일부 프로세스를 스왑 영역으로 보내고(swap out), 몇 개의 프로세스가 작업을 마쳐 메모리에 여유 공간이 생기면 스왑 영역에 있는 프로세스를 메모리로 가져온다(swap in).
    - 가상 메모리 시스템에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리와 스왑 영역을 합한 크기이다.
  - 동적 주소 변환(Dynamic Address Translation, DAT)
    - 앞서 말했듯 가상 메모리는 실제로 상요할 수 있는 최대 크기가 제한되어 있음에도 이론적으로 무한대의 크기가 있는 것 처럼 구현할 수 있다.
    - 이는 동적 주소 변환이라 불리는 작업을 통해 가능하다.
    - 가상 메모리 시스템에서 메모리 관리자가 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데 이러한 작업을 동적 주소 변환이라고한다.
    - 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 데이터를 물리 메모리에 배치할 수 있다.
    - 이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, 부족한 물리 메모리를 어떻게 처리할지 등의 문제들을 처리한다.
  - 가상 메모리의 메모리 분할 방식
    - 실제 메모리에 있는 물리 주소 0번지는 운영체제 영역이므로 일반 프로세스가 사용할 수 없다.
    - 따라서 가상 메모리 시스템에서는 운영체제를 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당한다.
    - 물리 메모리 분할 방식은 크게 가변 분할 방식과 고정 분할 방식으로 나뉘는데, 가상 메모리 시스템도 마찬가지이다.
    - 가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법은 세그먼테이션, 고정 분할 방식을 이용한 메모리 관리 기법은 페이징이라 한다.
    - 이 중 세그먼테이션은 가변 분할 방식의 단점인 외부 단편화 등의 문제 때문에 잘 사용되지 않는다.
    - 또한 페이징 기법은 페이지 관리에 어려움이 있다.
    - 따라서 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

  - 매핑 테이블
    - 가상 메모리 시스템에서 가상 주소와 물리 주소를 매핑하는 테이블이다.
    - 가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치하며, 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리한다.





## 페이징 기법

- 페이징 기법

  - 고정 분할 방식으로 가상 메모리를 분할하여 관리하는 기법이다.
  - 페이징 기법의 구현
    - 가상 주소의 분할된 각 영역은 페이지라고 부르며, 첫 번째 영역은 페이지0, 두 번째 영역은 페이지1과 같이 번호를 매겨 관리한다.
    - 물리 주소 공간을 같은 크기로 나누어 사용하며, 물리 메모리의 각 영역은 프레임이라고 부르고, 페이지와 마찬가지로 번호를 매겨 관리한다.
    - 페이지와 프레임의 크기는 같다.
    - 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다.
  - 페이지 테이블
    - 어떤 페이지가 어떤 프레임에 있는지에 대한 매핑 정보는 페이지 테이블에서 관리된다.
    - 페이지 테이블은 하나의 열로 구성된다.
    - 모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터 차례대로 페이지0, 페이지1, 페이지2, ...가 위치해 있는 프레임 번호를 가지고 있어, 페이지 번호를 나타내는 열은 필요가 없다.
    - 단, 페이지 번호가 순서대로 저장되지 않은 경우 페이지 번호를 표시하기도 한다.
    - 페이지 테이블에 숫자만 있는 것은 아니며, 물리 메모리가 아닌 스왑 영역에 있을 경우 invalid라고 표시된다.
    - 예를 들어 아래 페이지 테이블을 통해 페이지 0은 2번 프레임에, 페이지 1번은 1번 프레임에 위치해 있으며 페이지 5번은 스왑 영역에 위치해 있다는 것을 알 수 있다.
    - 페이지 테이블은 페이지 번호(열로 표현되지는 않는다), 프레임 번호로 구성되며, 각각의 줄은 페이지 테이블 엔트리(Page Table Entry, PTE)라 부른다. 
  
  | 프레임  |
  | ------- |
  | 2       |
  | 1       |
  | 3       |
  | 4       |
  | 0       |
  | invalid |



- 페이징 기법의 주소 변환

  - 주소 변환 과정
    - 가상 주소 공간과 물리 주소 공간을 똑같이 10B로 나누었다고 가정하자.
    - 1byte로 하나의 주소를 표현할 수 있으므로 한 페이지 혹은 한 프레임은 총 10개의 주소를 가진다.
    - 즉 페이지 0번에는 0~9번지의 10개 주소가, 페이지 1에는 10~19번지의 10개 주소가 있으며 물리 주소 공간도 마찬가지로 각 프레임에 10개의 주소가 있다.
    - 이 때 프로세스가 27번지의 내용을 읽으려고 할 때 주소 변환 과정은 아래와 같다.
    - 가상 주소 20번지가 어느 페이지에 있는지 확인한다.
    - 가상 주소 20번지는 페이지 2의 0번째에 위치해있다.
    - 페이지 테이블의 페이지 2로 가서 해당 페이지가 어떤 프레임과 매핑되어 있는지 확인한다.
    - 아레 페이지 테이블을 보면 페이지2는 프레임4와 매핑되어 있는 것을 확인할 수 있다.
    - 최종적으로 물리 메모리 프레임4의 0번째 위치에 접근한다.

  | 프레임  |
  | ------- |
  | 2       |
  | 3       |
  | 4       |
  | 1       |
  | 0       |
  | invalid |

  - 정형화된 주소 변환
    - 위의 주소 변환 과정을 정형화하면 아래와 같다.
    - 가상 주소는 `VA=<P,D>`와 같이 표현할 수 있다.
    - 여기서 VA(Virtual Address)는 가상 주소, P(Page)는 페이지, D(Distance)는 페이지의 처음 위치해서 해당 주소까지의 거리를 의미하며, D는 오프셋이라 부르기도 한다.
    - 가상 주소 20번지를 위 방식으로 정의하면 VA=<2, 0>으로 작성할 수 있다.
    - 물리 주소는 `PA=<F, D>`와 같이 표현할 수 있다.
    - PA(Physical Address)는 물리 주소, F(Frame)는 프레임, D(Distance)는 프레임의 처음 위치에서 해당 주소까지의 거리를 의미한다.
    - VA=<2,0>이 PA=<4,0>으로 변환되었다는 것은 가상 주소 20번지가 물리 주소 프레임 1의 0번 위치로 변환되었다는 의미이다.
    - 결론적으로 페이징 기법의 주소 변환은 아래와 같이 정형화할 수 있다.
    - `VA=<P, D> → PD<F, D>` 



- 16bit CPU를 사용할 경우 주소 변환 예시
  - 컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승으로 분할된다.
    - 위 예시에서는 편의를 위해 10B로 분할했으나, 실제 컴퓨터는 그렇게 동작하지 않는다.
    - 예를 들어 VAX라는 운영체제는 한 페이지의 크기가 2<sup>9</sup>byte이고, Windows는 2<sup>12</sup>byte이다.
  - 페이지의 크기가 다양할 경우 특정 가상 주소를 <P, D>로 변환하는 공식은 아래와 같다.
    - P = (가상 주소/한 페이지의 크기)의 몫, D = (가상 주소 / 한 페이지의 크기)의 나머지
    - 예를 들면 한 페이지의 크기가 512byte인 시스템에서 가상 주소 2049번지의 P는 2049/512의 몫인 4, D는 나머지인 1이다.
  -  16bit CPU의 컴퓨터에서 한 페이지의 크기가 2<sup>10</sup>bytes일 때 페이징 시스템의 구성은 아래와 같다.
    - 16bit CPU의 컴퓨터에서 한 프로세스가 사용할 수 있는 가상 메모리의 크기는 2<sup>16</sup>bytes이다.
    - 사용자는 0번지부터 65535(2<sup>16</sup>-1)번지까지 가상 주소 공간을 사용할 수 있다.
    - 한 페이지의 크기가 2<sup>10</sup>bytes이기 때문에 가상 주소로 활용할 수 있는 16bit중 6bit는 페이지 번호로, 10bit는 페이지의 처음 위치에서 해당 주소까지의 거리로 사용한다.
    - 만약 한 페이지의 크기가 2<sup>11</sup>bytes라면 16bit중 5bit는 페이지 번호로, 11bit는 패아지의 처음 위치에서 해당 주소까지 거리로 사용한다.
    - 한 페이지의 크기가 2<sup>10</sup>bytes일 경우 가상 주소 VA=<P, D>에서 P는 6bit, D는 10bit이다.
    - 이는 시스템 페이지가 0~63(2<sup>6</sup>-1)로 총 64개이고, 페이지 하나가 0~1023(2<sup>10</sup>-1)로 총 1024개 번지로 구성되어 있다는 의미이다.
    - 결국 페이지 0은 0~1023번지, 페이지 1은 1024~2047번지, ..., 페이지 63은 64512~65535번지로 구성된다.
    - 물리 주소도 가상 주소와 마찬가지로 1024bytes로 나눈다.
    - 가상 주소의 각 페이지가 어떤 프레임에 있는지는 페이지 테이블을 보면 알 수 있으며, 페이지 테이블의 크기는 물리 주소의 크기가 아니라 프로세스의 크기에 비례한다.
    - 물리 주소의 크기와 상관 없이 가상 주소를 많이 사용하면 페이지 테이블의 크기가 늘어나고, 적게 사용하면 페이지 테이블의 크기가 줄어든다.
  - 프로세스가 980번지에 저장된 데이터를 요청했을 때 가상 주소가 물리 주소로 변환되는 과정은 아래와 같다.
    - 가상 주소 980번지의 페이지 P와 거리 D를 구한다.
    - P는 (980/1024)의 몫, D는 (980/1024)의 나머지 이므로 VA=<0, 980>이다.
    - 페이지 테이블을 확인하여 페이지 0이 어떤 프레임과 매핑되어 있는지 확인한다(프레임 2번과 매핑되어 있다고 가정).
    - 프레임 2번의 시작 지점으로부터 980번지 떨어진 곳에 접근하여 데이터를 가져온다.



- 페이지 테이블 관리
  - 페이지 테이블 관리가 복잡한 이유
    - 시스템에는 하나의 프로세스만 있는 것이 아니라 여러 개의 프로세스가 존재하는데, 각 프로세스마다 페이지 테이블이 하나씩 있기 때문이다.
    - 예를 들어 프로세스 A, B, C가 있고, 각각의 프로세스는 하나의 물리 메모리를 사용하고 있는 상황이라고 가정해보자.
    - 프로세스는 메모리에 올라와야 실행 가능하므로 모든 프로세스의 일부 페이지가 물리 메모리의 프레임에 올라와 있고, 어떤 페이지가 어떤 프레임에 있는지 관리하기 위해 프로세스마다 페이지 테이블을 운영해야한다.
    - 메모리 관리자는 특정 프로세스가 실행될 때마다 각 프로세스의 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 작업을 반복한다.
  - 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓는다.
    - 페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빨리 접근할 수 있어야하기 때문이다.
    - 한 곳에 몰아 놓는다면 더 빨리 접근할 수 있게된다.
  - 페이지 테이블 관리의 가장 큰 문제는 페이지 테이블의 크기가 작지 않다는 것이다.
    - 시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다.
    - 한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.
    - 32bit CPU를 가지는 시스템이 있다고 가정할 때, 이 시스템이 가질 수 있는 물리 메모리의 최대 크기는 4GB이다.
    - 이 때, 페이징 시스템이 한 페이지의 크기를 512B로 관리한다면, 이 시스템에서 하나의 페이지 테이블의 최대 크기는 약 24.11MB이다.
    - 이 24.11MB는 페이지 테이블 하나의 크기이며, 만약 프로세스가 40개라면 페이지 테이블의 최대 크기는 1GB에 달하게 된다.
    - 이는 시스템에서 사용 가능한 물리 메모리 4GB의 25%에 해당하는 양이다.
    - 따라서 페이지 테이블의 크기를 적절하게 유지하는 것은 페이지 테이블 관리의 핵심이다.
  - Page Table Base Register(PTBR)
    - 각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 물리 메모리 상에서 페이지 테이블의 위치를 빠르게 파악할 필요가 있다.
    - 따라서 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터(PTBR)라는 곳에 보관한다.
    - PTBR은 각 프로세스 제어 블록에 저장된다.



- 페이지 테이블 매핑 방식

  - 물리 메모리 영역이 부족할 경우 프로세스만 스왑 영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.
    - 메모리 상에서 페이지 테이블의 크기가 늘어나면 페이지 테이블이 저장되는 운영체제 영역이 늘어나 그만큼 사용자 영역이 줄어든다.
    - 물리 메모리 영역이 부족할 경우 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.
    - 따라서 페이지 테이블 전체를 메모리에서 관리하느냐, 일부를 스왑 영역에서 관리하느냐에 따라 가상 주소를 물리 주소에서 관리하느냐에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라지게 된다.
  - 직접 매핑(Direct Mapping)
    - 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식이다.
    - 별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라 부른다.
    - 모든 페이지 테이블을 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠르다.
  - 연관 매핑(Associative Mapping)
    - 페이지 테이블 전체를 스왑 영역에서 관리하는 방식이다.
    - 물리 메모리의 여유 공간이 작을 때 사용하는 방식으로, 모든 페이지 테이블을 저장 장치의 스왑 영역에 저장하고 그중 일부만 무작위로 물리 메모리에 가지고 있는다.
    - 물리 메모리에 가지고 있는 일부 페이지 테이블을 변환 색인 버퍼(Translation Look-aside Buffer, TLB) 혹은 연관 레지스터(associate register)라고 부른다.
    - 이 방식에서 메모리에 접근하기 위해 먼저 변환 색인 버퍼를 찾아보는데, 원하는 페이지 번호가 있을 경우 TLB hit라 하며 바로 물리 주소로 변환된다.
    - 반대로 없을 경우 TLB miss라고 하며, 스왑 영역에 저장된 페이지 테이블을 사용하여 주소를 변환한다.
    - 일부 내용만 무작위로 배치하기 때문에 페이지의 번호가 연속적이지 않아 어떤 페이지를 가져왔는지 알 수 없으므로, 테이블의 열은 페이지 번호와 프레임 번호 둘 다 표시한다.
    - 따라서 연관 매핑의 경우 페이지 테이블의 열은 2개가 된다.

  | 페이지 | 프레임 |
  | ------ | ------ |
  | 0      | 1      |
  | 4      | 0      |
  | 5      | 5      |
  | 11     | 4      |
  | 16     | 9      |

  - 집합-연관 매핑(Set-Associative Mapping)
    - 연관 매핑에서는 일부 데이터만 무작위로 물리 메모리로 가져오기 때문에 원하는 프레임 번호를 얻기 위해 TLB 전체를 검색해야하는 문제가 있다.
    - 집합-연관 매핑은 연관 매핑의 이러한 문제를 개선한 방식이다.
    - 모든 페이지 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져온다는 것은 연관 매핑과 동일하다.
    - 그러나 집합-연관 매핑에서는 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.
    - 페이지의 번호가 연속적이므로 페이지 번호를 표시하지 않아도 되어 테이블의 열은 프레임 번호만 표시한다.
    - 페이지 테이블의 페이지들을 일정 개수씩 묶은 집합 테이블을 생성하고, 집합 테이블에 어떤 페이지 집합이 스왑 영역에 있고, 어떤 페이지 집합이 물리 메모리에 있는지를 표기한다.
    - 또한 물리 메모리에 있는 집합의 경우 물리 메모리의 몇 번지에 있는지를 저장하여 주소 변환 시간을 단축시킨다.
  - 역매핑(Invert Mapping)
    - 앞의 세 가지 매핑과 반대로 페이지 테이블을 구성하는 방식이다.
    - 앞의 세 방식은 페이지테이블의 번호를 기준으로 테이블을 구성하지만, 역매핑에서는 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다.
    - 다시 말해 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시한다.
    - 아래 표에서는 편의를 위해 페이지 테이블 컬럼에 프레임 번호도 작성했지만, 실제 페이지 테이블에는 프레임 순서대로 저장되기에 프레임 번호는 없으며, Process ID와 페이지 번호만 있다. 
    - 역매핑의 가장 큰 특징은 프로세스의 수와 상관없이 프레임 테이블이 하나만 존재한다는 것이다.
    - 다른 방식에서는 프로세스마다 페이지 테이블을 만들지만 역매핑에서는 물리 메모리를 기준으로 프레임 테이블을 만들기에 전체 시스템에서 테이블의 수가 단 1개이다.
    - 따라서 테이블의 크기가 매우 작다는 것이 장점이다.
    - 다만, 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점이 있다.
    - 예를 들어 아래 표에서 프로세스 1의 페이지 11이 물리 메모리에 있는지 확인하려면 <PID 1, page 11>을 모든 테이블에서 찾아야만 그 결과를 알 수 있다.
    - 또한 모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 속도가 아주 느리다(페이지는 물리 메모리의 프레임과 매핑되는 것이므로, 프레임에 해당하는 페이지가 없다는 것은 페이지가 물리 메모리가 아닌 스왑 영역에 저장되어 있다는 것을 의미한다).

  | 프레임 | Process ID | 페이지 |
  | ------ | ---------- | ------ |
  | 0      | 1          | 3      |
  | 1      | 1          | 0      |
  | 2      | 1          | 7      |
  | 3      | 2          | 2      |
  | 4      | 1          | 11     |







## 세그먼테이션

- 세그먼테이션 기법

  - 가변 분할 방식을 이용한 가상 메모리 관리 기법이다.
    - 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용한다.
    - 페이징 기법과 마찬가지로 세그먼테이션 기법도 매핑 테이블을 사용하며, 이를 세그먼테이션 테이블 또는 세그먼테이션 매핑 테이블이라 한다.
    - 세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit과 물리 메모리상의 주소를 나타내는 address가 있다.
    - 페이징 기법은 메모리를 같은 크기의 페이지로 분할하기에 매핑 테이블에 크기 정보를 유지할 필요가 없으나, 세그먼테이션 기법에서는 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함한다.
    - 세그먼테이션 역시 물리 메모리가 부족할 경우 스왑 영역을 사용한다.
    - 세그먼테이션 기법은 가변 분할 방식을 기본으로 하므로 가변 분할 방식의 장점과 단점을 모두 가지고 있다.
    - 즉, 메모리를 프로세스 단위로 관리하기에 세그먼테이션 테이블이 작다는 장점이 있으나, 외부 단편화로 인해 물리 메모리 관리가 복잡하다는 단점이 있다.
  - 아래는 세그먼테이션 테이블의 예시로, `I`(Invalid)는 해당 세그먼트가 스왑 영역에 있다는 것을 의미한다.
    - 페이지 테이블과 마찬가지로 0번 세그먼트부터 순서대로 위치하므로, 세그먼트 번호는 따로 열로 작성하지 않는다.

  | limit | address |
  | ----- | ------- |
  | 280   | 120     |
  | 140   | 400     |
  | 100   | 780     |
  | 120   | I       |



- 가상 주소를 물리 주소로 변환하는 과정

  - 세그먼테이션에서는 가상 주소를 `VA=<S, D>`로 표현한다.
    - S는 세그먼트 번호, D는 세그먼트 시작 지점에서 해당 주소까지의 거리를 의미한다.
    - 가상 메모리 시스템에서 사용자에게 보이는 메모리는 항상 0부터 시작하므로 페이징 기법이든 세그먼테이션 기법이든 D는 사용자가 지정한 주소 그 자체이다. 
  - 가상 주소를 물리 주소로 변환하는 과정은 아래와 같다.
    - 프로세스 A는 세그먼트 0, 프로세스 B는 세그먼트 1, 프로세스 C는 세그먼트 2로 분할되어 있다고 가정해보자.
    - 이 때 프로세스 A의 32번지에 접근하고자 한다면, 먼저 가상 주소를 구해야한다.
    - 프로세스 A는 세그먼트 0으로 분할되어있으므로 S는 0이다. 따라서 가상 주소는 VA=<0, 32>이다.
    - 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152번지를 구한다.
    - 이 때 메모리 관리자는 거리가 세그먼트의 크기(limit)보다 큰지 점검하는데, 만약 더 크다면 메모리 오류를 출력하고 해당 프로세스를 강제 종료하며, 크지 않다면 물리 주소를 구한다.
    - 물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 쓴다.

  | limit | address |
  | ----- | ------- |
  | 280   | 120     |
  | 100   | 330     |
  | 400   | 480     |

  - 트랩(Trap)
    - 사용자가 세그먼트의 크기보다 더 큰 주소에 접근하려고 하면 메모리 관리자는 해당 프로세스를 강제 종료하는데 , 이 때 발생하는 오류를 트랩이라 한다.
    - 예를 들어 프로세스 A에서 limit인 280을 벗어나는 접근, 즉 시작 주소인 120으로부터 280보다 더 멀리 떨어진 주소에 접근하려고 할 경우 트랩이 발생하게 된다.
    - 트랩은 자신의 영역을 벗어나는 주소에 접근하거나, 숫자를 0으로 나누는 것과 같이 사용자가 의도치 않게 일으키는 인터럽트를 말한다.
    - 트랩이 발생하면 운영체제는 사용자에게 세그먼테이션 오류 메시지를 보낸다.







## 세그먼테이션-페이징 혼용 기법

- 페이징 기법과 세그먼테이션 기법은 각각의 장단점을 가지고 있다.
  - 페이징 기법은 물리 메모리를 같은 크기로 나누어 관리하기 때문에 메모리 관리가 수월한 반면 페이지 테이블의 크기가 크다는 단점이 있다.
  - 세그먼테이션 기법은 세그먼테이션 테이블의 크기를 작게 유지할 수 있으나 물리 메모리의 외부 단편화가 발생할 수 있다는 단점이 있따.
  - 세그먼테이션-페이징 혼용 기법은 두 기법의 장점만 취한 가상 메모리 관리 기법이다.



- 메모리 접근 권한
  - 메모리 접근 권한은 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 아래와 같은 종류가 있다.
    - 읽기(read)
    - 쓰기(write)
    - 실행(execute)
    - 추가(append)
  - 네 가지 권한은 복합적으로 사용되며, 이론상으로는 네 가지 메모리 접근 권한을 모두 조합하면 16(2<sup>4</sup>)가지 access control mode가 나온다.
    - 그러나 실제로는 추가 권한의 경우 항상 쓰기 권한이 동반되어야 하므로 추가 권한은 쓰기 권한과 같이 취급되어 8가지 접근 방식이 있따.
    - 또한 읽기 권한 없이 쓰기만 하는 경우는 거의 없기 때문에 읽기는 못하고 쓰기만 하는 경우도 실제로는 사용되지 않는다.
  - 메모리 접근 권한 검사는 가상 주소에서 물리 주소로 변환이 일어날 때마다 시행된다.
    - 만약 읽기만 가능한 메모리 영역에 쓰기를 하려고 하면 메모리 오류인 트랩이 발생한다.
    - 페이징 기법이든 세그먼테이션 기법이든 매핑 테이블에 이러한 메모리 접근 권한에 대한 정보를 가지고 있으며, 이를 통해 주소 변환이 발생할 때 마다 유효한 접근인지 아닌지 검사한다.



- 세그먼테이션-페이징 혼용 기법

  - 페이지 테이블에 메모리 접근 권한에 대한 정보를 추가하기 위해서는 추가적인 bit가 필요하다.
    - 페이지 테이블에서 메모리 접근 권한을 나타내는 비트를 권한 비트(right bit)라고 부르며, 메모리 관리자는 주소 변환이 발생하면 권한 비트를 이용하여 유효한 접근인지 여부를 확인한다.
    - 문제는 페이지 테이블에 권한 비트가 추가되면 페이지 테이블의 크기가 그 만큼 커진다는 것이다.
    - 인접한 페이지의 메모리 접근 권한은 같은 경우가 많은데도 불구하고 페이지마다 권한 비트를 설정하기 때문에, 메모리가 낭비된다.
    - 이러한 문제를 완화하기 위해서는 권한 비트를 줄일 필요가 있다.

  | 권한 비트 | 권한 비트 | 권한 비트 | 프레임 번호 |
  | --------- | --------- | --------- | ----------- |
  |           |           |           | 2           |
  |           |           |           | 3           |
  |           |           |           | 1           |

  - 세그먼테이션 테이블을 사용하면 권한 비트 추가에 따라 페이지 테이블의 크기가 커지는 문제를 완화할 수 있다.
    - 페이지로 분할된 가상 주소 공간에서 서로 관련있고, 같은 메모리 접근 권한을 가진 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리하고 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식이다.
    - 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.
    - 권한 비트와 같이 중복되는 데이터를 세그먼테이션 테이블로 옮겨 관리함으로써 페이지 테이블의 크기를 줄일 수 있다.
  - 아래와 같이 세그먼테이션 테이블을 구성한다.

  | 권한 비트 | 권한 비트 | 권한 비트 | 권한 비트 | 페이지 테이블의 시작 주소 |
  | --------- | --------- | --------- | --------- | ------------------------- |
  |           |           |           |           | 180                       |
  |           |           |           |           | 200                       |
  |           |           |           |           | 300                       |

  - 세그먼테이션-페이징 혼합 깁법을 사용함에 따라 줄어드는 데이터에는 권한 비트만 있는 것이 아니다.
    - 유닉스 계열의 운영체제에서 사용하는 소유 권한과 접근 권한 등도 세그먼테이션 테이블에서 관리하여 추가되는 데이터의 양을 줄인다.







# 가상 메모리 관리

- 요구 페이징(Demand Paging)
  - 가져오기 정책
    - 프로세스는 전부 메모리에 올라가지 않고 필요한 부분만 메모리에 올라가서 실행된다.
    - 이를 통해 메모리 절약, 메모리의 효율저 관리, 프로세스의 응답 속도 향상 등의 효과를 볼 수 있다.
    - 다만, 이로 인해 프로세스가 필요로 하는 데이터를 언제 가져올지가 문제가 된다.
    - 프로세스가 필요로 하는 데이터를 언제 메모리를 가져올지를 결정하는 정책을 가져오기 정책이라 부른다.
  - 가장 일반적인 가져오기 정책은 프로세스가 요청할 때 메모리로 가져오는 정책으로, 이를 요구 페이징이라한다.



- 페이지 테이블 엔트리의 구조

  - 가상 메모리 시스템에서 프로세스는 물리 메모리와 스왑 영역 중 한 곳에 있다.
    - 이 때 페이지가 스왑 영역에 있는 경우는 크게 두 가지로, 하나는 요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못한 경우이고, 다른 하나는 물리 메모리가 꽉 차서 스왑 영역으로 옮겨 온 경우이다.
    - 페이지 테이블에는 각 페이지가 물리 메모리와 스왑 영역 중 어디에 위치해 있는지를 표시해야 하는데 이때 사용하는 비트가 유효비트이다.
  - 페이지 테이블의 한 행을 의미하는 페이지 테이블 엔트리(PTE)는 아래와 같이 구성된다.

  | (페이지 번호) | access bit | modified bit | valid bit | read | write | excute | 프레임 번호 |
  | ------------- | ---------- | ------------ | --------- | ---- | ----- | ------ | ----------- |

  - 페이지 번호
    - 주소 변환 방식 중 직접 매핑 방식에서는 페이지 번호가 필요 없다.
    - 그러나 연관 매핑에서는 페이지 번호도 필요하다.
    - 이처럼 페이지 번호는 매핑 방식에 따라 PTE에 포함되기도하고 되지 않기도 한다.
  - 프레임 번호
    - 가상 주소의 해당 페이지가 어느 프레임에 있는지를 알려주는 자료 구조로, 페이지 테이블의 핵심이다.
    - 메모리 관리자는 프레임 번호를 기반으로 가상 주소를 물리 주소로 변환한다.
    - 프레임 번호는 주소 필드라고도 한다.
  - 접근 비트(참조 비트)
    - 페이지가 메모리에 올라온 후 사용한 적이 있는지를 나타내는 비트이다.
    - 해당 메모리에 읽기나 실행 작업을 했다면 접근 비트가 1이 된다.
  - 변경 비트(더티 비트)
    - 페이지가 메모리에 올라온 후 데이타의 변경이 있었는지 알려주는 비트이다.
    - 해당 메모리에 쓰기나 추가 작업을 했다면 변경 비트가 1이 된다.
  - 유효 비트(현재 비트)
    - 페이지가 물리 메모리에 있는지를 나타내는 비트이다.
    - 유효 비트가 0이면 페이지가 물리 메모리에 있다는 의미이다.
  - 읽기, 쓰기, 실행 비트
    - 페이지에 대한 읽기, 쓰기, 실행 권한을 나타내는 비트이다.
    - 이 세 비트를 합쳐서 권한 비트라고도 부른다.



- 페이지 부재(Page Fault)
  - 유효 비트의 값에 따라 주소 필드(프레임 번호)의 값이 달라진다.
    - 유효 비트가 0일 경우 페이지가 물리 메모리에 있다는 의미이므로 주소 필드에는 물리 메모리의 프레임 번호가 저장된다.
    - 반면 1일 경우 페이지가 스왑 영역에 있다는 의미이므로 주소 필드에 스왑 영역 내 페이지의 주소가 저장된다.
  - 프로세스가 특정 페이지를 요청했을 때 해당 페이지가 물리 메모리에 없는 상황을 페이지 부재라고 한다.
    - 페이지 부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야한다.
    - 페이지 부재가 발생할 경우 메모리 관리자는 스왑 영역에 있는 페이지를 메모리에 비어 있는 프레임으로 가져온다(스왑 인).
    - 그 후 해당 페이지에 해당하는 PTE 유효 비트 값을 0으로, 주소 필드 값을 스왑 영역의 주소에서 물리 메모리의 프레임 번호로 변경한다.
  - 페이지 교체 알고리즘(Page Replacement Algorithm)
    - 페이지 부재가 발생했을 때, 빈 프레임이 있다면 빈 프레임으로 페이지를 가져오면 되지만, 빈 프레임이 없을 경우 기존에 물리 메모리에 있던 페이지를 스왑 영역으로 보내 빈 프레임을 만들어야한다.
    - 이 때 어떤 페이지를 스왑 아웃할지를 정하는 알고리즘을 페이지 교체 알고리즘이라 한다.
    - 그리고 페이지 교체 알고리즘에 의해 스왑 아웃 될 페이지를 대상 페이지(victim page)라고 한다.



- 지역성(Locality)
  - 지역성은 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질을 말한다.
    - 메모리가 꽉 차서 페이지를 스왑 아웃해야 할 때는 되도록 앞으로 사용하지 않을 페이지를 선택하는 것이 좋다.
    - 자주 사용될 페이지를 스왑 아웃 할 경우 사용할 때 물리 메모리로 다시 가져와야 하므로 프로세스의 성능이 떨어질 수 있다.
    - 이 때 어떤 메모리가 앞으로 사용되지 않을지를 판단할 때 근거로 사용하는 것이 바로 지역성이다.
  - 공간의 지역성(Spartial Locality)
    - 최근에 접근한 데이터에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높다는 것이다.
  - 시간의 지역성(Temporal Locality)
    - 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다는 것이다.
  - 순차적 지역성(Sequential Locality)
    - 여러 작업이 순차적으로 진행되는 경향이 있다는 것을 의미한다.
    - 순차적 지역성은 공간의 지역성의 일부로 구분되기도 한다.





## 페이지 교체 알고리즘

- 페이지 교체 알고리즘(Page Replacement Algorithm)

  - 페이지 교체 알고리즘 개요
    - 페이지 부재가 발생했을 때, 빈 프레임이 있다면 빈 프레임으로 페이지를 가져오면 되지만, 빈 프레임이 없을 경우 기존에 물리 메모리에 있던 페이지를 스왑 영역으로 보내 빈 프레임을 만들어야한다.
    - 이 때 어떤 페이지를 스왑 아웃할지를 정하는 알고리즘을 페이지 교체 알고리즘이라 한다.
    - 그리고 페이지 교체 알고리즘에 의해 스왑 아웃 될 페이지를 대상 페이지(victim page)라고 한다.
  - 페이지 교체 알고리즘의 종류

  | 종류               | 알고리즘  | 특징                                                    |
  | ------------------ | --------- | ------------------------------------------------------- |
  | 간단한 알고리즘    | 무작위    | 무장위로 대상 페이지를 선정한다.                        |
  |                    | FIFO      | 메모리에 올라온 순서대로 대상 페이지를 선정한다.        |
  | 이론적 알고리즘    | 최적      | 미래의 접근 패턴을 보고 대상 페이지를 선정한다.         |
  | 최적 근접 알고리즘 | LRU       | 시간적으로 멀리 떨어진 페이지를 대상 페이지로 선정한다. |
  |                    | LFU       | 사용 빈도가 적은 페이지를 대상 페이지로 선정한다.       |
  |                    | NUR       | 최근에 사용한 적 없는 페이지를 대상 페이지로 선정한다.  |
  |                    | FIFO 변형 | FIFO 알고리즘 보다 성능을 높인 변형 알고리즘            |

  - 페이지 교체 알고리즘의 성능 평가 기준
    - 페이지 알고리즘의 목표는 페이지 부재율을 최소화하는 것이다.
    - 따라서 당연히 페이지 부재 횟수와 페이지 성공 횟수가 평가 기준에 들어간다.
    - 또한 대상 페이지 선정 작업에 걸리는 시간이나, 차지하는 메모리 등도 평가 기준이 될 수 있다.
  - 아래 표는 앞으로 각 페이지 교체 알고리즘을 살펴볼 때 공통으로 사용할 메모리 접근 순서이다.

  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | A    | B    | C    | D    | B    | A    | B    | A    | C    | A    |



