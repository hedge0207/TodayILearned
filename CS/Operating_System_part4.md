# 가상 메모리 기초

- 가상 메모리(Virtial Memory)

  - 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다.
    - 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다.
    - 이러한 메모리 시스템을 가상 메모리라고 부란다.
    - 가상 메모리는 물리 메모리의 크기와 상관없이 프로게스에 커다란 메모리 공간을 제공하는 기술이다.
    - 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경쓰지 않고 메모리를 마음대로 사용할 수 있다.
  - 가상 메모리가 필요한 이유
    - 메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 2GB의 메모리에서 동작하는 프로그램이 1GB의 메모리에서는 동작하지 않을 수 있다,
    - 또한 물리 메모리만을 사용해야 한다면 프로그래머 또한 메모리 크기에 맞는 응용프로그램만을 개발해야 하는데, 실제로 메모리 크기를 고려하여 프로그래밍하기란 매우 어렵다.
  - 가상 메모리의 크기와 주소
    - 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지와 무관하게 0번지부터 시작하는 연속된 메모리 공간을 가진다.
    - 논리 주소와 유사하지만 한 가지 차이점이 있는데, 논리 주소는 물리 메모리의 주소 공간에 비례하고, 가상 주소는 물리 메모리 공간이 아닌 가상의 주소 공간을 가진다는 것이다.
    - 가상 메모리는 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉜다.
    - 이론적으로 가상 메모리는 무한대의 크기이나, 실제로 가상 메모리의 최대 크기는 물리 메모리의 최대 크기로 한정되며, CPU의 비트에 따라 결정된다.
    - 32bit CPU의 경우 32bit로 표현할 수 있는 최대값인 2<sup>32</sup>-1(16진수로 FFFFFFFF)으로 약 4GB가 메모리의 최대 크기이고, 가상 메모리의 최대 크기도 약 4GB이다.
  - Swap In과 Swap Out
    - 32bit CPU의 최대 메모리 크기는 4GB이며, 이 시스템에서 각 4GB 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면 운영체제를 포함하여 적어도 40GB의 메모리가 필요하다.
    - 이 경우 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮긴다.
    - 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로, 메모리의 일부이며, 가상 메모리의 구성 영역 중 하나다.
    - 메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충한다.
    - 즉 물리 메모리가 꽉 찼을 때 일부 프로세스를 스왑 영역으로 보내고(swap out), 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져온다(swap in).
    - 가상 메모리 시스템에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리와 스왑 영역을 합한 크기이다.
  - 동적 주소 변환(Dynamic Address Translation, DAT)
    - 앞서 말했듯 가상 메모리는 실제로 상요할 수 있는 최대 크기가 제한되어 있음에도 이론적으로 무한대의 크기가 있는 것 처럼 구현할 수 있다.
    - 이는 동적 주소 변환이라 불리는 작업을 통해 가능하다.
    - 가상 메모리 시스템에서 메모리 관리자가 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데 이러한 작업을 동적 주소 변환이라고한다.
    - 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 데이터를 물리 메모리에 배치할 수 있다.
    - 이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, 부족한 물리 메모리를 어떻게 처리할지 등의 문제들을 처리한다.
  - 가상 메모리의 메모리 분할 방식
    - 실제 메모리에 있는 물리 주소 0번지는 운영체제 영역이므로 일반 프로세스가 사용할 수 없다.
    - 따라서 가상 메모리 시스템에서는 운영체제를 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당한다.
    - 물리 메모리 분할 방식은 크게 가변 분할 방식과 고정 분할 방식으로 나뉘는데, 가상 메모리 시스템도 마찬가지이다.
    - 가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법은 세그먼테이션, 고정 분할 방식을 이용한 메모리 관리 기법은 페이징이라 한다.
    - 이 중 세그먼테이션은 가변 분할 방식의 단점인 외부 단편화 등의 문제 때문에 잘 사용되지 않는다.
    - 또한 페이징 기법은 페이지 관리에 어려움이 있다.
    - 따라서 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

  - 매핑 테이블
    - 가상 메모리 시스템에서 가상 주소와 물리 주소를 매핑하는 테이블이다.
    - 가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치하며, 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리한다.





## 페이징 기법

- 페이징 기법

  - 고정 분할 방식으로 가상 메모리를 분할하여 관리하는 기법이다.
  - 페이징 기법의 구현
    - 가상 주소의 분할된 각 영역은 페이지라고 부르며, 첫 번째 영역은 페이지0, 두 번째 영역은 페이지1과 같이 번호를 매겨 관리한다.
    - 물리 주소 공간을 같은 크기로 나누어 사용하며, 물리 메모리의 각 영역은 프레임이라고 부르고, 페이지와 마찬가지로 번호를 매겨 관리한다.
    - 페이지와 프레임의 크기는 같다.
    - 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다.
  - 페이지 테이블
    - 어떤 페이지가 어떤 프레임에 있는지에 대한 매핑 정보는 페이지 테이블에서 관리된다.
    - 페이지 테이블은 하나의 열로 구성된다.
    - 모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터 차례대로 페이지0, 페이지1, 페이지2, ...가 위치해 있는 프레임 번호를 가지고 있어, 페이지 번호를 나타내는 열은 필요가 없다.
    - 단, 페이지 번호가 순서대로 저장되지 않은 경우 페이지 번호를 표시하기도 한다.
    - 페이지 테이블에 숫자만 있는 것은 아니며, 물리 메모리가 아닌 스왑 영역에 있을 경우 invalid라고 표시된다.
    - 예를 들어 아래 페이지 테이블을 통해 페이지 0은 2번 프레임에, 페이지 1번은 1번 프레임에 위치해 있으며 페이지 5번은 스왑 영역에 위치해 있다는 것을 알 수 있다.
    - 페이지 테이블은 페이지 번호(열로 표현되지는 않는다), 프레임 번호로 구성되며, 각가의 줄은 페이지 테이블 엔트리(Page Table Entry, PTE)라 부른다. 
  
  | 프레임  |
  | ------- |
  | 2       |
  | 1       |
  | 3       |
  | 4       |
  | 0       |
  | invalid |



- 페이징 기법의 주소 변환

  - 주소 변환 과정
    - 가상 주소 공간과 물리 주소 공간을 똑같이 10B로 나누었다고 가정하자.
    - 1byte로 하나의 주소를 표현할 수 있으므로 한 페이지 혹은 한 프레임은 총 10개의 주소를 가진다.
    - 즉 페이지 0번에는 0~9번지의 10개 주소가, 페이지 1에는 10~19번지의 10개 주소가 있으며 물리 주소 공간도 마찬가지로 각 프레임에 10개의 주소가 있다.
    - 이 때 프로세스가 27번지의 내용을 읽으려고 할 때 주소 변환 과정은 아래와 같다.
    - 가상 주소 20번지가 어느 페이지에 있는지 확인한다.
    - 가상 주소 20번지는 페이지 2의 0번째에 위치해있다.
    - 페이지 테이블의 페이지 2로 가서 해당 페이지가 어떤 프레임과 매핑되어 있는지 확인한다.
    - 아레 페이지 테이블을 보면 페이지2는 프레임4와 매핑되어 있는 것을 확인할 수 있다.
    - 최종적으로 물리 메모리 프레임4의 0번째 위치에 접근한다.

  | 프레임  |
  | ------- |
  | 2       |
  | 3       |
  | 4       |
  | 1       |
  | 0       |
  | invalid |

  - 정형화된 주소 변환
    - 위의 주소 변환 과정을 정형화하면 아래와 같다.
    - 가상 주소는 `VA=<P,D>`와 같이 표현할 수 있다.
    - 여기서 VA(Virtual Address)는 가상 주소, P(Page)는 페이지, D(Distance)는 페이지의 처음 위치해서 해당 주소까지의 거리를 의미하며, D는 오프셋이라 부르기도 한다.
    - 가상 주소 20번지를 위 방식으로 정의하면 VA=<2, 0>으로 작성할 수 있다.
    - 물리 주소는 `PA=<F, D>`와 같이 표현할 수 있다.
    - PA(Physical Address)는 물리 주소, F(Frame)는 프레임, D(Distance)는 프레임의 처음 위치에서 해당 주소까지의 거리를 의미한다.
    - VA=<2,0>이 PA=<4,0>으로 변환되었다는 것은 가상 주소 20번지가 물리 주소 프레임 1의 0번 위치로 변환되었다는 의미이다.
    - 결론적으로 페이징 기법의 주소 변환은 아래와 같이 정형화할 수 있다.
    - `VA=<P, D> → PD<F, D>` 



- 16bit CPU를 사용할 경우 주소 변환 예시
  - 컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승으로 분할된다.
    - 위 예시에서는 편의를 위해 10B로 분할했으나, 실제 컴퓨터는 그렇게 동작하지 않는다.
    - 예를 들어 VAX라는 운영체제는 한 페이지의 크기가 2<sup>9</sup>byte이고, Windows는 2<sup>12</sup>byte이다.
  - 페이지의 크기가 다양할 경우 특정 가상 주소를 <P, D>로 변환하는 공식은 아래와 같다.
    - P = (가상 주소/한 페이지의 크기)의 몫, D = (가상 주소 / 한 페이지의 크기)의 나머지
    - 예를 들면 한 페이지의 크기가 512byte인 시스템에서 가상 주소 2049번지의 P는 2049/512의 몫인 4, D는 나머지인 1이다.
  -  16bit CPU의 컴퓨터에서 한 페이지의 크기가 2<sup>10</sup>bytes일 때 페이징 시스템의 구성은 아래와 같다.
    - 16bit CPU의 컴퓨터에서 한 프로세스가 사용할 수 있는 가상 메모리의 크기는 2<sup>16</sup>bytes이다.
    - 사용자는 0번지부터 65535(2<sup>16</sup>-1)번지까지 가상 주소 공간을 사용할 수 있다.
    - 한 페이지의 크기가 2<sup>10</sup>bytes이기 때문에 가상 주소로 활용할 수 있는 16bit중 6bit는 페이지 번호로, 10bit는 페이지의 처음 위치에서 해당 주소까지의 거리로 사용한다.
    - 만약 한 페이지의 크기가 2<sup>11</sup>bytes라면 16bit중 5bit는 페이지 번호로, 11bit는 패아지의 처음 위치에서 해당 주소까지 거리로 사용한다.
    - 한 페이지의 크기가 2<sup>10</sup>bytes일 경우 가상 주소 VA=<P, D>에서 P는 6bit, D는 10bit이다.
    - 이는 시스템 페이지가 0~63(2<sup>6</sup>-1)로 총 64개이고, 페이지 하나가 0~1023(2<sup>10</sup>-1)로 총 1024개 번지로 구성되어 있다는 의미이다.
    - 결국 페이지 0은 0~1023번지, 페이지 1은 1024~2047번지, ..., 페이지 63은 64512~65535번지로 구성된다.
    - 물리 주소도 가상 주소와 마찬가지로 1024bytes로 나눈다.
    - 가상 주소의 각 페이지가 어떤 프레임에 있는지는 페이지 테이블을 보면 알 수 있으며, 페이지 테이블의 크기는 물리 주소의 크기가 아니라 프로세스의 크기에 비례한다.
    - 물리 주소의 크기와 상관 없이 가상 주소를 많이 사용하면 페이지 테이블의 크기가 늘어나고, 적게 사용하면 페이지 테이블의 크기가 줄어든다.
  - 프로세스가 980번지에 저장된 데이터를 요청했을 때 가상 주소가 물리 주소로 변환되는 과정은 아래와 같다.
    - 가상 주소 980번지의 페이지 P와 거리 D를 구한다.
    - P는 (980/1024)의 몫, D는 (980/1024)의 나머지 이므로 VA=<0, 980>이다.
    - 페이지 테이블을 확인하여 페이지 0이 어떤 프레임과 매핑되어 있는지 확인한다(프레임 2번과 매핑되어 있다고 가정).
    - 프레임 2번의 시작 지점으로부터 980번지 떨어진 곳에 접근하여 데이터를 가져온다.



- 페이지 테이블 관리

