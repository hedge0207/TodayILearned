# 가상 메모리 기초

- 가상 메모리(Virtial Memory)

  - 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다.
    - 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다.
    - 이러한 메모리 시스템을 가상 메모리라고 부란다.
    - 가상 메모리는 물리 메모리의 크기와 상관없이 프로게스에 커다란 메모리 공간을 제공하는 기술이다.
    - 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경쓰지 않고 메모리를 마음대로 사용할 수 있다.
  - 가상 메모리가 필요한 이유
    - 메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 2GB의 메모리에서 동작하는 프로그램이 1GB의 메모리에서는 동작하지 않을 수 있다,
    - 또한 물리 메모리만을 사용해야 한다면 프로그래머 또한 메모리 크기에 맞는 응용프로그램만을 개발해야 하는데, 실제로 메모리 크기를 고려하여 프로그래밍하기란 매우 어렵다.
  - 가상 메모리의 크기와 주소
    - 가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지와 무관하게 0번지부터 시작하는 연속된 메모리 공간을 가진다.
    - 논리 주소와 유사하지만 한 가지 차이점이 있는데, 논리 주소는 물리 메모리의 주소 공간에 비례하고, 가상 주소는 물리 메모리 공간이 아닌 가상의 주소 공간을 가진다는 것이다.
    - 가상 메모리는 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉜다.
    - 이론적으로 가상 메모리는 무한대의 크기이나, 실제로 가상 메모리의 최대 크기는 물리 메모리의 최대 크기로 한정되며, CPU의 비트에 따라 결정된다.
    - 32bit CPU의 경우 32bit로 표현할 수 있는 최대값인 2<sup>32</sup>-1(16진수로 FFFFFFFF)으로 약 4GB가 메모리의 최대 크기이고, 가상 메모리의 최대 크기도 약 4GB이다.
  - Swap In과 Swap Out
    - 32bit CPU의 최대 메모리 크기는 4GB이며, 이 시스템에서 각 4GB 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면 운영체제를 포함하여 적어도 40GB의 메모리가 필요하다.
    - 이 경우 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮긴다.
    - 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로, 메모리의 일부이며, 가상 메모리의 구성 영역 중 하나다.
    - 메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충한다.
    - 즉 물리 메모리가 꽉 찼을 때 일부 프로세스를 스왑 영역으로 보내고(swap out), 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져온다(swap in).
    - 가상 메모리 시스템에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리와 스왑 영역을 합한 크기이다.
  - 동적 주소 변환(Dynamic Address Translation, DAT)
    - 앞서 말했듯 가상 메모리는 실제로 상요할 수 있는 최대 크기가 제한되어 있음에도 이론적으로 무한대의 크기가 있는 것 처럼 구현할 수 있다.
    - 이는 동적 주소 변환이라 불리는 작업을 통해 가능하다.
    - 가상 메모리 시스템에서 메모리 관리자가 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데 이러한 작업을 동적 주소 변환이라고한다.
    - 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 데이터를 물리 메모리에 배치할 수 있다.
    - 이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, 부족한 물리 메모리를 어떻게 처리할지 등의 문제들을 처리한다.
  - 가상 메모리의 메모리 분할 방식
    - 실제 메모리에 있는 물리 주소 0번지는 운영체제 영역이므로 일반 프로세스가 사용할 수 없다.
    - 따라서 가상 메모리 시스템에서는 운영체제를 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당한다.
    - 물리 메모리 분할 방식은 크게 가변 분할 방식과 고정 분할 방식으로 나뉘는데, 가상 메모리 시스템도 마찬가지이다.
    - 가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법은 세그먼테이션, 고정 분할 방식을 이용한 메모리 관리 기법은 페이징이라 한다.
    - 이 중 세그먼테이션은 가변 분할 방식의 단점인 외부 단편화 등의 문제 때문에 잘 사용되지 않는다.
    - 또한 페이징 기법은 페이지 관리에 어려움이 있다.
    - 따라서 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

  - 매핑 테이블
    - 가상 메모리 시스템에서 가상 주소와 물리 주소를 매핑하는 테이블이다.
    - 가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치하며, 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리한다.





## 페이징 기법

- 페이징 기법

  - 고정 분할 방식으로 가상 메모리를 분할하여 관리하는 기법이다.
  - 페이징 기법의 구현
    - 가상 주소의 분할된 각 영역은 페이지라고 부르며, 첫 번째 영역은 페이지0, 두 번째 영역은 페이지1과 같이 번호를 매겨 관리한다.
    - 물리 주소 공간을 같은 크기로 나누어 사용하며, 물리 메모리의 각 영역은 프레임이라고 부르고, 페이지와 마찬가지로 번호를 매겨 관리한다.
    - 페이지와 프레임의 크기는 같다.
    - 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다.
  - 페이지 테이블
    - 어떤 페이지가 어떤 프레임에 있는지에 대한 매핑 정보는 페이지 테이블에서 관리된다.
    - 페이지 테이블은 하나의 열로 구성된다.
    - 모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터 차례대로 페이지0, 페이지1, 페이지2, ...가 위치해 있는 프레임 번호를 가지고 있어, 페이지 번호를 나타내는 열은 필요가 없다.
    - 단, 페이지 번호가 순서대로 저장되지 않은 경우 페이지 번호를 표시하기도 한다.
    - 페이지 테이블에 숫자만 있는 것은 아니며, 물리 메모리가 아닌 스왑 영역에 있을 경우 invalid라고 표시된다.
    - 예를 들어 아래 페이지 테이블을 통해 페이지 0은 2번 프레임에, 페이지 1번은 1번 프레임에 위치해 있으며 페이지 5번은 스왑 영역에 위치해 있다는 것을 알 수 있다.
    - 페이지 테이블은 페이지 번호(열로 표현되지는 않는다), 프레임 번호로 구성되며, 각가의 줄은 페이지 테이블 엔트리(Page Table Entry, PTE)라 부른다. 
  
  | 프레임  |
  | ------- |
  | 2       |
  | 1       |
  | 3       |
  | 4       |
  | 0       |
  | invalid |



- 페이징 기법의 주소 변환

  - 주소 변환 과정
    - 가상 주소 공간과 물리 주소 공간을 똑같이 10B로 나누었다고 가정하자.
    - 1byte로 하나의 주소를 표현할 수 있으므로 한 페이지 혹은 한 프레임은 총 10개의 주소를 가진다.
    - 즉 페이지 0번에는 0~9번지의 10개 주소가, 페이지 1에는 10~19번지의 10개 주소가 있으며 물리 주소 공간도 마찬가지로 각 프레임에 10개의 주소가 있다.
    - 이 때 프로세스가 27번지의 내용을 읽으려고 할 때 주소 변환 과정은 아래와 같다.
    - 가상 주소 20번지가 어느 페이지에 있는지 확인한다.
    - 가상 주소 20번지는 페이지 2의 0번째에 위치해있다.
    - 페이지 테이블의 페이지 2로 가서 해당 페이지가 어떤 프레임과 매핑되어 있는지 확인한다.
    - 아레 페이지 테이블을 보면 페이지2는 프레임4와 매핑되어 있는 것을 확인할 수 있다.
    - 최종적으로 물리 메모리 프레임4의 0번째 위치에 접근한다.

  | 프레임  |
  | ------- |
  | 2       |
  | 3       |
  | 4       |
  | 1       |
  | 0       |
  | invalid |

  - 정형화된 주소 변환
    - 위의 주소 변환 과정을 정형화하면 아래와 같다.
    - 가상 주소는 `VA=<P,D>`와 같이 표현할 수 있다.
    - 여기서 VA(Virtual Address)는 가상 주소, P(Page)는 페이지, D(Distance)는 페이지의 처음 위치해서 해당 주소까지의 거리를 의미하며, D는 오프셋이라 부르기도 한다.
    - 가상 주소 20번지를 위 방식으로 정의하면 VA=<2, 0>으로 작성할 수 있다.
    - 물리 주소는 `PA=<F, D>`와 같이 표현할 수 있다.
    - PA(Physical Address)는 물리 주소, F(Frame)는 프레임, D(Distance)는 프레임의 처음 위치에서 해당 주소까지의 거리를 의미한다.
    - VA=<2,0>이 PA=<4,0>으로 변환되었다는 것은 가상 주소 20번지가 물리 주소 프레임 1의 0번 위치로 변환되었다는 의미이다.
    - 결론적으로 페이징 기법의 주소 변환은 아래와 같이 정형화할 수 있다.
    - `VA=<P, D> → PD<F, D>` 



- 16bit CPU를 사용할 경우 주소 변환 예시
  - 컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승으로 분할된다.
    - 위 예시에서는 편의를 위해 10B로 분할했으나, 실제 컴퓨터는 그렇게 동작하지 않는다.
    - 예를 들어 VAX라는 운영체제는 한 페이지의 크기가 2<sup>9</sup>byte이고, Windows는 2<sup>12</sup>byte이다.
  - 페이지의 크기가 다양할 경우 특정 가상 주소를 <P, D>로 변환하는 공식은 아래와 같다.
    - P = (가상 주소/한 페이지의 크기)의 몫, D = (가상 주소 / 한 페이지의 크기)의 나머지
    - 예를 들면 한 페이지의 크기가 512byte인 시스템에서 가상 주소 2049번지의 P는 2049/512의 몫인 4, D는 나머지인 1이다.
  -  16bit CPU의 컴퓨터에서 한 페이지의 크기가 2<sup>10</sup>bytes일 때 페이징 시스템의 구성은 아래와 같다.
    - 16bit CPU의 컴퓨터에서 한 프로세스가 사용할 수 있는 가상 메모리의 크기는 2<sup>16</sup>bytes이다.
    - 사용자는 0번지부터 65535(2<sup>16</sup>-1)번지까지 가상 주소 공간을 사용할 수 있다.
    - 한 페이지의 크기가 2<sup>10</sup>bytes이기 때문에 가상 주소로 활용할 수 있는 16bit중 6bit는 페이지 번호로, 10bit는 페이지의 처음 위치에서 해당 주소까지의 거리로 사용한다.
    - 만약 한 페이지의 크기가 2<sup>11</sup>bytes라면 16bit중 5bit는 페이지 번호로, 11bit는 패아지의 처음 위치에서 해당 주소까지 거리로 사용한다.
    - 한 페이지의 크기가 2<sup>10</sup>bytes일 경우 가상 주소 VA=<P, D>에서 P는 6bit, D는 10bit이다.
    - 이는 시스템 페이지가 0~63(2<sup>6</sup>-1)로 총 64개이고, 페이지 하나가 0~1023(2<sup>10</sup>-1)로 총 1024개 번지로 구성되어 있다는 의미이다.
    - 결국 페이지 0은 0~1023번지, 페이지 1은 1024~2047번지, ..., 페이지 63은 64512~65535번지로 구성된다.
    - 물리 주소도 가상 주소와 마찬가지로 1024bytes로 나눈다.
    - 가상 주소의 각 페이지가 어떤 프레임에 있는지는 페이지 테이블을 보면 알 수 있으며, 페이지 테이블의 크기는 물리 주소의 크기가 아니라 프로세스의 크기에 비례한다.
    - 물리 주소의 크기와 상관 없이 가상 주소를 많이 사용하면 페이지 테이블의 크기가 늘어나고, 적게 사용하면 페이지 테이블의 크기가 줄어든다.
  - 프로세스가 980번지에 저장된 데이터를 요청했을 때 가상 주소가 물리 주소로 변환되는 과정은 아래와 같다.
    - 가상 주소 980번지의 페이지 P와 거리 D를 구한다.
    - P는 (980/1024)의 몫, D는 (980/1024)의 나머지 이므로 VA=<0, 980>이다.
    - 페이지 테이블을 확인하여 페이지 0이 어떤 프레임과 매핑되어 있는지 확인한다(프레임 2번과 매핑되어 있다고 가정).
    - 프레임 2번의 시작 지점으로부터 980번지 떨어진 곳에 접근하여 데이터를 가져온다.



- 페이지 테이블 관리
  - 페이지 테이블 관리가 복잡한 이유
    - 시스템에는 하나의 프로세스만 있는 것이 아니라 여러 개의 프로세스가 존재하는데, 각 프로세스마다 페이지 테이블이 하나씩 있기 때문이다.
    - 예를 들어 프로세스 A, B, C가 있고, 각각의 프로세스는 하나의 물리 메모리를 사용하고 있는 상황이라고 가정해보자.
    - 프로세스는 메모리에 올라와야 실행 가능하므로 모든 프로세스의 일부 페이지가 물리 메모리의 프레임에 올라와 있고, 어떤 페이지가 어떤 프레임에 있는지 관리하기 위해 프로세스마다 페이지 테이블을 운영해야한다.
    - 메모리 관리자는 특정 프로세스가 실행될 때마다 각 프로세스의 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 작업을 반복한다.
  - 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓는다.
    - 페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빨리 접근할 수 있어야하기 때문이다.
    - 한 곳에 몰아 놓는다면 더 빨리 접근할 수 있게된다.
  - 페이지 테이블 관리의 가장 큰 문제는 페이지 테이블의 크기가 작지 않다는 것이다.
    - 시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다.
    - 한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.
    - 32bit CPU를 가지는 시스템이 있다고 가정할 때, 이 시스템이 가질 수 있는 물리 메모리의 최대 크기는 4GB이다.
    - 이 때, 페이징 시스템이 한 페이지의 크기를 512B로 관리한다면, 이 시스템에서 하나의 페이지 테이블의 최대 크기는 약 24.11MB이다.
    - 이 24.11MB는 페이지 테이블 하나의 크기이며, 만약 프로세스가 40개라면 페이지 테이블의 최대 크기는 1GB에 달하게 된다.
    - 이는 시스템에서 사용 가능한 물리 메모리 4GB의 25%에 해당하는 양이다.
    - 따라서 페이지 테이블의 크기를 적절하게 유지하는 것은 페이지 테이블 관리의 핵심이다.
  - Page Table Base Register(PTBR)
    - 각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 물리 메모리 상에서 페이지 테이블의 위치를 빠르게 파악할 필요가 있다.
    - 따라서 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터(PTBR)라는 곳에 보관한다.
    - PTBR은 각 프로세스 제어 블록에 저장된다.



- 페이지 테이블 매핑 방식

  - 물리 메모리 영역이 부족할 경우 프로세스만 스왑 영역으로 옮겨지는 것이 아니라 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.
    - 메모리 상에서 페이지 테이블의 크기가 늘어나면 페이지 테이블이 저장되는 운영체제 영역이 늘어나 그만큼 사용자 영역이 줄어든다.
    - 물리 메모리 영역이 부족할 경우 페이지 테이블의 일부도 스왑 영역으로 옮겨진다.
    - 따라서 페이지 테이블 전체를 메모리에서 관리하느냐, 일부를 스왑 영역에서 관리하느냐에 따라 가상 주소를 물리 주소에서 관리하느냐에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라지게 된다.
  - 직접 매핑(Direct Mapping)
    - 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식이다.
    - 별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라 부른다.
    - 모든 페이지 테이블을 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠르다.
  - 연관 매핑(Associative Mapping)
    - 페이지 테이블 전체를 스왑 영역에서 관리하는 방식이다.
    - 물리 메모리의 여유 공간이 작을 때 사용하는 방식으로, 모든 페이지 테이블을 저장 장치의 스왑 영역에 저장하고 그중 일부만 무작위로 물리 메모리에 가지고 있는다.
    - 물리 메모리에 가지고 있는 일부 페이지 테이블을 변환 색인 버퍼(Translation Look-aside Buffer, TLB) 혹은 연관 레지스터(associate register)라고 부른다.
    - 이 방식에서 메모리에 접근하기 위해 먼저 변환 색인 버퍼를 찾아보는데, 원하는 페이지 번호가 있을 경우 TLB hit라 하며 바로 물리 주소로 변환된다.
    - 반대로 없을 경우 TLB miss라고 하며, 스왑 영역에 저장된 페이지 테이블을 사용하여 주소를 변환한다.
    - 일부 내용만 무작위로 배치하기 때문에 페이지의 번호가 연속적이지 않아 어떤 페이지를 가져왔는지 알 수 없으므로, 테이블의 열은 페이지 번호와 프레임 번호 둘 다 표시한다.
    - 따라서 연관 매핑의 경우 페이지 테이블의 열은 2개가 된다.

  | 페이지 | 프레임 |
  | ------ | ------ |
  | 0      | 1      |
  | 4      | 0      |
  | 5      | 5      |
  | 11     | 4      |
  | 16     | 9      |

  - 집합-연관 매핑(Set-Associative Mapping)
    - 연관 매핑에서는 일부 데이터만 무작위로 물리 메모리로 가져오기 때문에 원하는 프레임 번호를 얻기 위해 TLB 전체를 검색해야하는 문제가 있다.
    - 집합-연관 매핑은 연관 매핑의 이러한 문제를 개선한 방식이다.
    - 모든 페이지 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져온다는 것은 연관 매핑과 동일하다.
    - 그러나 집합-연관 매핑에서는 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.
    - 페이지의 번호가 연속적이므로 페이지 번호를 표시하지 않아도 되어 테이블의 열은 프레임 번호만 표시한다.
    - 페이지 테이블의 페이지들을 일정 개수씩 묶은 집합 테이블을 생성하고, 집합 테이블에 어떤 페이지 집합이 스왑 영역에 있고, 어떤 페이지 집합이 물리 메모리에 있는지를 표기한다.
    - 또한 물리 메모리에 있는 집합의 경우 물리 메모리의 몇 번지에 있는지를 저장하여 주소 변환 시간을 단축시킨다.
  - 역매핑(Invert Mapping)
    - 앞의 세 가지 매핑과 반대로 페이지 테이블을 구성하는 방식이다.
    - 앞의 세 방식은 페이지테이블의 번호를 기준으로 테이블을 구성하지만, 역매핑에서는 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다.
    - 다시 말해 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시한다.
    - 아래 표에서는 편의를 위해 페이지 테이블 컬럼에 프레임 번호도 작성했지만, 실제 페이지 테이블에는 프레임 순서대로 저장되기에 프레임 번호는 없으며, Process ID와 페이지 번호만 있다. 
    - 역매핑의 가장 큰 특징은 프로세스의 수와 상관없이 프레임 테이블이 하나만 존재한다는 것이다.
    - 다른 방식에서는 프로세스마다 페이지 테이블을 만들지만 역매핑에서는 물리 메모리를 기준으로 프레임 테이블을 만들기에 전체 시스템에서 테이블의 수가 단 1개이다.
    - 따라서 테이블의 크기가 매우 작다는 것이 장점이다.
    - 다만, 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점이 있다.
    - 예를 들어 아래 표에서 프로세스 1의 페이지 11이 물리 메모리에 있는지 확인하려면 <PID 1, page 11>을 모든 테이블에서 찾아야만 그 결과를 알 수 있다.
    - 또한 모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 속도가 아주 느리다(페이지는 물리 메모리의 프레임과 매핑되는 것이므로, 프레임에 해당하는 페이지가 없다는 것은 페이지가 물리 메모리가 아닌 스왑 영역에 저장되어 있다는 것을 의미한다).

  | 프레임 | Process ID | 페이지 |
  | ------ | ---------- | ------ |
  | 0      | 1          | 3      |
  | 1      | 1          | 0      |
  | 2      | 1          | 7      |
  | 3      | 2          | 2      |
  | 4      | 1          | 11     |





