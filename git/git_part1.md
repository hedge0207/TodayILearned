# 시작하기

## 버전 관리 시스템

- 버전 관리 시스템(VCS, Version Control System)
  - 버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다.



- 중앙 버전 관리 시스템(CVCS)
  - 버전 정보를 중앙에서 관리하고 다른 사람들은 중앙 서버에 요청하여 버전 정보를 받아온다.
  - 중앙 서버에 문제가 생길 경우 문제가 해결될 때 까지 협업이 불가능하고 사람들이 하는 일을 백업할 방법도 없다.
  - 또한 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다.



- 분산 버전 관리 시스템(DVCS)

  - 버전 정보를 중앙뿐 아니라 참여한 모든 사람이 공유하는 방식.

  - 저장소를 히스토리와 더불어 전부 복제한다. 
  - 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. 
  - git은 분산 버전 관리 시스템 중 하나이다.



## git

- git에는 크게 4개의 영역이 있다.
  - working directory: 실제 작업중인 영역.
  - staging area: 버전 관리 하고자 하는 내용들을 옮겨 놓은 영역.
  - git repository: 버전 정보를 가지고 있는 영역.
    - local: 내가 작업하고 있는 내 컴퓨터의 git repository
    - remote:  github 등의 서버에 존재하는 git repository



- working directory는 다시 3개의 영역으로 나뉜다.
  - untracked: 한 번도 버전 정보가 관리된 적 없는 파일들
  - tracked: 버전 정보가 한 번이라도 관리된 적 있는 파일들
    - unmodified: 마지막 버전에서 한 번도 수정 된 적 없는 파일들
    - modified: 마지막 버전에서 한 번이라도 수정 된 적 있는 파일들



- 흐름
  - working directory에서 작업을 한다.
  - 작업을 하다가 현 시점의 버전을 관리해야 겠다고 생각이 들면 staging area로 작업한 내용을 옮긴다(`add`).
  - staging area에 있는 파일들을 git repository에 저장한다(`commit`).
  - 여기까지는 모두 local에서 이루어진다.
    - 따라서 내 컴퓨터에 문제가 생길 경우 지금까지 관리중인 버전 정보를 사용하지 못하게 될 수도 있다.
  - 만일 서버에 지금까지 저장한 버전을 옮기고 싶다면 github 등의 remote git repository로 이동시킨다(`push`).





## git 최초 설정

- git CLI
  - Git을 사용하는 방법은 많다. CLI로 사용할 수도 있고 GUI를 사용할 수도 있다.
  - Git의 모든 기능을 지원하는 것은 CLI 뿐이다. GUI 프로그램의 대부분은 Git 기능 중 일부만 구현하기 때문에 비교적 단순하다. 
  - CLI를 사용할 줄 알면 GUI도 사용할 수 있지만 반대는 성립하지 않는다. 
  - 따라서 CLI를 사용하는 것을 권장한다.



- git을 설치하고 나면 사용 환경을 적절하게 설정해 주어야 한다.
  - 환경 설정은 한 컴퓨터에서 한 번만 하면 된다. 
  - 설정한 내용은 Git을 업그레이드해도 유지된다. 
  - 언제든지 다시 바꿀 수 있는 명령어도 있다.



- `git config`라는 도구로 설정 내용을 확인하고 변경할 수 있다.
  - Git은 이 설정에 따라 동작한다. 이때 사용하는 설정 파일은 세 가지나 된다.
    - `/etc/gitconfig` 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. `git config --system` 옵션으로 이 파일을 읽고 쓸 수 있다. (이 파일은 시스템 전체 설정파일이기 때문에 수정하려면 시스템의 관리자 권한이 필요하다.)
    - `~/.gitconfig`, `~/.config/git/config` 파일: 특정 사용자(즉 현재 사용자)에게만 적용되는 설정이다. `git config --global` 옵션으로 이 파일을 읽고 쓸 수 있다. 특정 사용자의 *모든* 저장소 설정에 적용된다.
    - `.git/config` : 이 파일은 Git 디렉토리에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. `--local` 옵션을 사용하면 이 파일을 사용하도록 지정할 수 있다. 하지만 기본적으로 이 옵션이 적용되어 있다. (당연히, 이 옵션을 적용하려면 Git 저장소인 디렉토리로 이동 한 후 적용할 수 있다.)
  - 각 설정은 역순으로 우선시 된다. 그래서 `.git/config` 가 `/etc/gitconfig` 보다 우선한다.
  - 각 repo의 config는 아래 명령어로 확인이 가능하다.
    - 혹은 `.git/config` 파일에서도 확인이 가능하다.
  
  ```bash
  $ git config --local --list
  ```
  
  



- 사용자 이름과 이메일 주소 설정하기

  - 한 번 커밋 한 후에는 이 정보를 변경할 수 없다.
  - `--global` 옵션으로 설정하는 것은 딱 한 번만 하면 된다.
    - 해당 시스템에서 해당 사용자가 사용할 때는 이 정보를 사용한다.
    - 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 `--global` 옵션을 빼고 아래 명령어를 수행하면 된다.
  - 이름은 원하는 이름을 해도 되지만 이메일은 github 계정과 동일하게 해줘야 한다.
  
  ```bash
  $ git config --global user.name <"이름">
  $ git config --global user.email <"이메일">
  ```
  
  - 만일 리포지토리 별로 다른 계정을 사용하고 싶다면 아래와 같이 --global을 빼고 설정하면 된다.
    - repo별로 설정하는 것이므로 당연히 git으로 관리 중인 폴더에서 실행해야 한다.
    - `--global` 옵션을 주지 않으면 `--local` 옵션이 자동으로 들어가게 된다.
  
  ```bash
  $ git config user.name <"이름">
  $ git config user.email <"이메일">
  ```
  
  - 위에서 email을 github 계정으로 설정한다고 해서 해당 계정의 private에 접근 할 수 있는 것은 아니다.
    - 해당 계정의 private repo에 접근하려면 윈도우의 경우 자격 증명을 변경해 줘야 한다.
    - 자격증명에는 github email이 아닌 닉네임과 password를 적어야 한다.
    - 위 email 변경은 commit 시에 commit을 찍을 계정을 선택하는 것이다.
    - 혹은 굳이 변경하지 계정 정보를 추가하는 방법도 존재한다(아래의 [기존 저장소를 clone하기] 참고).



- 편집기 설정하기

  - Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용한다.
  - Notepad, VScode 등의 다양한 편집기를 사용할 수 있다.
  - 아래는 VScode를 편집기로 설정하는 코드이다.

  ```bash
  $ git config --global core.editor "code"
  ```

  - 이후 편집기를 실행하면 설정한 편집기가 실행되는 것을 확인 가능하다.

  ```bash
  $ git config --global -e
  ```

  - 만일 편집기가 실행되는 도중 터미널에 다른 명령어를 수행하지 못하게 막으려면 `--wait` 옵션을 주면 된다.

  ```bash
  $ git config --global core.editor "code --wait"
  ```



- 줄 바꿈 설정하기

  - 운영체제마다 에디터에서 줄 바꿈을 할 때 들어가는 문자열이 달라진다.
    - 윈도우: `\r\n`
    - 맥, 리눅스: `\n`
  - 이러한 차이점으로 인해 git repository를 다양한 운영체제에서 사용하는 경우 줄 바꿈으로 인한 문제가 발생할 수 있다.
  - 아래 명령어를 입력하면 git에 push 할 때와 pull 할 때 줄 바꿈 관련 처리를 자동으로 해준다.

  ```bash
  # window
  $ git config --global core.autocrlf true
  # Mac, Linux
  $ git config --global core.autocrlf input
  ```



- 설정 확인하기

  - `git config --list` 명령어를 실행하면 설정한 모든 내용을 볼 수 있다.

  ```bash
  $ git config --list
  ```

  - `git config <key>` 명령어로 git이 특정 key에 대해 어떤 값을 사용하는지 확인할 수 있다.

  ```bash
  # user name을 어떤 것으로 설정했는지 확인하는 예시
  $ git config user.name
  ```



- 도움말 보기

  - 명령어에 대한 도움말이 필요할 때 도움말을 보는 두 가지 방법(두 가지 모두 결과는 동일하다).

  ```bash
  $ git help <verb>
  $ man git-<verb>
  ```

  - 각 명령어에서 사용할 수 있는 옵션들에 대해 간략히 살펴보기 위해서는 `-h`, `--help` 옵션을 사용하면 된다.

  ```bash
  # add 명령어에 어떤 옵션들을 사용할 수 있는지 확인하는 예시
  $ git add -h
  ```





# Git의 기초

## Git 저장소 만들기

- git 저장소를 만드는 두 가지 방법
  - 아직 버전 관리를 하지 않는 로컬 디렉토리 하나를 선택해서 git 저장소를 적용하는 방법
  - 다른 어딘가에서 git 저장소를 clone하는 방법



- git 명령어

  - git 명령어는 `git`, `명령어`, `-option`으로 나눌 수 있다.
  - `git`은 모든 명령어 앞에 붙인다.
  - 명령어는 수행하고자 하는 동작을 의미한다.
  - `-option`은 해당 동작을 수행하는 옵션을 의미한다.

  ```bash
  $ git <명령어> -option
  ```

  - 아래 방법을 통해서 명령어를 축약해서 사용할 수 있다.

  ```bash
  $ git config --global alias.<단축하여 사용할 이름> <단축할 명령어>
  ```

  



- 기존 디렉토리를 git 저장소로 만들기

  - 버전 관리를 시작할 디렉토리로 이동해서 아래 명령어를 실행한다.

  ```bash
  $ git init
  ```

  - 위 명령어를 수행하면 `.git`이라는 하위 디렉토리가 생성된다.
    - 만일 보이지 않는다면 숨김 파일 보기를 체크하면 보일 것이다.
    - `.git` 디렉토리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다.
    - 이 디렉토리를 삭제하면 프로젝트가 더 이상 git 으로 관리되지 않게 된다.
  - 아직은 이 프로젝트를 git으로 관리하는 것이 아니다.
  - 아래 명령어를 입력해야 버전 관리가 시작된다.

  ```bash
  $ git add .
  $ git commit -m 'initial project version'
  ```

  

- 기존 저장소를 clone하기

  - clone하려는 repository의 주소를 복사한 후 아래 명령어와 함께 입력한다.

  ```bash
  $ git clone <주소>
  ```

  - 위 명령어를 입력하면 해당 repository 이름으로 된 디렉토리를 생성하고 그 안에 `.git` 디렉토리를 생성한다.
  - 아래 명령어를 실행하면 이미 설정된 저장소 이름이 아닌 내가 원하는 이름을 지정할 수 있다.

  ```bash
  $ git clone <주소> <이름>
  ```

  - 만일 다른 계정의 private repository를 clone해야 한다면 아래와 같이 주소 앞에 clone하려는 repo를 생성한 계정을 입력해야 한다.
    - push에도 적용 되는지는 확인 필요
  
  ```bash
  $ git clone https://<github에 등록된 유저명>@<github repo 주소>
  ```





## 저장소에 저장하기

- 파일 상태 확인하기

  - 아래 명령어를 입력하면 Untracked 파일 정보와 modified 파일 정보를 볼 수 있다.
  - 즉 아직 버전이 관리된 적 없는 파일 정보와 버전이 관리된 적 있으나 마지막 버전과 달라진 파일 정보를 볼 수 있다.
  - 또한 현재 작업중인 브랜치 정보도 알려준다.

  ```bash
  $ git status
  ```

  - 만일 간략하게 확인하고 싶다면 아래와 같이 `-s` 또는 `--short` 옵션을 입력한다.

  ```bash
  $ git status -s
  ```

  - 위 명령어는 `?`, `A`, `M`, ` (공백)`을 사용하여 상태를 보여준다.
    - 아직 버전이 관리된 적 없는 파일 앞에는 `??`가 붙는다.
    - 버전이 관리된 적 있는 파일 앞에는 `M` 또는 `A`가 오는데, 두 자리를 차지한다.
    - 왼쪽에는 Staging Area에서의 상태를, 오른쪽에는 Working Tree에서의 상태를 표시한다.
    - 왼쪽에 표시된 `A`는 Staged 상태로 추가한 파일 중 새로 생성한 파일이라는 뜻이고
    - 왼쪽에 표시된 `M`은  Staged 상태로 추가한 파일 중 수정한 파일이라는 뜻이다.
    - 오른쪽에 표시된 `M`은 수정한 파일이라는 뜻이다.
    - 예를 들어 "  M"은 Staged 상태가 아니고 수정 사항이 있다는 뜻이고
    - "MM"은 Staged 상태지만 수정 사항도 있다는 뜻이고
    - "A  "는 Staged 상태인 새로 추가된 파일이라는 뜻이다.



- 변경 내용 확인하기

  - 단순히 어떤 파일이 변경되었는지가 아니라 어떤 내용이 변경되었는지 보려면 아래 명령어를 입력하면 된다.

  ```bash
  $ git diff
  ```

  - 이 명령어는 워킹 디렉토리에 있는 것과 Staging Area에 있는 것을 비교한다.
    - 즉 수정했으나 아직 staged 상태가 아닌 내용들을 보여준다.
  - 만일 Staging Area에 있는 파일의 변경 부분을 보고 싶으면 옵션으로 `--staged` 또는 `--cached`를 주면된다. 
    -  둘은 같은 옵션이다.
    - 이 명령은 저장소에 커밋한 것과 Staging Area에 있는 것을 비교한다.

  ```bash
  # --staged 옵션
  $ git diff --staged
  
  # --cached 옵션
  $ git diff --cached
  ```

  - 잊지 말아야 할 것은 `git diff` 명령어는 마지막으로 커밋한 후에 수정한 것들 전부를 보여주는 것은 아니라는 것이다.
    - `git diff` 는 Unstaged 상태인 것들만 보여준다. 
    - 수정한 파일을 모두 Staging Area에 넣었다면 `git diff` 명령은 아무것도 출력하지 않는다.



- 파일을 staging area로 옮기기

  - 아래 명령어를 입력하면 Untracked 파일과 modified 파일이 staging area로 이동하게 된다(Staged 상태가 된다).

  ```bash
  $ git add <추가할 파일명>
  
  # 아래와 같이 입력하면 모든 파일이 추가 된다.
  $ git add .
  ```
  
  - 이후 다시 `git status` 명령어를 입력하면 `Changes to be committed:` 라는 메세지를 볼 수 있는데 여기에 해당하는 파일들은 staging area로 옮겨진 것(Staged 상태가 된 것)이다. 
  - 만일 Staged 상태인 파일을 수정한후 `git status` 명령어를 입력하면 해당 파일은 Staged 상태이면서 동시에 Unstaged 상태인 것이 확인 가능하다.
  - 지금 이 시점에서 커밋을 하면 `git commit` 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 `git add` 명령을 실행했을 때의 버전이 커밋된다. 
  - 그러니까 `git add` 명령을 실행한 후에 또 파일을 수정하면 `git add` 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 한다.



- Git으로 관리하지 않을 파일 제외시키기

  - `.gitignore` 파일을 생성한다.
  - 위 파일 안에 무시할 패턴을 작성한다.

    - `#` 은 주석으로 인식한다.
    - `표준 Glob` 패턴을 사용한다.
    - `*`은 모든을 나타낸다.
    - `/`는 무시할 디렉토리를 나타낸다. 앞에 붙이면 현재 디렉토리의 특정 파일, 뒤에 붙이면 현재 디렉토리의 모든 파일을 무시하겠다는 뜻이다.
    - `!`는 무시하지 않겠다는 것을 의미한다.
    - `[abc]`는 대괄호 안의 문자 중 하나라도 일치하는 것은 무시하겠다는 것이다.
    - `[a-z]`는 a~z까지 중 하나라도 일치하는 것은 무시하겠다는 것이다.
  - 예시

  ```python
  # 확장자가 .a인 파일 무시
  *.a
  
  # 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음
  !lib.a
  
  # 현재 디렉토리에 있는 TODO파일은 무시하고 subdir/TODO처럼 하위디렉토리에 있는 파일은 무시하지 않음
  /TODO
  
  # build/ 디렉토리에 있는 모든 파일은 무시
  build/
  
  # doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음
  doc/*.txt
  
  # doc 디렉토리 아래의 모든 .pdf 파일을 무시
  doc/**/*.pdf
  
  # 이름 끝에 c가 들어가는 모든 파일을 무시
  *c.*
  
  # 이름 첫 글자에 a또는 b가 오는 txt 파일 무시
  [ab]*.txt
  ```

  - 더 간단한 방법은 아래 사이트에 접속해서 `.gitignore`파일을 작성하는 것이다.

    > https://www.toptal.com/developers/gitignore
  
  - gitignore가 제대로 적용 중인지 확인하기
  
  ```bash
  $ git status --ignored
  ```



- 빈 디렉터리 추가하기
  - git에는 빈 디렉터리를 추가하는 것이 불가능하다.
    - 그러나 빈 디렉터리를 추가해야 하는 경우도 있는 데 이 때 사용할 수 있는 방법이다.
  - `.gitkeep` 파일을 빈 디렉터리에 추가한다.
    - git에 빈 디렉터리를 추가하기 위해 사용하는 빈 파일이다.



- 변경 사항 커밋하기

  - staging area에 있는 파일들만 커밋 된다.
    - 즉 생성하거나 수정하고 나서 `git add` 명령어로 추가하지 않은 파일은 커밋하지 않는다.
    - 아래 명령어를 입력하면 자동으로 커밋 메세지에 `git status` 명령의 결과가 채워진다.

  ```bash
  $ git commit
  ```

  - `git commit`에 `-v` 옵션을 주면 `git diff`를 했을 때 나오는 메세지도 추가된다.

  ```bash
  $ git commit -v
  ```

  - `-m` 옵션을 주면 커밋 메세지를 인라인으로 첨부할 수도 있다.

  ```bash
  $ git commit -m '메세지'
  ```

  - 커밋 날짜 변경하기
    - 맨 마지막 커밋 날짜를 변경한다.

  ```bash
  $ git commit --amend --no-edit --date "<변경하고자 하는 날짜>"
  
  # 예시
  $ git commit --amend --no-edit --date "Mon 20 Aug 2018 20:19:19 KST"
  ```

  

  

- Staging Area 생략하기

  - `git commit` 명령을 실행할 때 `-a` 옵션을 추가하면 Git은 Tracked 상태의 파일을 자동으로 Staging Area에 넣는다. 
    - 이를 통해 `git add` 명령어를 수행하지 않고도 커밋이 가능하다.

  ```bash
  $ git commit -a
  ```

  

- Staging Area에 있는 파일 삭제하기

  - 커밋한 파일 삭제하기
    - 워킹 디렉토리에서도 파일이 삭제되므로 주의해야 한다.

  ```bash
  $ git rm <삭제할 파일>
  ```

  - `git rm` 명령어로 삭제하는 것과 단순히 워킹 디렉토리에서 파일을 삭제하는 것의 차이
    - `git rm`으로 삭제한 파일은 stated 상태가 된다. 즉, staging area에도 삭제 했다는 변경 사항이 바로 반영이 된다.
    - 워킹 디렉토리에서 삭제하면  해당 파일은 unstaged 상태가 된다. 즉 `git add` 명령어를 통해 staging에 변경 사항을 반영해 줘야 한다.

  - 커밋하지는 않은 파일 삭제하기
    - Staging Area에 있지만 커밋 하지는 않은 파일을 삭제하려면 아래와 같이 `-f` 옵션을 줘야 한다.
    - 이 역시 워킹 디렉토리에서도 파일이 삭제된다.

  ```bash
  $ git rm -f <삭제할 파일>
  ```

  - 워킹 디렉토리에서는 남기고 Staging Area에서만 삭제하는 방법
    - `--cached` 옵션을 주면 된다.

  ```bash
  $ git rm --cached <삭제할 파일>
  ```

  

- 파일 이름 변경하기

  - 아래 명령어를 통해 파일 이름을 변경할 수 있다.

  ```bash
  $ git mv <기존 파일명> <변경할 파일명>
  ```

  - 사실 위 명령어는 아래 명령어를 수행한 것과 동일하다.

  ```bash
  # git 명령어가 아닌 일반 명령어로 파일명을 변경하고
  $ mv <기존 파일명> <변경할 파일명>
  # 아래 명령어가 수행되는 것과 동일하다.
  $ git rm <기존파일명>
  $ git add <변경할 파일명>
  ```






## 커밋 히스토리 조회하기

- `git log` 명령어를 통해 히스토리를 조회할 수있다.

  - 최신순으로 조회된다.

  ```bash
  $ git log
  ```



- 원하는 히스토리를 조회할 수 있도록 다양한 옵션을 제공한다.

  - `-p`, `--patch`
    - 각 커밋의 diff 결과를 보여준다.

  ```bash
  $ git log -p
  ```

  - `--stat`
    - 각 커밋의 통계 정보를 확인할 수 있다.

  ```bash
  $ git log --stat
  ```

  - `--pretty`

    - 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. 몇개 선택할 수 있는 옵션의 값이 있다. 
    - `oneline` 옵션은 각 커밋을 한 라인으로 보여준다. 이 옵션은 많은 커밋을 한 번에 조회할 때 유용하다. 
    - `short`, `full`, `fuller` 옵션도 있는데 이것은 정보를 조금씩 가감해서 보여준다.
    - `format` 옵션은 자신이 정의한 포맷으로 결과를 출력해준다(아래 표는 format 옵션에 사용할 수 있는 옵션들이다).

    | 옵션 | 설명                |
    | ---- | ------------------- |
    | %H   | 커밋 해시           |
    | %h   | 짧은 길이 커밋 해시 |
    | %T   | 트리 해시           |
    | %t   | 짧은 길이 트리 해시 |
    | %P   | 부모 해시           |
    | %p   | 짧은 길이 부모 해시 |
    | %an  | 저자 이름           |
    | %ae  | 저자 메일           |
    | %ad  | 저자 시각           |
    | %ar  | 저자 상대적 시각    |
    | %cn  | 커미터 이름         |
    | %ce  | 커미터 메일         |
    | %cd  | 커미너 시각         |
    | %cr  | 커미터 상대적 시각  |
    | %s   | 요역                |

    - 저자와 커미터가 분리되어 있는데 저자는 원래 작업을 수행한 원작자이고 커밋터는 마지막으로 이 작업을 적용한(저장소에 포함시킨) 사람이다.

  ```bash
  $ git log --pretty=<옵션>
  ```

  - `--graph`
    - 브랜치와 머지 히스토리를 보여주는 아스키 그래프를 출력한다.

  ```bash
  $ git log --graph
  ```



- 조회 제한 조건

  - `git log` 명령은 조회 범위를 제한하는 옵션들도 있다.
    - 히스토리 전부가 아니라 부분만 조회한다.
  - `-숫자`
    - 해당 숫자 만큼의 기록만 보여준다.

  ```bash
  $ git log -<숫자>
  ```

  - `--since`, `--until`
    - 각기 어느 시점까지, 어느 시점부터의 기록들을 보여준다.
    - `"2020-01-15"` 같이 정확한 날짜도 사용할 수 있고 `"2 years 1 day 3 minutes ago"` 같이 상대적인 기간을 사용할 수도 있다.

  ```bash
  $ git log --since=2.weeks
  $ git log --until=2.2020-01-15
  ```

  - `--author`/`--committer`
    - 저자/커미터를 지정하여 검색할 수 있다.
  - `--grep`
    - 커밋 메세지에서 키워드를 검색할 수 있다.
  - `--all-match`
    - 여러 옵션을 함께 사용하여 조건을 모두 만족하는 값을 찾으려면 이 옵션도 함께 줘야 한다.
  - `-S`
    - 코드에서 추가되거나 제거된 내용 중에 특정 텍스트가 포함되어 있는지를 검색한다.

  ```bash
  $ git log -S <검색할 내용>
  ```

  - `--`
    - 디렉토리나 파일 이름을 사용하여 그 파일이 변경된 log의 결과를 검색할 수 있다. 
    - 명령어 끝 부분에 쓴다.

  ```bash
  $ git log -- <path1> <path2>
  ```



- 머지 커밋 표시하지 않기
  - 저장소를 사용하는 워크플로우에 따라 머지 커밋이 차지하는 비중이 클 수도 있다.
  - `--no-merges` 옵션을 사용하면 검색 결과에서 머지 커밋을 표시하지 않도록 할 수 있다.





## 되돌리기

- 완료한 커밋을 수정하기

  - 다시 커밋하고 싶으면 파일 수정 작업 후 Staging Area에 추가한 다음 `--amend` 옵션을 사용하여 커밋을 재작성 할 수 있다.

  ```bash
  $ git commit --amend
  ```

  - 이 명령은 Staging Area를 사용하여 커밋한다. 
    - 만약 마지막으로 커밋하고 나서 수정한 것이 없다면(커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같다. 
    - 이때는 커밋 메시지만 수정한다.
  - 편집기가 실행되면 이전 커밋 메시지가 자동으로 포함된다. 
    - 메시지를 수정하지 않고 그대로 커밋해도 기존의 커밋을 덮어쓴다.
  - 커밋을 했는데 Staging Area에 옮기는 것을  깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수 있다.

  ```bash
  $ git commit
  $ git add <빠트린 파일>
  $ git commit --amend
  ```

  - `--amend` 옵션으로 커밋을 고치는 작업은, 추가로 작업한 일이 작다고 하더라도 이전의 커밋을 완전히 새로 고쳐서 새 커밋으로 변경하는 것을 의미한다. 
    - 이전의 커밋은 일어나지 않은 일이 되는 것이고 당연히 히스토리에도 남지 않는다.
  - `--amend` 옵션으로 커밋을 고치는 작업이 주는 장점은 마지막 커밋 작업에서 아주 살짝 뭔가 빠뜨린 것을 넣거나 변경하는 것을 새 커밋으로 분리하지 않고 하나의 커밋에서 처리하는 것이다. 
    - “앗차, 빠진 파일 넣었음”, “이전 커밋에서 오타 살짝 고침” 등의 커밋을 만들지 않겠다는 말이다.



- 파일 상태를 Unstaged로 변경하기

  - 아래 명령어를 입력하면 된다.
  - 단 `reset` 명령어는 매우 위험할 수 있다.

  ```bash
  $ git reset HEAD <file>
  ```



- Modified 파일 되돌리기

  - 마지막 커밋 기록으로 수정된 파일을 되돌리는 방법
  - 원래 파일을 덮어쓰기 때문에 수정한 내용은 전부 사라진다.

  ```bash
  git checkout -- <file>
  ```

  



## 리모트 저장소

- 리모트 저장소

  - 리모트 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. 
  - 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기만 가능할 수 있다.
  - 리모트 저장소를 관리할 줄 알아야 다른 사람과 함께 일할 수 있다. 
    - 간단히 말해서 다른 사람들과 함께 일한다는 것은 리모트 저장소를 관리하면서 데이터를 거기에 Push 하고 Pull 하는 것이다. 
    - 리모트 저장소를 관리한다는 것은 저장소를 추가, 삭제하는 것뿐만 아니라 브랜치를 관리하고 추적할지 말지 등을 관리하는 것을 말한다.

  - “remote” 저장소라고 이름이 붙어있어도 이 원격 저장소가 사실 같은 로컬 시스템에 존재할 수도 있다. 
    - 여기서 “remote” 라는 이름은 반드시 저장소가 네트워크나 인터넷을 통해 어딘가 멀리 떨어져 있어야만 한다는 것을 의미하지 않는다. 
    - 물론 일반적인 원격 저장소와 마찬가지로 Push, Pull 등의 기능은 동일하게 사용한다.



- 리모트 저장소 확인하기

  - `git remote`명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인할 수 있다.
    - 이 명령은 리모트 저장소의 단축 이름을 보여준다. 
    - 저장소를 Clone 하면 `origin`이라는 리모트 저장소가 자동으로 등록되기 때문에 `origin`이라는 이름을 볼 수 있다.

  ```bash
  $ git remote
  ```

  - `-v` 옵션을 주어 단축 이름괴 URL을 확인 가능하다.

  ```bash
  $ git remote -v
  ```

  

- 리모트 저장소 추가하기

  - 아래 명령어를 사용한다.

  ```bash
  $ git remote add <단축이름> <URL>
  ```



- 리모트 저장소에 push하기

  ```bash
  $ git push <단축이름> <브랜치명>
  ```



- 리모트 저장소를 pull 하거나 fetch하기

  - `git fetch`
    - `git fetch`는 데이터를 가져오기만 할 뿐 자동으로 Merge하지는 않는다.
    - 따라서 로컬에서 하던 작업을 정리하고 나서 수동으로 Merge 해야 한다.

  ```bash
  $ git fetch <remote>
  ```

  - `git pull`
    - 데이터를 가져와 자동으로 Merge한다.

  ```bash
  $ git pull <단축이름> <브랜치명>
  ```

  

- 리모트 저장소 살펴보기

  - 아래 명령어를 입력하면 리모트 저장소의 구체적인 정보를 확인할 수 있다.

  ```bash
  $ git remote show <단축이름>
  ```

  - 이 명령은 `git pull` 명령을 실행할 때 master 브랜치와 Merge 할 브랜치가 무엇인지 보여 준다.
  - 또한 브랜치명을 생략하고 `git push` 명령을 실행할 때 어떤 브랜치가 어떤 브랜치로 Push 되는지 보여준다. 
  - 그 외에도 아직 로컬로 가져오지 않은 리모트 저장소의 브랜치는 어떤 것들이 있는지, 서버에서는 삭제됐지만 아직 가지고 있는 브랜치는 어떤 것인지, `git pull` 명령을 실행했을 때 자동으로 Merge 할 브랜치는 어떤 것이 있는지 보여준다.



- 리모트 저장소 이름을 바꾸거나 리모트 저장소를 삭제하기

  - 저장소 이름 변경

  ```bash
  $ git remote rename <원래 단축이름> <변경할 단축이름>
  ```

  - 저장소 삭제
    - 위와 같은 방법으로 리모트 저장소를 삭제하면 해당 리모트 저장소에 관련된 추적 브랜치 정보나 모든 설정 내용도 함께 삭제된다.

  ```bash
  $ git remote remove <단축이름>
  ```

  

## 태그

- 다른 VCS처럼 git도 태그를 지원한다.
  - 보통 릴리즈할 때 사용한다.



- 태그 조회하기

  - 알파벳 순서로 태그를 보여준다.

  ```bash
  $ git tag
  ```

  - `-l` 혹은 `--list` 옵션을 줄 수 있다.
    - 단순히 모든 Tag 목록을 확인하기 위해 `git tag` 명령을 실행했을 때 `-l` 또는 `--list` 옵션이 적용된 것과 동일한 결과가 출력된다.
    - 하지만 와일드카드를 사용하여 태그 목록을 검색하는 경우에는 반드시 `-l` 또는 `--list` 옵션을 같이 써 줘야 원하는 결과를 얻을 수 있다.

  ```bash
  $ git tag -l <"검색할 내용">
  ```



- 태그 붙이기

  - git 태그는 **Lightweight** 태그와 **Annotated** 태그로 두 종류가 있다.
  - Annotated
    - Git 데이터베이스에 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜, 그리고 태그 메시지도 저장한다. 
    - GPG(GNU Privacy Guard)로 서명할 수도 있다. 
    - 일반적으로 Annotated 태그를 만들어 이 모든 정보를 사용할 수 있도록 하는 것이 좋다. 
    - 하지만 임시로 생성하는 태그거나 이러한 정보를 유지할 필요가 없는 경우에는 Lightweight 태그를 사용할 수도 있다.
    - `git show` 명령으로 태그 정보와 커밋 정보를 모두 확인할 수 있다.

  ```bash
  # -a 옵션을 추가하면 Annotated 태그로 등록된다.
  # -m 옵션으로 태그를 저장할 때 메세지를 함께 저장할 수 있다. 명령을 실행할 때 메시지를 입력하지 않으면 Git은 편집기를 실행시킨다.
  $ git tag -a <태그> -m <"메세지">
  ```

  ```bash
  # git show 명령어를 실행하면 태그 정보와 커밋 정보를 모두 확인할 수 있다.
  $ git show <태그명>
  ```

  - Lightweight
    - 브랜치와 유사한데 브랜치처럼 가리키는 지점을 최신 커밋으로 이동시키지는 않는다.
    - Lightweight 태그는 기본적으로 파일에 커밋 체크섬을 저장하는 것뿐이다. 다른 정보는 저장하지 않는다.
    -  `git show` 를 실행하면 별도의 태그 정보를 확인할 수 없다. 이 명령은 단순히 커밋 정보만을 보여준다.

  ```bash
  $ git tag <태그명>
  ```

  

- 이전 커밋에 태그하기

  - 특정 커밋에 태그하기 위해서 명령의 끝에 커밋 체크섬을 명시한다(긴 체크섬을 전부 사용할 필요는 없다).

  ```bash
  $ git tag <태그> <체크섬의 전부 또는 일부>
  ```

  

- 태그 공유하기

  - `git push` 명령을 실행해도 자동으로 리모트 서버에 태그를 전송하지 않는다.
    - 태그를 만들었으면 서버에 별도로 Push 해야 한다. 
    - 브랜치를 공유하는 것과 같은 방법으로 할 수 있다.

  ```bash
  $ git push <단축주소> <태그>
  ```

  - 만약 한 번에 태그를 여러 개 Push 하고 싶으면 `--tags` 옵션을 추가한다.

  ```bash
  git push <단축주소> --tags
  ```

  

- 태그를 Checkout 하기

  - 태그가 특정 버전을 가리키고 있고, 특정 버전의 파일을 체크아웃 해서 확인하고 싶다면 다음과 같이 실행한다. 
    - 단 태그를 체크아웃하면(브랜치를 체크아웃 하는 것이 아니라면) “detached HEAD”(떨어져나온 HEAD) 상태가 되며 일부 Git 관련 작업이 브랜치에서 작업하는 것과 다르게 동작할 수 있다.

  ```bash
  $ git checkout <태그>
  ```

  - “detached HEAD”(떨어져나온 HEAD) 상태에서는 작업을 하고 커밋을 만들면, 태그는 그대로 있으나 새로운 커밋이 하나 쌓이 상태가 되고 새 커밋에 도달할 수 있는 방법이 따로 없게 된다. 
    - 물론 커밋의 해시 값을 정확히 기억하고 있으면 가능하긴 하다. 
    - 특정 태그의 상태에서 새로 작성한 커밋이 버그 픽스와 같이 의미있도록 하려면 반드시 브랜치를 만들어서 작업하는 것이 좋다.

## Git Alias

- Git의 명령을 전부 입력하는 것이 귀찮다면 `git config` 를 사용하여 각 명령의 Alias를 쉽게 만들 수 있다.

  - 기존의 명령어를 축약

  ```bash
  $ git config --global alias.<단축 명령어> <단축할 명령어>
  ```

  - 새로운 명령어를 생성

  ```bash
  # 예시
  $ git config --global alias.unstage 'reset HEAD --'
  ```



- Git의 명령어뿐만 아니라 외부 명령어도 실행할 수 있다. 

  - `!` 를 제일 앞에 추가하면 외부 명령을 실행한다. 
  - 커스텀 스크립트를 만들어서 사용할 때 매우 유용하다. 
  - 아래 명령은 `git visual` 이라고 입력하면 `gitk` 가 실행된다.

  ```bash
  $ git config --global alias.visual '!gitk'
  ```

  



