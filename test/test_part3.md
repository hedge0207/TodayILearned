# 유지 보수성

- 유지 보수성은 개발의 속도와 관련되어 있다.
  - 테스트의 실질적 도움
    - 프로덕션 코드를 변경할 때 기존 테스트를 계속 변경해야 한다면 오히려 개발 속도를 늦추게 된다.
    - 그러나 프로덕션 코드를 변경하고도 기존 테스트를 수정할 필요가 없다면 테스트가 개발에 실질적인 도움이 된다고 볼 수 있다.
  - 유지 보수성이 테스트를 얼마나 자주 변경해야 하는지 가늠하는 척도라면 그 횟수를 최소화하는 것이 중요하다.
    - 이를 위한 근본적인 원인을 파악하려면 아래 항목을 점검해 볼 필요가 있다.
    - 언제 테스트가 실패하여 변경이 필요하다는 사실을 깨닫는가?
    - 왜 테스트가 실패하는가?
    - 어떤 테스트가 실패했을 때 테스트 코드를 반드시 수정해야 하는가?
    - 테스트 코드를 반드시 수정할 필요가 없더라도 언제 테스트 코드를 변경하는가?



- 테스트 실패로 코드 변경
  - 실제 실패(true failure)와 거짓 실패(false failure)
    - 테스트 실패는 유지 보수성에 문제가 생길 수 있음을 알려주는 첫 번째 신호다.
    - 물론 실제로 프로덕션 코드에서 버그를 발견할 수도 있지만, 그렇지 않을 수도 있다.
    - 프로덕션 코드의 버그로 발생한 실패를 실제 실패라한다.
    - 프로덕션 코드의 버그가 아닌 다른 이유로 발생하는 실패를 거짓 실패라 한다.
  - 테스트의 유지 보수성 측정
    - 일정 기간 동안 발생하는 거짓 실패 횟수와 그 원인을 분석하면 유지 보수성을 측정할 수 있다.
    - 거짓 실패가 발생하는 원인 중 하나는 테스트 자체의 버그이며, 그 밖에 다른 원인들도 있다.
  - 테스트와 관련이 없거나 다른 테스트와 충돌하는 경우
    - 프로덕션 코드에 새로운 기능을 넣으면 기존 테스트와 충돌할 수 있다.
    - 이 경우 거짓 실패가 발생할 수 있다.
    - 이 경우 테스트는 버그를 찾는 용도로만 사용하지 않고 새 기능이 추가된 코드의 신규 요구 사항을 제대로 반영했는지 확인하는 용도로도 사용할 수 있다.
    - 또 코드가 변경되어 기대 결과 역시 달라졌을 수 있으니, 새로운 기능에 맞춰 작성된 테스트는 통과할 수 있지만 기존 테스트는 더 이상 유효하지 않을 수 있다.
    - 새로운 기능이 추가되어 실패한 테스트는 더 이상 유효하지 않거나 새로운 요구사항이 잘못되었을 수 있다.
    - 요구 사항이 맞는다고 가정하면 유효하지 않은 테스트는 삭제해도 된다.



- 프로덕션 코드의 API 변경

  - 테스트 대상 코드가 변경되어 함수나 객체를 사용하는 방식이 달라지는 경우에도 거짓 실패가 발생할 수 있다.
    - 이러한 거짓 실패는 가능한 피해야한다.
    - 예를 들어 아래 코드는 유지 보수성 관점에서 보면 머지않아 수정해야 할 수 도 잇는 여러 문제점이 보인다.

  ```python
  # 테스트 대상 코드
  class ILogger(ABC):
      @abstractmethod
      def info(self):
          ...
  
  class PasswordVerifier:
      def __init__(self, rules, looger: ILogger):
          self._rules = rules
          self._logger = logger
      
      def verify(self, text):
          ...
          
  # 테스트
  class MockLogger(ILogger):
      def info(self, text):
          ...
  
  def test_passes_with_zero_rules():
      verifier = PasswordVerifier([], MockLogger())
      result = verifier.verifiy("any input")
      assert result
  
  def test_fails_with_failing_rule():
      verifier = PasswordVerifier([lambda : False], MockLogger())
      result = verifier.verifiy("any input")
      assert not result
  ```

  - 코드의 수명은 길다.
    - 현재 작성 중인 코드는 때로는 10년 이상 그 자리에 있을 수도 있다.
    - 그 기간 동안 `PasswordVerifier`의 설계가 변경될 가능성은 무궁무진하다.
    - 앞으로 `PasswordVerifier`에는 아래와 같은 변경이 있을 수 있다.
    - 생성자 매개변수의 추가나 삭제
    - 생성자 매개변수의 자료형의 변경
    - `ILogger`의 함수 개수나 함수 시그니처의 변경
    - 사용 패턴의 변경으로 `PasswordVerifier`를 인스턴스화하지 않고 함수만 직접 사용.
  - 만약 프로덕션 코드의 API가 아래와 같이 변경되었다고 가정해보자.
    - `logger`는 이제 `IComplicatedLogger`의 인스턴스여야한다.
    - 아래와 같이 수정될 경우, PasswordVerifier를 직접 인스턴스화하는 모든 테스트를 수정해야한다.

  ```python
  class PasswordVerifier:
      def __init__(self, rules, logger: IComplicatedLogger):
          self._rules = rules
          self._logger = logger
      
      # ...
  ```

  - 팩토리 함수로 객체를 만드는 과정을 분리한다.
    - 유지 보수성을 떨어뜨릴 수 있는 잠재적인 문제 상황을 피하는 방법은 테스트할 코드의 생성 과정을 분리하거나 추상화하는 것이다.
    - 아래에서는 `PasswordVerifier`의 생성을 공용(centralized) 팩토리 함수로 분리했다.
    - 이렇게 하면 나중에 변경 사항이 발생하더라도 팩토리 함수만 수정하면 된다.

  ```python
  # 아래와 같이 팩토리 함수를 통해 인스턴스를 생성한다.
  def make_password_verifier(rules: list, logger: ILogger):
      return PasswordVerifier(rules, logger)
  
  
  # 추후에 변경이 필요할 경우, 모든 테스트 코드를 변경하지 않고, 팩토리 함수만 변경한다.
  def make_password_verifier(rules: list, logger: IComplicatedLogger):
      return PasswordVerifier(rules, logger)
  ```



- 다른 테스트가 변경되었을 경우

  - 테스트는 항상 다른 테스트와 독립적으로 실행되어야 한다.
    - 같은 기능을 검증하더라도 각 테스트는 서로 격리된 공간에서 실행되어야 한다.
    - 테스트가 제대로 분리되지 않으면 각 테스트가 서로 간섭하게 된다.
    - 그러면 코드가 매우 복잡해져 단위 테스트에 많은 시간을 소모하게 된다.
  - 순서가 정해진 테스트
    - 이전 테스트의 실행 여부에 따라 결과가 달라지는 테스트를 말한다.
    - 이는 테스트가 다른 테스트 때문에 설정 값이 바뀌거나 공유 변수 같은 자원의 상태 값이 변경되는 것에 영향을 받기 때문이다.
  - 예를 들어 아래와 같은 코드가 있다고 가정해보자.
    - `UserCache`는 애플리케이션과 테스트에서 데이터를 임시로 저장하는 단일 인스턴스(싱글톤)을 사용한다.

  ```python
  class UserDetails(BaseModel):
      key: str
      password: str
  
  
  class UserCacheInterface(ABC):
      @abstractmethod
      def add_user(self, user: UserDetails):
          ...
          
      @abstractmethod
      def get_user(self, key: str):
          ...
          
      @abstractmethod
      def reset(self):
          ...
          
          
  class UserCache(UserCacheInterface):
      def __init__(self):
          self._users = {}
      
      def add_user(self, user: UserDetails):
          if self._users.get(user.key) is None:
              self._users[user.key] = user
          else:
              raise Exception("user aleady exists")
      
      def get_user(self, key: str) -> UserDetails:
          return self._users.get(key)
      
      def reset(self):
          self._users = {}
          
  
  cache = None
  def get_user_cache() -> UserCache:
      global cache
      if cache is None:
          cache = UserCache()
      return cache
  
  
  class SpecialApp:
      def login_user(self, key:str, pass_: str) -> bool:
          _cache = get_user_cache()
          found_user = _cache.get_user(key)
          if found_user is not None and found_user.password == pass_:
              return True
          return False
  ```

  - 위 코드의 테스트 코드를 아래와 같이 작성했다.
    - 아래 코드는 첫 번째 테스트와 세 번째 테스트가 모두 두 번째 테스트에 의존하고 있다.
    - 첫 번째 테스트는 cache가 비어 있어야 성공하므로 두 번째 테스트가 먼저 실행되면 안 된다.
    - 세 번째 테스트는 두 번째 테스트가 유저 정보를 cache에 넣어야 성공하므로 두 번째 테스트가 먼저 실행되어야 한다. 

  ```python
  def test_no_user_login_fails():
      app = SpecialApp()
      result = app.login_user("foo", "bar")
      assert not result
      
  def test_can_only_cache_each_user_once():
      get_user_cache().add_user(UserDetails(**{"key":"foo", "password":"bar"}))
      with pytest.raises(Exception, match=r"user aleady exists"):
          get_user_cache().add_user(UserDetails(**{"key":"foo", "password":"bar"}))
  
  def test_users_exists_login_succeed():
      app = SpecialApp()
      result = app.login_user("foo", "bar")
      assert result
  ```

  - 리팩터링하기
    - 위와 같은 안티 패턴은 보통 테스트 일부를 헬퍼 함수로 빼지 않고 사용하려 할 때 발생한다.
    - 다른 테스트가 먼저 실행되어 현재 테스트에 필요한 설정 값을 초기화 해 주길 바라는 것이다.
    - 이를 해결하려면 헬퍼 함수를 만들어야한다.
    - 아래와 같이 수정하면, 테스트 실핼 순서가 테스트 결과에 영향을 미치지 않는다.

  ```python
  # cache에 사용자를 추가해주는 헬퍼 함수
  def add_default_user():
      get_user_cache().add_user(UserDetails(**{"key":"foo", "password":"bar"}))
  
  # SpecialApp 인스턴스도 팩토리 함수로 생성하도록 변경한다.
  def make_special_app() -> SpecialApp:
      return SpecialApp()
  
  # 각 테스트가 실행되기 전에 실행되어 cache를 초기화해주는 함수
  @pytest.fixture
  def reset_cache():
      get_user_cache().reset()
  
  def test_no_user_login_fails(reset_cache):
      app = make_special_app()
      result = app.login_user("foo", "bar")
      assert not result
      
  def test_can_only_cache_each_user_once(reset_cache):
      add_default_user()
      with pytest.raises(Exception, match=r"user aleady exists"):
          get_user_cache().add_user(UserDetails(**{"key":"foo", "password":"bar"}))
  
  def test_users_exists_login_succeed(reset_cache):
      add_default_user()
      app = make_special_app()
      result = app.login_user("foo", "bar")
      assert result
  ```



- 유지 보수성을 높이는 리팩터링 방법

  - private 또는 protected 메서드를 직접 테스트하지 않는다.
    - 이들은 보통 특정한 이유로 메서드에 대한 접근을 제한하는 용도로 사용한다.
    - 이는 구현 세부 사항을 숨겨 나중에 구현이 변경되더라도 외부에서 보이는 동작은 바뀌지 않도록 하기 위함이다.
    - private 메서드를 테스트하는 것은 시스템 내부의 약속이나 규칙을 테스트하는 것과 같다.
    - 테스트 할 때는 외부의 규칙만 신경쓰면 된다.
    - private 메서드를 테스트하는 것은 내부적으로 어떤 동작을 발생시킬지 몰라 전체 코드의 동작을 테스트하는 것에 영향을 줄 수 있다.
    - private 메서드는 홀로 존재하지 않으며, 결국에는 이를 호출하는 public 메서드가 있고, 그렇지 않더라도 실행의 연결 고리 중에는 반드시 어딘가에 public 메서드가 있다.
    - 즉, private 메서드는 항상 외부 인터페이스로 시작하는 더 큰 작업의 일부이다.
    - 따라서 private 메서드를 보면 시스템 내에서 이 메서드를 호출하는 public 메서드나 기능을 찾아야한다.
    - private 메서드가 제대로 동작한다고 해도, 외부 인터페이스(public 메서드)에서 이를 잘못 사용하고 있으면 시스템 전체가 제대로 동작하지 않을 수 있다.
    - 결국 중요한 것은 외부 동작(public 메서드)이 올바르게 작동하는지 확인하는 것이다.
    - public 메서드로 private 메서드를 간접적으로 테스트하는 것이 더 효과적이다. 
    - 테스트는 외부에서 관찰할수 있는 동작을 검증해야한다.
  - 메서드를 public으로 만들기
    - 이 방법이 객체 지향 원칙에 어긋나는 것처럼 보일 수 있지만, 항상 그런 것은 아니다.
    - 어떤 메서드를 테스트하고 싶다는 것은 그 메서드가 일정하게 동작하거나 역할이 중요하다는 의미일 수 있다.
    - 메서드를 public으로 만들면 이를 명확하게 드러내는 것이다.
    - 반면에 private으로 두면 나중에 그 코드를 유지 보수할 때 해당 private 메서드를 사용하는 코드는 걱정할 필요 없이 private 메서드의 구현부를 마음대로 변경할 수 있다.
  - 메서드를 새로운 클래스나 모듈로 분리하기
    - 메서드에 독립적으로 동작할 수 있는 로직이 많이 포함되어 있거나, 해당 메서드와 관련된 특정 상태 값을 사용한다면 메서드를 시스템 내에서 특정 역할을 하는 새로운 클래스나 모듈로 분리하는 것이 좋다.
    - 이렇게 하면 그 클래스만 따로 테스트할 수 있다.
  - Stateless한 private 메서드를 public이나 static 메서드로 만들기
    - 메서드가 stateless하다면 이 기능을 지원하는 언어에서는 이를 static으로 변경하는 것이 좋다.
    - 이렇게 하면 테스트하기가 훨씬 쉽고 메서드 이름으로 유틸리티 메서드라는 점을 더 명확히 드러낼 수 있다.

  - 테스트에서도 DRY 원칙을 고수해야한다.
    - 단위 테스트에서 중복은 프로덕션 코드에서의 중복만큼이나 해롭다.
    - 헬퍼 함수를 사용하면 테스트에서 중복되는 부분을 줄일 수 있다.
    - 다만, 중복을 제거하는 것이 지나치면 가독성을 해칠 수도 있다.

  - 초기화 함수를 사용을 지양해야한다.
    - 테스트 전에 한 번씩 실행되는 `beforeEach()` 함수(초기화 함수)는 중복을 제거하려는 목적으로 자주 사용되지만, 이 보다는 헬퍼 함수를 사용하는 것이 더 나을 수 있다.
    - 초기화 함수는 잘못 사용되기 쉬워 개발자가 이를 원래 의도와는 다르게 사용할 가능성이 높아, 테스트 유지 보수가 어려워질 수 있기 때문이다.
  - 초기화 함수는 아래와 같은 조건을 만족해야한다.
    - 일부 테스트에서만 사용하는 객체를 초기화 함수에서 초기화하면 안 된다.
    - 길고 이해하기 어려운 초기화 코드를 작성하면 안 된다. 
    - 초기화 함수 내에서 목이나 가짜 객체를 만들어선 안 된다.
    - 초기화 함수는 매개 변수나 반환 값을 가져서는 안 된다.
    - 초기화 함수는 값을 반환하는 팩터리 매서드로 사용해선 안 된다.
    - 초기화 함수는 모든 테스트에 동일한 초기화 작업을 적용해야 하므로 특정 상황에 맞춘 세밀한 조정 로직이 들어가선 안 된다.
  - 매개 변수화된 테스트로 중복 코드를 제거한다.
    - 초기화 함수를 사용하지 않고 코드를 전개할 수 있는 다른 좋은 방법은 모든 테스트가 비슷하게 작성되었다는 가정하에 매개 변수화된 테스트를 사용하는 것이다.
    - 매개 변수화 패턴은 원래 초기화 함수에 있어야 할 설정을 각 테스트의 준비 단계로 옮길 수 있다.



- 과잉 명세된 테스트
  - 과잉 명세된 테스트는 단순히 코드의 외부 동작을 확인하는 것이 아니라 코드 내부가 어떻게 구현되어야 하는지까지 검증하는 테스트를 의미한다.
    - 단순히 관찰 가능한 동작(종료점)이 올바른지 확인하는 것을 넘어서 코드 내부의 구현 세부 사항까지 확인한다.
    - 예를 들어 메서드의 내부 로직이나 특정 상태 변화를 검증하는 테스트가 이에 해당한다.
    - 이는 테스트가 지나치게 구체적이고 복잡해서 코드를 변경할 때 테스트를 자주 수정해야 하는 문제가 생길 수 있다.
  - 아래는 단위 테스트가 과잉 명세되었다고 볼 수 있는 조건이다.
    - 테스트가 객체의 내부 상태만 검증한다.
    - 테스트가 목을 여러 개 만들어 사용한다.
    - 테스트가 스텁을 목처럼 사용한다.
    - 테스트가 필요하지 않은데도 특정 실행 순서나 정확한 문자열 비교를 포함한다.



- 목을 사용한 내부 동작 과잉 명세

  - 작업 단위의 종료점을 확인하는 대신 클래스나 모듈의 내부 함수가 호출되었는지만 검증하는 것이다.
    - 예를 들어 아래 테스트 코드에서는 종료점을 검증하지 않으며, 내부 메서드를 호출하는지만 확인한다.
    - 이는 아무 의미 없는 테스트이다.

  ```python
  class PasswordVerifier:
      def __init__(self, rules: list):
          self._rules = rules
      
      def verify(self, value):
          failed = self._find_failed_rules(value)
          if len(failed) == 0:
              return True
          return False
      
      # 내부 메서드
      def _find_failed_rules(self, value):
          return list(filter(lambda result: not result, map(lambda rule: rule(value), self._rules)))
      
      
  def test_check_failed_rules_is_called(mocker):
      verifier = PasswordVerifier([])
      failed_mock = Mock()
      failed_mock.return_value=[]
      verifier._find_failed_rules = failed_mock
      verifier.verify("foo")
      failed_mock.assert_called()
  ```

  - 테스트는 내부 메서드에 신경 쓸 필요가 없다.
    - `_find_failed_rules`메서드와 같이 값을 반환하는 메서드는 모의 함수로 만들지 않는 것이 좋은데, 이는 메서드 호출 자체는 종료점을 나타내지 않기 때문이다.
    - 위 코드에서 종료점은 `verify()` 메서드가 반환하는 값이며, 내부 메서드가 존재하는지 여부는 중요하지 않다.
    - 종료점이 아닌 protected 메서드를 모의 함수로 만들어 검증하는 것은 별다른 이점 없이 테스트 코드 내부 구현의 결합도만 올리는 행위다.
    - 메서드 내에서 클래스 내부 메서드 호출이 변경될 때마다 관련된 모든 테스트를 수정해야 하는데, 이는 바람직하지 않다.



- 결과와 순서를 지나치게 세밀하게 검증

  - 반환된 값의 순서와 구조를 지나치게 세분화하는 것은 바람직하지 않다.
    - 전체 목록괴 각 항목을 한꺼번에 검증하려고 하면 목록의 사소한 변경에도 테스트를 수정해야 하는 부담이 생긴다.
    - 한 번에 모든 것을 검증하려고 하지 말고, 검증을 여러 작은 검증 구문으로 나누어 각각의 측면을 명확하게 확인하는 것이 좋다.

  - 예를 들어 아래와 같은 코드를 테스트하려고 한다.

  ```python
  class PasswordVerifier:
      def __init__(self, rules: list):
          self._rules = rules
      
      def verify(self, values: list[str]) -> list[Result]:
          failed_results = list(map(self._check_single_input, values))
          return failed_results
      
      def _check_single_input(self, value: str) -> Result:
          failed = self._find_failed_rules(value)
          return Result(result=len(failed)==0, input_=value)
      
      def find_result_for(self, results: list[Result], value: str) -> bool:
          found_result = None
          for result in results:
              if result.input_ == value:
                  found_result = result
                  break
          return found_result.result if found_result else False
      
      def _find_failed_rules(self, value: str):
          return list(filter(lambda result: not result, map(lambda rule: rule(value), self._rules)))
      
      def _find_failed_rules(self, value: str):
          return list(filter(lambda result: not result, map(lambda rule: rule(value), self._rules)))
  ```

  - 아래와 같이 결과의 순서와 구조를 단일 검증문을 이용하여 확인하도록 테스트 코드를 작성한다.
    - 아래 테스트는 결과값뿐만 아니라 결과의 순서와 구조까지도 검증한다.
    - 즉, 한 번에 너무 많은 것을 검증한다.
    - `results`의 배열 길이가 변경되거나, 각 객체에 속성이 추가되거나 삭제되거나, 결과의 순서가 변경되면 테스트도 함께 변경해줘야한다.
    - 심지에 테스트에서 해당 속성을 사용하지 않더라도 속성이 추가되거나 삭제되면 테스트도 변경해야한다.

  ```python
  def test_overspecify_order_and_schema():
      verifier = PasswordVerifier([lambda x: "abc" in x])
      results = verifier.verify(["a", "ab", "abc", "abcd"])
      assert results == [
          Result(result=False, input_='a'), 
          Result(result=False, input_='ab'), 
          Result(result=True, input_='abc'), 
          Result(result=True, input_='abcd')
      ]
  ```

  - 구조는 무시하고 순서와 결과만 확인하도록 변경하면 아래와 같다.
    - 이 코드 역시 결과 값의 순서가 바뀌면 여전히 문제가 될 수 있다.

  ```python
  def test_overspecify_order_and_schema():
      verifier = PasswordVerifier([lambda x: "abc" in x])
      results = verifier.verify(["a", "ab", "abc", "abcd"])
      assert len(results) == 4
      assert results[0].result == False
      assert results[1].result == False
      assert results[2].result == True
      assert results[3].result == True
  ```

  - 순서가 그다지 중요하지 않다면 결과 값에 특정 값이 포함되어 있는지만 확인하면 된다.

  ```python
  def test_overspecify_order_and_schema():
      verifier = PasswordVerifier([lambda x: "abc" in x])
      results = verifier.verify(["a", "ab", "abc", "abcd"])
      assert len(results) == 4
      assert verifier.find_result_for(results, "a") == False
      assert verifier.find_result_for(results, "ab") == False
      assert verifier.find_result_for(results, "abc") == True
      assert verifier.find_result_for(results, "abcd") == True
  ```

  - 단위 테스트에서 반환값이나 속성에 대해 하드코딩된 문자열을 사용하여 검증하는 것 역시 쉽게 저지를 수 있는 실수이다.
    - 사실 필요한 것은 문자열으 특정 부분만 확인하는 것이라면 문자열이 완벽히 일치하는지보다는 필요한 내용의 포함 유무를 확인 가능한지 생각해봐야한다.
    - 문자열이 정확히 일치하는지 확인하는 것 보다는 원하는 대로 문자열이 구성되었는지를 확인하는 것이 중요하다.
    - 문자열이 정확히 일치하는지 확인하는 경우, 띄어쓰기, 쉼표, 마침표 하나에도 테스트가 실패할 수 있다.





# 가독성

- 단위 테스트 이름 짓기
  - 테스트 이름이나 테스트가 포함된 파일 구조에는 아래 세 가지 중요한 정보가 포함되어야 한다.
    - 작업 단위의 진입점(혹은 현재 테스트 중인 기능 이름)
    - 진입점을 테스트하는 상황
    - 작업 단위의 종료점이 실행해야하는 동작
  - 작업 단위나 진입점의 이름은 테스트를 읽는 사람이 코드의 기능 범위를 쉽게 알 수 있게 해준다.
    - 테스트 이름의 첫 부분에 이를 포함하면 테스트 파일에서 쉽게 탐색할 수 있다.
    - 예를 들어 "진입점 x를 null 값으로 호출하면 y를 실행한다." 형식으로 작성한다.
  - 작업 단위의 종료점에서 무엇을 해야하거나 반환해야 하는지, 또는 어떻게 동작해야 하는지 알기 쉬운 말로 설명해야한다.
    - 예를 들어 "진입점 x를 null 값으로 호출하면, 작업 단위의 종료점에서 y가 수행되어야 한다." 형식으로 작성한다.
  - 테스트를 실패할 때 표시되는 정보가 보통 테스트의 이름이라는 것도 단위 테스트의 중요성을 더한다.
    - 테스트가 실패했을 때, 실패한 테스트의 이름만 보고도 실패 원인을 이해할 수 있다.
    - 이렇게 하면 디버깅 시간과 코드를 읽는 시간을 훨씬 절약할 수 있다.
  - 좋은 테스트 이름은 문서 역할도 할 수 있다.
    - 테스트 이름만으로 시스템이나 컴포넌트의 동작을 이해할 수 있다면 좋은 이름이다.



- 매직 넘버와 변수명

  - 매직 넘버
    - 하드코딩된 값, 기록에 남지 않은 값, 명확하게 이해되지 않는 상수나 변수를 의미한다.
    - 매직이라는 표현은 마치 마법처럼 이 값들이 작동하지만 왜 그렇게 작동하는지 알 수 없다는 의미로 쓰인다.
    - 예를 들어 아래 테스트는 매직 넘버를 포함하고 있다.

  ```python
  def test_on_weekends_raise_exceptions():
      with pytest.raises(Exception, match=r"It's the weekend!"):
          verify_password("foobar123", [], 0)
  ```

  - 위 코드의 문제점
    - 0은 여러 가지 의미로 해석될 수 있으며, 코드를 읽는 사람이 이 값이 일요일을 나타낸다는 것을 이해하려면 코드를 찾아봐야한다.
    - 코드를 읽는 사람 입장에서 빈 배열이 무엇을 뜻하는지 알려면 역시 코드를 봐야한다.
    - "foobar123"은 비밀번호처럼 보이긴 하지만 코드를 읽는 사람 입장에서는 왜 이 특정한 값을 사용했는지 의문이 들 것이다.
  - 매직 넘버 문제를 수정하면 아래와 같다.
    - 비밀번호 값은 "아무거나"라는 의미를 전달하기 위해 "anything"으로 변경한다.
    - 나머지 두 개의 매직 넘버 역시 변수에 할당해 의미를 분명히 한다.

  ```python
  def test_on_weekends_raise_exceptions():
      NO_RULES = []
      SUNDAY = 0
      with pytest.raises(Exception, match=r"It's the weekend!"):
          verify_password("anything", NO_RULES, SUNDAY)
  ```



- 검증과 실행 단계 분리

  - 가독성을 높이려면 검증 단계와 실행 단계를 한 문장에 넣지 말아야 한다.
    - 아래 예시는 검증 단계와 실행 단계가 한 문장에 들어가 있다.
    - 이로인해 테스트를 읽고 이해하기거 어렵다.
    - 또한 디버깅도 어렵다.

  ```python
  assert "fake reason" in verifier.verify("anything")[0]
  ```

  - 아래와 같이 검증 단계와 실행 단계를 분리하는 것이 좋다.
    - 디버깅을 위해 함수 호출 후 값을 확인하고 싶을때에도 훨씬 편하다.

  ```python
  result = verifier.verify("anything")
  assert "fake reason" in result[0]
  ```



- 초기화 설정 및 설정 해제

  - 단위 테스트에서 초기화(setup)와 해제(teardown) 함수는 남용되기 쉽다.
    - 이는 테스트에 필요한 초기 설정이나 테스트가 끝난 후 목을 다시 초기화하는 등 해제 작업의 가독성을 떨어뜨린다.
    - 특히 초기화 함수에서는 이 현상이 더욱 두드러진다.

  - 예를 들어 아래 테스트는 초기화 함수를 사용하여 목을 설정한다.
    - `mock_logger` fixture에서 목을 초기화하고, 테스트 함수에서 목을 사용한다.
    - 만약 파일에 이러한 테스트가 수십 개 이상 있다고 가정하면, 목을 어디서 초기화시켰는지 찾기가 매우 힘들어진다.
    - 또한 테스트에서 사용되는 상태가 많아질수록, 초기화 함수는 모든 테스트에서 사용되는 상태를 처리하는 곳이 되어 버린다.

  ```python
  @pytest.fixture
  def mock_logger():
      yield create_autospec(ComplicatedLogger)
  
  def test_verify_with_logger_calls_logger_with_pass(mock_logger):
      verifier = PasswordVerifier([], mock_logger)
      verifier.verify("anything")
      mock_logger.info.assert_called_with("PASSED", "verify")
  ```

  - 목은 테스트 내에서 직접 초기화하고 모든 기댓값을 설정하는 것이 훨씬 더 가독성이 좋다.
    - 아래와 같이 테스트 내에서 목을 초기화하도록 변경한다.

  ```python
  def test_verify_with_logger_calls_logger_with_pass():
      mock_logger = create_autospec(ComplicatedLogger)
      verifier = PasswordVerifier([], mock_logger)
      verifier.verify("anything")
      mock_logger.info.assert_called_with("PASSED", "verify")
  ```

  - 만약 유지 보수성을 좀 더 생각한다면 일종의 팩토리 함수를 만들어 목을 생성하고 이를 여러 곳에서 사용할 수 있도록 리팩터링할 수 있다.
    - 이렇게 하면 초기화 함수 대신 여러 테스트에서 동일한 팩토리 함수를 사용 할 수 있다.

  ```python
  def make_mock_logger():
      yield create_autospec(ComplicatedLogger)
  
  def test_verify_with_logger_calls_logger_with_pass():
      mock_logger = make_mock_logger()
      verifier = PasswordVerifier([], mock_logger)
      verifier.verify("anything")
      mock_logger.info.assert_called_with("PASSED", "verify")
  ```





# 더 나은 테스트 전략 수립

- 일반적인 테스트 유형과 수준

  - 단위 테스트는 매우 중요하지만, 여러 테스트 유형 중 하나일 뿐이다.

  - 일반적인 소프트웨어 테스트의 level은 아래와 같이 구분할 수 있다.

    - E2E/UI 통합 테스트
    - E2E/UI 격리 테스트
    - 시스템 외부에서 실행하는 API 테스트
    - 통합 테스트(인메모리)
    - 컴포넌트 테스트(인메모리)
    - 단위 테스트(인메모리)

  - 위 구분에서 위에 있는 것일수록 테스트 수준이 높은 것이다.

    - 테스트 수준이 높을수록 실제 의존성을 더 많이 사용하게 되어 전체 시스템 정확성에 대한 신뢰도는 높다.
    - 그러나 테스트는 더 느려지고 불안정해질 수 있는 단점이 있다.

  - 서비스 도메인에 따라 테스트 유형과 수준이 다를 수 있다.

    - 테스트를 작성할 때 고려해야 할 여러 기준을 설정하고 그 기준에 따라 어떤 테스트 유형을 선택할지 판단해야한다.

  - 테스트 평가 기준

    - 복잡성: 테스트를 작성하고 읽고 디버깅하는 과정이 얼마나 복잡한지 평가한다.
    - 불안정성: 다른 팀의 코드, 네트워크, 데이터베이스, 설정 권한 등 제어할 수 없는 요소 때문에 테스트가 실패할 가능성을 평가한다.
    - 신뢰도: 테스트가 통과할 때 개발자에게 얼마나 큰 신뢰를 주는지 평가하는 기준이다.
    - 유지 보수성: 테스트를 얼마나 자주 변경해야 하며, 변경이 얼마나 쉬운지 평가하는 기준이다.
    - 실행 속도: 테스트가 얼마나 빨리 끝나는지 평가하는 기준이다.

  - 단위 테스트와 컴포넌트

    - 단위 테스트와 컴포넌트 테스트는 지금까지 다룬 테스트 유형이다.
    - 이 둘은 같은 범주에 속하지만 컴포넌트 테스트는 단위 테스트에 비해 더 많은 함수나 클래스, 컴포넌트를 작업 단위 내에 포함할 수 있다는 점에서 차이가 있다.
    - 즉 컴포넌트 테스트는 진입점과 종료점 사이에 더 많은 요소를 포함한다.

    - 단위 테스트와 컴포넌트 테스트의 평가는 아래와 같다.

  | 기준        | 점수 | 비고                                                         |
  | ----------- | ---- | ------------------------------------------------------------ |
  | 복잡성      | 1/5  | 테스트의 범위가 작고 테스트 내에서 모든 것을 제어할 수 있다. |
  | 불안정성    | 1/5  | 테스트 내 모든 것을 제어할 수 있다.                          |
  | 신뢰도      | 1/5  | 단위 테스트가 통과해도, 시스템이 제대로 동작하는지 확신할 수는 없다. |
  | 유지 보수성 | 5/5  | 모든 테스트 유형 중에서 가장 유지 보수가 쉽다.               |
  | 실행 속도   | 5/5  | 외부 의존성 없이 모든 것이 메모리에서 실행되기 때문에 빠르게 실행된다. |

  - 통합 테스트
    - 일반적인 단위 테스트와 거의 비슷하게 보이지만, 일부 의존성은 스텁으로 대체할 수 없다.
    - 예를 들어 실제 환경 설정, DB, 파일 시스템 등을 사용하는 경우다.
    - 그러나 메모리 내에서 시스템 객체를 생성하고, 그 객체의 특정 기능을 직접 호출하여 테스트를 진행한다는 점에서 테스트를 실행하는 방식은 단위 테스트와 유사하다.

  | 기준        | 점수  | 비고                                                         |
  | ----------- | ----- | ------------------------------------------------------------ |
  | 불안정성    | 2~3/5 | 실제 의존성 수에 따라 불안정성이 달라질 수 있다.             |
  | 신뢰도      | 2~3/5 | 통합 테스트가 통과하면 DB나 설정 파일처럼 제어할 수 없는 요소를 사용하는 코드가 제대로 동작한다는 것을 확인할 수 있다. |
  | 유지 보수성 | 3~4/5 | 외부 의존성을 사용하기에 단위 테스트보다 복잡하다.           |
  | 실행 속도   | 3~4/5 | 파일 시스템, 네트워크, DB, 스레드 등에 대한 의존성 때문에 단위 테스트보다 느릴 수 있다. |

  - API 테스트
    - 이 단계부터는 애플리케이션을 최소한 일부라도 배포하고 네트워크를 통해 호출해야 한다.
    - 단위 테스트나 컴포넌트 테스트. 통합 테스트와 달리 API 테스트는 메모리 내부에서 하는 것이 아니라 작업 프로세스의 외부에서하는 테스트다.
    - 이제 더 이상 테스트용 가짜 코드를 만드는 행위를 하지 않는다.
    - 다시 말해 네트워크와 네트워크 서비스의 배포라는 새로운 의존성이 추가된다.

  | 기준        | 점수  | 비고                                                         |
  | ----------- | ----- | ------------------------------------------------------------ |
  | 불안정성    | 3~4/5 | 네트워크를 사용하여 불안정성이 더 높아진다.                  |
  | 신뢰도      | 3~4/5 | 통합 테스트보다 더 큰 신뢰도를 가진다.                       |
  | 유지 보수성 | 2~3/5 | 네트워크는 환경 설정을 더 복잡하게 만들며, 테스트를 변경하거나 API를 추가하거나 변경할 때 더 세심하게 주의를 기울여서 작업해야한다. |
  | 실행 속도   | 2~3/5 | 네트워크로 인해 테스트 속도가 상당히 느려진다.               |

  - E2E/UI 격리 테스트
    - 사용자 관점에서 애플리케이션을 테스트하는 수준이다.
    - "격리"라는 표현을 사용한 이유는 테스트하는 애플리케이션이나 서비스만 대상으로하고 이 애플리케이션에 필요할 수 있는 외부 애플리케이션이나 서비스는 배포하지 않고 테스트하기 때문이다.
    - 이러한 테스트에서는 타사의 인증 절차나 동일 서버에서 배포해야 하는 다른 애플리케이션의 API, 테스트 대상 애플리케이션에 속하지 않는 모든 코드를 가짜로 만들어 사용한다.

  | 기준        | 점수  | 비고                                                         |
  | ----------- | ----- | ------------------------------------------------------------ |
  | 불안정성    | 4/5   | 사용하는 의존성이 많아 불안정성이 커진다.                    |
  | 신뢰도      | 4/5   | 이 유형의 테스트가 통과하면 애플리케이션에 대한 신뢰도가 크게 상승한다. |
  | 유지 보수성 | 1~2/5 | 의존성이 더 많이 추가되어 설정이 복잡해지고, 테스트를 변경하거나 작업 흐름을 추가해야 하거나 변경할 때 더욱 주의를 기울여야한다. |
  | 실행 속도   | 1~2/5 | 로그인이나 캐싱, 여러 페이지 탐색 등 UI를 살펴보는 과정에서 속도가 매우 느려질 수 있다. |

  - E2E/UI 통합 테스트
    - 이 수준에서는 가짜인 것이 없다.
    - 실제 운영 환경에 가장 가까운 상태에서 테스를 수행한다.

  | 기준        | 점수 | 비고                                                     |
  | :---------- | ---- | -------------------------------------------------------- |
  | 불안정성    | 5/5  | 다양한 이유로 테스트가 실패할 수 있다.                   |
  | 신뢰도      | 5/5  | 가장 높은 신뢰도를 준다.                                 |
  | 유지 보수성 | 1/5  | 의존성이 많고 테스트 진행을 위한 작업 흐름이 길다.       |
  | 실행 속도   | 1/5  | UI와 실제 의존성을 사용하기에 테스트 속도가 매우 느리다. |





## 각 테스트 수준별 안티 패턴

- E2E 테스트만 사용하는 안티 패턴
  - E2E 테스트만 사용할 경우 테스트는 매우 느리고, 유지 보수하기 어렵고, 디버깅이 힘들며, 불안정성이 높다.
    - 또한 E2E 테스트를 추가할 드는 노력 대비 얻는 신뢰도의 가치는 시간이 흐름에 따라 하락한다.
    - 예를 들어 E2E 테스트를 처음 작성하면 테스트를 통과할 때 큰 신뢰감을 얻을 수 있다.
    - 그러나 기능이 추가되고 새로운 E2E 테스트를 작성하더라도, 새로운 E2E 테스트는 첫 번째 E2E 테스트만큼의 신뢰감을 얻게 해주진 않는다.
    - 그러나 디버깅이나 코드 수정, 코드 읽기, 코드 실행에 드는 비용은 첫 번째 테스트와 거의 차이가 없다.
    - 즉 첫 번째 테스트에서 얻을 수 있었던 가치 대비 두 번째 테스트에서 얻는 가치가 상대적으로 너무 작다.
    - 조금의 추가 신뢰도를 얻기 위해 많은 추가 작업이 발생하므로 E2E 테스트는 효율이 점차 떨어진다.
  - E2E 테스트의 또 다른 문제는 불안정성이 높아 여러 원인으로 실패할 수 있는데, 이 중에는 실제 테스트와 관련 없는 이유로 실패하는 경우도 있다는 것이다.
    - 따라서 조직 내에는 원인을 분석하고 그 원인이 중요한 문제인지 사소한 오류인지 구분해 내는 사람들이 필요해지며 보통 이러한 역할은 QA 팀이 맡는다.
    - 이들은 반복적인 일을 하는 경우가 대부분이며, 많은 스트레스와 압박 속에서 일을 하고, 좋은 평가를 받기도 힘들어 단기간에 번아웃이 찾아온다.
    - 이를 해결하기 위해서는 견고하게 설계된 자동화 테스트 파이프라인을 구축하는 것이다.
    - 이렇게 하면 불안정한 테스트가 있더라도 빌드가 성공했는지 자동으로 판한달 수 있다.
  - E2E는 책임 전가를 부른다.
    - E2E는 테스트를 유지하고 모니터링하는 책임을 QA 팀에게 전가한다.
    - 이는 조직 내 개발자들이 빌드 결과에 관심을 가지지 않거나, 그 결과를 알지 못할 수도 있다는 것을 의믜한다.
    - 개발자들은 이러한 테스트에 대한 책임감이나 관심을 가지지 않기에 테스트를 본인의 소유물로 생각하지 않는다.
    - 이는 많은 오해를 낳을 수 있으며 제품의 품질까지 저하시킬 수 있다.
    - 한쪽은 자신이 한 일의 결과에 무관심하고, 다른 쪽은 문제 원인을 제어할 수 없는 상태에서 그 결과를 감당해야 하기 때문이다.
  - E2E 테스트 자체가 안티패턴이라는 것이 아니다.
    - E2E 테스트만 사용하는 테스트 방식이 안티패턴이다.
    - E2E 테스트는 애플리케이션이 제대로 작동한다는 확신과 신뢰감을 준다는 점에서 꼭 필요하다.
    - 사용자 관점에서 시스템 전체, 즉 모든 하위 시스템과 구성 요소를 통합해서 테스트하기 때문에 유닛 테스트와는 다른 수준의 신뢰를 준다.
  - E2E 테스트를 완전히 피하지는 말되, 테스트 수를 최소화하기는 해야한다.



- 저수준 테스트만 사용하느 안티 패턴
  - 유닛 테스는 애플리케이션이 하나의 통합된 시스템으로 제대로 작동하는지에 대한 신뢰는 주지 못한다.
    - 저수준 테스트 안티 패턴은 대부분 자동화 테스트가 유닛 테스트나 컴포넌트 테스트 같은 저수준 테스트에 집중되어 있다.
    - 이 방식의 가장 큰 문제는 이러한 테스트가 통과하더라도 애플리케이션이 제대로 작동한다고 확신하기에는 신뢰도가 충분하지 않다는 것이다.
    - 결국 테스트를 실행한 후에도 배포하기 전에 정말로 내보내도 괜찮은지 확인하려고 계속 수동 디버깅과 테스트를 수행한다.
  - 이 안티 패턴은 주로 아래 상황에 발생한다.
    - 개발자가 저수준 테스트만 작성하는 데 익숙한 경우.
    - 고수준 테스트는 QA팀이 해야 할 일이라고 생각하는 경우.



- 저수준 테스트와 고수준 테스트의 단절
  - 테스트가 단절되어 있으면 예상치 못한 오류나 비효율성이 따라오게 된다.
    - 여러 테스트가 여러 수준에서 반복적으로 생성된다.
    - 저수준 테스트를 진행하는 사람과 고수준 테스를 작성하는 사람이 다르다보니 서로가 작성한 테스트에는 관심이 없고, 서로 다른 파이프라인에서 각기 다른 유형의 테스트가 실행될 가능성이 높다.
    - 하나의 파이프라인이 실패하면 다른 테스트를 작성한 쪽은 그 사실을 알지 못하거나 알아도 그다지 관심이 없을 수 있다.
    - 그러다 보니 상위 수준과 하위 수준 테스트에서 발생할 수 있는 문제점이 모두 드러난다.
    - 상위 수준에서는 긴 테스트 시간, 어려운 유지 보수, 빌드 분석 필요, 불안정성 등이 문제가 되고, 하위 수준에서는 신뢰도가 문제가 된다.
    - 게다가 실행 속도가 빠르다는 저수준 테스트의 속도 이점을 제대로 활용하지 못하는데, 이는 상위 수준에서 결국 테스트가 반복되기 때문이다.
    - 결국 너무 많은 테스트가 불안정하여 상위 수준에서 기대하는 신뢰도를 충분하 확보하지 못한다.
  - 이 안티 패턴은 주로 아래 상황에 발생한다.
    - 테스트 팀과 개발 팀의 서로 다른 목표와 지표, 각기 다른 업무와 파이프라인 심지어 코드 저장소까지 따로 운영할 때 자주 일어난다.
    - 회사 규모가 클수록 이러한 상황이 발생할 가능성은 더 높다.





## 테스트 레시피 전략

- 테스트 레시피
  - 특정 기능을 어떻게 테스트할지에 대한 간단한 계획이다.
    - 잘 만든 테스트 레시피는 각 시나리오에 어떤 테스트 수준이 적합한지 판단하는 데 사용할 수 있다.
    - 테스트 레시피는 기능이 제대로 작동한다는 신뢰감을 주는 시나리오 목록을 의미한다.
  - 이 계획에는 아래와 같은 것들이 포함된다.
    - 주요 시나리오(해피 패스).
    - 예외적인 상황이나 극단적인 경우(에지 케이스)
  - 테스트 레시피 작성 방법
    - 테스트 레시피를 작성할 때는 최소한 두 사람이 함께 작업하면 좋다.
    - 한 면은 개발자 관점에서, 다른 한 명은 테스트 관점에서 접근하는 것이 이상적이다.
    - 조직 내 테스트 팀이 없을 때는 개발자 둘이서 진행하되, 한 명은 시니어 개발자면 좋다.
    - 테스트 레시피를 작성하기 가장 좋은 시점은 기능 작업을 시작하기 직전이다.
    - 이렇게 하면 테스트 레시피가 해당 기능의 "완료" 기준에 포함되며, 전체 테스트 레시피가 통과해야 기능이 완성되었다고 볼 수 있다.
    - 테스트 시나리오가 새로 추가되거나 없어질 수 있기 때문에 시간이 지나면서 레시피가 바뀔 수는 있다.
    - 레시피는 고정된 산출물이 아니라 소프트웨어 개발의 다른 모든 것처럼 계속해서 발전을 거듭하는 작업물이다.
    - 일반적으로 저수준 테스트와 고수준 테스트 간에는 1:5 또는 1:10 비율을 유지하면 좋다.
    - 예를 들어 단위 테스트가 100개 있다면, 통합 테스트는 10개, E2E테스트는 한 개 정도면 충분하다.
  - 테스트 레시피를 너무 형식적으로 다룰 필요는 없다.
    - 테스트 레시피는 반드시 따라야 하는 약속도 아니고, 테스트 케이스를 정리해 놓은 공식 문서도 아니다.
    - 공적인 자리에서 발표 보고서로 사용하거나, 무언가를 약속하는 문서로 사용해서는 안 된다.
    - 기본적으로 레시피는 간단한 시나리오 5~20줄 정도를 자동화된 방식으로 어떤 수준에서 테스트할 것인지 간략하게 설명한 목록일 뿐이다.
    - 이 목록은 필요에 따라 추가, 수정 및 삭제를 할 수 있는 주석 정도로 생각하면 된다.
  - 사용자 프로필 기능에 대한 테스트 레시피 예시
    - E2E: 로그인, 프로필 화면으로 이동, 이메일 업데이트, 로그아웃, 새 이메일로 다시 로그인, 프로필 화면 업데이트 확인.
    - API: 더 복잡한 데이터를 사용하여 프로필 업데이트 API 호출
    - 단위 테스트1: 잘못된 이메일로 프로필 업데이트 로직 확인
    - 단위 테스트2: 동일한 이메일로 프로필 업데이터 로직 확인
    - 단위 테스트3: 프로필 데이터 변환 및 데이터 복원
  - 테스트 레시피를 사용하는 시점
    - 기능이나 사용자 스토리를 작업하기 직전에는 팀 동료와 함께 어떤 시나리오를 테스트할지 구상해 보는 것이 좋다.
    - 그런 다음 그 시나리오를 어느 수준에서 테스트하면 가장 적합할지 결정한다.
    - 보통 5~15분 정도 대화를 하면 충분히 많은 것을 결정할 수 있고, 이후 코딩을 시작하면서 테스트도 함께 작성하게 된다.
    - 조직 내 자동화나 QA 역할이 있을 때는 개발자가 저수준 테스트를 작성하고 QA가 고수준 테스트를 작성하는데, 이 과정은 기능을 개발하는 것과 동시에 진행된다.
    - 둘은 동시에 작업하며, 한 사람이 작업을 끝낼 때까지 다른 사람이 기다리지 않고 각자 테스트를 작성한다.



- 테스트 레시피 작성 규칙

  - 속도
    - 어떤 기능이 제대로 동작하는지에 대한 신뢰도를 얻는 방법이 E2E 밖에 없다면 어쩔 수 없다.
    - 그것이 아니라면 저수준 테스트를 우선시하는 것이 좋다.
  - 신뢰도
    - 모든 테스트가 통과되었을 때 "이 기능은 잘 동작한다고 확신"한다면 레시피는 완성된 것이다.
    - 그렇지 않다면 그런 확신을 줄 수 있는 테스트 시나리오를 더 만들어야 한다.
  - 수정
    - 개발 하면서 테스트를 추가하거나 삭제해도 괜찮다.
    - 단 레시피를 함께 작성한 사람들에게는 꼭 알려야 한다.
  - 적절한 타이밍
    - 코딩을 시작하기 직전에 누가 코딩할지 정해졌을 때 이 레시피를 작성한다.
  - 페어 프로그래밍
    - 가능하다면 혼자 작성하지 말고 다른 사람과 함께 작성한다.
    - 사람마다 생각하는 방식이 다르기 때문에 시나리오를 논의하면서 서로의 테스트 아이디어와 관점을 공유하는 것이 중요하다.
  - 기존 기능의 테스트를 중복하지 말 것
    - 현재 시나리오를 이미 다른 테스트에서 테스트한 적이 있다면 같은 수준에서 이 시나리오를 다시 테스트할 필요는 없다.

  - 다른 계층에서 테스트를 중복해서 작성하지 말 것
    - 동일한 시나리오를 여러 테스트 수준에서 반복하지 말아야 한다.
    - 예를 들어 E2E 테스트에서 로그인이 잘 되는 것을 확인했다면, 저수준 테스트에서는 이 시나리오를 살짝만 바꾼 부분만 확인하면 된다.
  - 더 많이, 더 빠르게
    - 좋은 기준은 테스트 수준 간 비율을 최소 1:5로 맞추는 것이다.
    - 하나의 E2E 테스트에 대해 저수준 테스트를 다섯 개  이상 작성하는 것을 의미한다.
  - 실용성 중시
    - 모든 기능을 전부 각기 다른 테스트 수준으로 작성해야 한다고 생각할 필요는 없다.
    - 어떤 기능이나 사용자 스토리는 단위 테스트만으로 충분할 수 있고, 다른 경우에는 API 테스트느 E2E 테스트만으로도 충분할 수 있다.
    - 즁요한 점은 레시피에 있는 모드 시나리오가 통과했을 때 기능이 제대로 작동한다고 느낄 수 있어야 한다는 것이다.
    - 그렇지 않다면 속도나 유지 보수에 큰 부담을 느끼지 않는 선에서 시나리오를 다른 테스트 수준으로 작성해 보는 것이 좋다.



- 배포 파이프라인 관리

  - 여러 조직에서 다양한 테스트 작업을 통합 자동화 파이프라인의 일부로 실행한다.
    - 여기에는 성능 테스트, 보안 테스트, 부하 테스트 등이 포함된다.
    - 이들은 배포하거나 PR을 올릴 때마다 실행된다.
    - 그러나 이러한 테스트들은 시간이 많이 소요되므로 테스트 결과를 받는 데 상당한 시간이 걸릴 수 있다.
    - 더구나 이러한 테스트에서 실패가 발생하더라도 실제로는 배포를 중단해야 할 중요한 문제가 아닐 때도 많다.
    - 그럼에도 테스트 결과가 실패로 표시되면 배포에 큰 문제가 없더라도 배포가 지연되고 작업 흐름이 끊길 수 있다.
  - 이러한 테스트는 두 가지 그룹으로 나눌 수 있다.
    - 배포 중단 테스트: 변경 사항에 문제 없는지 배포 전에 판단하는 테스트를 의미한다. 단위 테스트, E2E 테스트, 시스템 테스트, 보안 테스트 등이 이에 속하며, 성공과 실패가 명확하다.
    - 참고용 테스트: 주요 성과 지표(Key Performance Indicator, KPI)를 파악하고 지속적으로 모니터링하는 데 사용한다. 코드를 분석하고, 복잡도를 스캔하기도 하며, 고부하 성능 테스트를 하거나 장시간 실행되는 비기능적 테스트 역시 여기에 포함된다. 단순히 성공이나 실패로 나뉘지 않며, 실패하더라도 소프트웨어 배포에는 큰 영향을 주지 않는다.

  - 배포 파이프라인과 탐색 파이프라인
    - 배포 파이프라인은 배포를 결정하는 테스트에 사용한다.
    - 이 파이프라인이 통과하면 자동으로 프로덕션에 배포해도 된다는 확신을 가질 수 있어야한다.
    - 이 파이프라인의 테스트는 비교적 빠르게 실행 결과를 알려줄 수 있어야한다.
    - 배포 파이프라이느이 목적은 코드가 문제 없이 통과될 경우 배포를 진행하는 것이다.
    - 탐색 파이프라인은 참고용 테스트에 사용한다.
    - 배포 파이프라인과 병렬로 실행되지만 지속적으로 작동하며, 배포 기준에는 포함되지 않는다.
    - 이 파이프라인의 실행 결과를 기다릴 필요가 없기 때문에 테스트가 오래 걸려도 무방하다.
    - 오류가 발견되면 다음 스프린트에서 해결해야 할 적업 항목으로 추가하면 되며, 배포는 중단되거나 지연되지 않는다.
    - 탐색 파이프라인의 목적은 리팩터링해야 하는 코드가 어디인지를 찾는 것이다.
  - 테스트 계층 병렬화
    - 테스트 결과를 신속하게 얻는 것은 매우 중요하다.
    - 따라서 파이프라인의 각 단계별 결과를 빠르게 받기 위해 여러 테스트 계층을 병렬로 실행하는 것이 일반적이다.
