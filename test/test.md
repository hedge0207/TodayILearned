# Unit Test

- 단위 테스트
  - 위키피디아는 단위 테스트를 아래와 같이 정의한다.
    - 컴퓨터 프로그래밍에서 예제 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차다.
    - 즉 모든 함수와 메서드에 대한 테스트 케이스를 작성하는 절차를 말한다.
    - 이를 통해 언제라도 코드 변경으로 인한 문제가 발생할 경우, 단시간 내에 이를 파악하고 바로잡을 수 있도록 해준다.
  - 켄트 벡이 smalltalk에서 단위 테스트 개념을 도입했으며, 이 개념이 다른 프로그래밍 언어로 확산되었다.
  - 테스트를 작성할 대상은 테스트 중인 주제(subject), 시스템(system), 테스트 대상(Suite Under Test, SUT)이다.
    - 무언가를 테스트할 때 테스트하고자 하는 대상을 SUT이라 한다.
    - SUT은 테스트 중인 주제, 시스템, 테스트의 모음(suite)를 의미하며, 일부 사람들은 테스트 중인 컴포넌트(component), 클래스(class), 코드(code)를 의미하는 CUT(component, class, code under test)라는 용어를 사용하기도 한다. 
  - 단위 테스트의 "단위(unit)"의 의미
    - 단위는 시스템 내 작업 단위(unit of work) 또는 사용 사례(use case)를 의미한다.
    - 작업 단위는 함수 하나만 의미할 수도 있고, 여러 함수를 의미할 수도 있다.
    - 함수뿐 아니라 모듈이나 컴포넌트도 작업 단위가 될 수 있다.



- 진입접과 종료점

  - 작업 단위에는 시작과 끝이 있으며 이를 진입접(entry point)과 종료점(exit point)이라고 한다.
  - 작업 단위는 진입점의 호출부터 하나 이상의 종료점까지 눈에 띄는 결과가 나타날 때까지 발생하는 모든 작업을 의미한다.
    - 작업 단위에는 항상 하나의 진입점과 하나 이상의 종료점이 있다.
    - 진입점은 어떤 것이 되어도 상관 없으며 설정하기 나름이다.
  - 종료점
    - 코드가 실행되면 무언가 의미 있는 작업을 하기 마련이다.
    - 여기서 의미 있는 작업이란 단순히 값을 반환하는 것부터 시작하여 어떤 상태를 변경하거나 서드 파티 코드를 호출하는 등 뭔가 눈에 띄는 동작을 의미한다.
    - 이런 동작을 종료점이라고 부른다.
    - 종료점은 작업 단위의 최종 결과를 의미한다.
  - 진입점과 종료점 예시
    - 아래 예시에서 sum() 함수는 하나의 완전한 작업 단위이다.
    - 함수는 진입점이며 그 결과로 두 숫자의 합을 반환하기 때문에 종료점 역할도 한다.
    - 함수(작업 단위)를 실행한 동일한 위치에서 반환 값도 얻으므로 진입점이 종료점이기도 하다.

  ```python
  def sum(numbers):
      a, b = numbers.split(",")
      result = int(a) + int(b)
      return result
  ```

  - 복수의 종료점이 있는 경우
    - `sum()` 함수는 아래 두 개의 종료점을 가지고 있다.
    - 숫자의 합을 반환
    - 숫자의 합을 total에 추가하는 누적 합계를 계산

  ```python
  total = 0
  
  def sum(numbers):
      global total
      a, b = numbers.split(",")
      result = int(a) + int(b)
      total += result
      return result
  ```

  - 여러 개의 종료점이 있을 때 각 종료점은 개별적인 테스트 코드로 바꿀 수 있다.
    - 여러 개의 종료점이 있을 때 각 종료점은 실제로 코드가 수행해야 하는 중요한 작업을 의미한다.
    - 따라서 같은 작업 단위에서 나오는 서로 다른 경로나 요구 사항으로 보이기도 한다.
  - 진입점과 종료점은 테스트 코드 범위를 설정하는 데 도움을 준다.
    - 진입점은 항상 테스트가 작업 단위를 실행하는 지점이다.
    - 작업 단위에는 여러 개의 종료점이 있을 수 있으며, 각 종료점은 서로 다른 테스트 코드에서 사용할 수 있다.
    - 종료점을 기준으로 종료점마다 테스트를 만들어 분리하면 각 테스트끼리 영향을 주지 않고, 더 읽기 쉬우며, 디버깅하기도 쉽다.
  - 종료점 추가하기
    - 기존 두 개의 종료점에 숫자를 출력한다는 새로운 종료점을 추가한다.
    - 종료점이 추가된다는 것은 의미 있는 작업이 추가된다는 것이다.
    - `print()` 함수는 외부에 무언가를 기록하며, 파일에 기록될 수도, 콘솔에 기록될 수도 있다.
    - 이는 의존성 호출에 해당된다.

  ```python
  total = 0
  
  def sum(numbers):
      global total
      a, b = numbers.split(",")
      print("first_num:", a, "second_num", b)
      result = int(a) + int(b)
      total += result
      return result
  ```

  - 의존성 호출
    - 의존성은 단위 테스트 중 온전히 제어할 수 없는 것을 의미한다.
    - 그 종류는 무수히 많지만 아래와 같은 것들이 있다.
    - 파일에 무언가를 기록하는 경우.
    - 네트워크와 통신하는 경우.
    - 다른 팀이 관리하는 코드일 경우.
    - DB에 접근하는 행위일 경우.
    - 오래 걸리는 계산 작업일 경우.
  - 종료점의 유형
    - 마지막으로 살펴본 코드는 세 유형의 종료점을 가지고 있다.
    - 함수가 undefined가 아닌 값을 반환한다.
    - 함수 호출 전과 후에 상태(result) 값이 달라진다.
    - 코드의 실행 주도권이 없는 함수(print)를 호출한다.
  - 종료점의 유형에 따라 테스트 방법이 다소 다르다.
    - 반환 값이 있는 종료점은 가장 테스트하기 쉬운 유형으로, 작업 단위를 실행하여 진입점을 호출하고 실행 결과를 받아 그 값을 확인하면 된다.
    - 상태 값을 변경하는 종료점은 의도한대로 상태 값이 변경되었는지를 확인해야한다.
    - 서드 파티(실행 주도권이 없는 함수)를 호출하는 종료점은 모의 객체를 만들어 테스트 결과를 임의로 조작하여 테스트해야한다.



- 테스트 코드 작성하기

  - 이전에 살펴본 아래 코드의 테스트 코드를 작성할 것이다.
    - 세 가지 종료점의 유형중 반환 값이 있는 종료점에 대해서만 작성할 것이다.

  ```python
  total = 0
  
  def sum(numbers):
      global total
      a, b = numbers.split(",")
      print("first_num:", a, "second_num", b)
      result = int(a) + int(b)
      total += result
      return result
  ```

  - 위 코드를 테스트 하기 위한 코드의 진입점은 sum(numbers) 함수다.
    - 일반적으로 함수의 시그니처가 함수의 진입점이 된다. 
    - sum 함수는 반환 값이 있어 진입점이자 동시에 종료점이기도 하다.

  - sum 함수를 테스트하기 위한 테스트 코드 작성하기
    - 아래 코드는 SUT인 sum 함수를 호출한 후 반환된 값을 확인한다.
    - 함수의 실행 결과가 기댓값과 다르면, 오류 정보를 출력한다.
    - 또 테스트 코드는 발생하는 모든 예외를 출력하여 이후 다른 메서드의 실행에 지장이 없도록 한다(테스트 프레임워크를 사용하면 보통 프레임워크가 자동으로 처리한다).
    - 아래 코드는 다양한 입력 값이 주어질 수 있는 여러 경우를 고려하지 않았다는 문제가 있다.

  ```python
  def parser_test():
      try:
          result = sum("1,2")
          if result == 3:
              print("parser_test example 1 PASSED")
          else:
              raise Exception(f"parser_test: expected 3 but was {result}")
      except Exception as e:
          print(e)
  ```

  - 테스트 코드 개선하기
    - 범용적인 검증 함수를 만들어 오류가 일관되게 처리되도록 수정한다.
    - `assert_equals`은 인자로 받은 두 값이 같은지를 검증하고, `check`는 테스트 이름과 콜백 함수를 인자로 받아 테스트 중에 발생하는 오류를 잡아낸다.
    - 이처럼 몇 가지 함수를 추가하면 테스트가 훨씬 읽기 쉽고 테스트 생산성도 올라가게 된다.

  ```python
  def assert_equals(expected, actual):
      if expected != actual:
          raise Exception(f"Expected {expected} but was {actual}")
  
  def check(name, implementation):
      try:
          implementation()
          print(f"{name} passed")
      except Exception as e:
          print(f"{name} FAILED", e)
          
  check("sum with 2 numbers should sum them up", lambda :assert_equals(5, sum("2,3")))
  check("sum with 2 numbers should sum them up", lambda :assert_equals(8, sum("3,6")))
  ```



- 좋은 단위 테스트
  - 좋은 테스트는 다음 항목을 만족해야 한다.
    - 테스트 작성자의 의도를 이해하기 쉬워야 한다.
    - 읽고 쓰기 쉬워야 한다.
    - 테스트를 자동화할 수 있어야 한다.
    - 같은 조건에서 실행 결과는 항상 같아야 한다.
    - 의미 있는 테스트여야 한다.
    - 구체적인 결과를 제공하여 문제를 쉽게 파악할 수 있어야 한다.
    - 누구나 쉽게 실행할 수 있어야 한다.
    - 실패할 경우 무엇이 잘못되었는지 쉽게 알 수 있어야 한다.
  - 그 중에서도 좋은 단위 테스트는 아래와 같은 특징이 있다.
    - 빠르게 실행된다.
    - 테스트 환경을 일관되게 유지하고, 테스트 결과가 항상 예측 가능하다
    - 다른 테스트와 완전히 독립적으로 실행된다.
    - 시스템 파일, 네트워크, 데이터베이스가 없어도 메모리 내에서 실행이 가능하다.
    - 가능한 한 동기적인 흐름으로 실행된다(가능하면 병렬 스레드를 사용하지 않는다).
  - 항상 모든 조건을 만족해야 하는 것은 아니다.
    - 모든 테스트가 좋은 단위 테스트의 특성을 전부 만족하는 것은 사실 불가능에 가깝다.
    - 단위 테스트 조건을 만족하기 까다로운 테스트는 통합 테스트로 만드는 것도 하나의 방법이다.
  - 의존성을 스텁으로 대체하기
    - 스텁은 실제 의존성을 흉내내는 가짜 의존성이다.
    - 스텁을 사용하면 실제 의존성에 접근하지 않고도 테스트를 수행할 수 있어 테스트를 더 예측 가능하고 안정적으로 진행할 수 있다.
  - 비동기 처리를 동기적 테스트로 흉내 내기
    - 많은 언어에서 비동기 처리가 표준이 되었다.
    - 그럼에도 테스트에서는 비동기 코드를 동기적인 방식으로 검증할 수 있다.
    - 비동기 코드를 동기적인 방식으로 검증한다는 것은 테스트에서 직접 콜백 함수를 호출하거나 비동기 작업이 완료될 때까지 기다린다는 의미다.
  - 단위 테스트 체크리스트