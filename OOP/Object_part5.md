# 의존성 관리하기

- 변경과 의존성

  - 의존성
    - 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.
    - **어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.**
    - 두 객체 사이에 의존성이 있다는 것은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다.
    - 즉 <span style="color:red">**의존성은 함께 변경될 수 있는 가능성을 의미**</span>한다.
    - 의존성은 방향성을 가지며 단방향이다.

  - 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
    - 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야한다.
    - 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
  
  
    - 영화 예매 시스템에서
      - `PeriodCondition.is_satisfied_by`는 `Screening`인스턴스에게 메시지를 전송하여 상영 시작 시간을 받아온다.
      - 즉 `PeriodCondition`은 `Screening`에게 의존한다.
      - 실행 시점에 `PeriodCondition`의 인스턴스가 정상적으로 동작하기 위해서는 `Screening`의 인스턴스가 존재해야 한다.
      - 만약 `Screening`의 인스턴스가 존재하지 않거나 상영 시작 시간을 알려달라는 메시지를 이해할 수 없다면 `is_satisfied_by` 메서드는 예상했던 대로 동작하지 않을 것이다.
      - 또한 `PeriodCondition`은 `DiscountCondition`을 상속 받으므로, `DiscountCondition`에게 의존한다.
      - 따라서 만약 `Screening`의 인터페이스가 변경되거나, `DiscountCondition`이 변경된다면 `PeriodCondition`도 변경되어야 한다.
  
  ```python
  class PeriodCondition(DiscountCondition):
  
      def __init__(self, day_of_week: str=None, start_time: time=None, end_time: time=None):
          self._day_of_week = day_of_week
          self._start_time = start_time
          self._end_time = end_time
  
      def is_satisfied_by(self, screening: Screening):
          return screening._when_screened.weekday() == self._day_of_week and \
                 self._start_time <= screening._when_screened() and \
                 self._end_time >= screening._when_screened()
  ```
  
    - 변경과 관련이 있는 어떤 것에도 의존성이라는 개념을 적용할 수 있다.
      - 의존성이란 꼭 클래스에만 국한되는 개념은 아니다.
      - 의존성의 대상은 객체일 수도 있고 모듈일 도 있고 더 큰 규모의 시스템일 수도 있다.
  
    - **변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.**
      - 의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.
      - Java라면 JDK에 포함된 표준 클래스가 이 부류에 속한다.
      - 이런 클래스들에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 생성하더라도 문제가 없다.
  



- 의존성 전이(Transitive Dependency)
  - 의존성은 전이될 수 있다.
    - 의존성 전이가 의미하는 것은 A가 B에 의존하고 B가 C에 의존할 때 A는 B가 의존하는 C에 대해서도 자동적으로 의존하게 된다는 것이다.
    - 다만 의존성은 함께 변경될 수 있는 **가능성**을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.
  - 의존성이 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.
    - 내부 구현이 효과적으로 캡슐화될수록 의존성 전이가 발생하지 않을 확률이 높다.
  - 의존성의 종류
    - 직접 의존성(direct dependency)이란 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다.
    - 간점 의존성(indirect dependency)이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.



- 런타임 의존성과 컴파일 타임 의존성
  - 런타임과 컴파일타임
    - 런타임이란 애플리케이션이 실행되는 시점을 의미한다.
    - 컴파일 타임은 작성된 코드를 컴파일 하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체 혹은 코드를 작성하는 시점을 가리키기도 한다.
  - 런타임 의존성은 객체 사이의 의존성을, 컴파일 타임 의존성은 클래스 사이의 의존성을 주제로 한다.
    - 런타임 의존성과 컴파일 타임 의존성이 다를 수 있다.
    - 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.
  - 영화 예매 시스템에서
    - `Movie`는 가격 계산을 위해 비율 할인 정책과 금액 할인 정책 모두를 적용할 수 있게 설계해야 한다.
    - 즉 `Movie`는 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 모두와 협력할 수 있어야 한다.
    - 이를 위해 두 할인 정책 클래스가 `DiscountPolicy`라른 추상 클래스를 상속받게 한 후 `Movie`가 이 추상 클래스에 의존하도록 클래스 관계를 설계했다.
    - 중요한 점은 `Movie`에서 `AmountDiscountPolicy`와 `PercentDiscountPolicy`로 향하는 어떤 의존성도 존재하지 않는다는 것이다.
    - `Movie`는 오직 `DiscountPolicy`에만 의존한다.
    - 하지만 런타임에는 두 클래스 모두와 협력할 수 있다.
    - 코드 작성 시점의 `Movie` **클래스**는 두 클래스의 존재를 모르지만 실행 시점의 `Movie` **객체**는 두 클래스의 인스턴스와 협력할 수 있게 된다.
  - **실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야한다.**
    - **어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안 된다.**
    - 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다.
    - 따라서 **컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.**



- 컨텍스트 독립성
  - 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다.
    - 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.
  - 구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는 것과 같다.
    - 예를 들어 `Movie` 클래스 안에 `PercentDiscountPolicy` 클래스에 대한 컴파일타임 의존성을 명시적으로 표현하는 것은 `Movie`가 비율 할인 정책이 적용된 영화의 요금을 계산하는 문맥에서 사용될 것이라는 것을 가정하는 것이다.
  - 컨텍스트 독립성은 특정한 문맥에 결합되지 않는 다는 것을 의미한다.
    - 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.
    - 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이루어져 있다면 다른 문맥에서 사용하기가 훨씬 더 수월해진다.
    - 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 적게 알아야 한다.



- 의존성 해결하기

  - 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체되어야 한다.

    - 예를 들어 `DiscountPolicy`에 의존하는 `Movie`의 컴파일타임 의존성은 런타임에 `AmountDiscountPolicy`와 `PercentDiscountPolicy` 같은 구체적인 런타임 의존성으로 대체된다.
    - 이처럼 **컴파일타임의 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결**이라고 부른다.

  - 의존성 해결에는 일반적으로 아래와 같은 방법들이 사용된다.

    - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    - 객체 생성 후 setter 메서드를 통해 의존성 해결
    - 메서드 실행 시 인자를 이용해 의존성 해결

  - 생성자를 사용하는 방식

    - 생성자의 인자로 객체를 전달 받아 인스턴스 변수에 할당하는 방식이다.

  - Setter 메서드를 사용하는 방식

    - 객체를 생성한 이후에 의존하고 있는 대상이 변경될 가능성이 있는 경우에 유용하다.
    - 그러나 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 단점이 있다.
    - 예를 들어 의존 대상이 설정되지 않은 상태에서, 의존 대상이 필요한 코드가 실행되면 에러가 발생할 수도 있다.

    - 더 좋은 방법은 객체 생성시에 먼저 의존성을 해결해서 완전한 상태의 객체를 생성하고, 이후 필요에 따라 setter를 이용해 의존 대상을 변경하는 것이다.

  - 메서드 실행 시 인자를 이용하는 방식

    - 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나 메서드가 실행될 때마다 의존 대상이 달라져야 하는 경우에 유용하다.
    - 그러나 매번 동일한 객체를 인자로 전달하고 있다면 생성자나 setter를 이용해서 의존성을 지속적으로 유지하는 방식으로 변경하는 것이 낫다.



- 의존성과 결합도

  - 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다.
    - 그리고 이런 지식들이 객체 사이의 의존성을 낳는다.
    - 따라서 모든 의존성이 나쁜 것은 아니다.
    - 의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서는 바람직한 것이다.
    - 문제는 의존성 그 자체가 아니라 의존성의 정도다.
  - 바람직한 의존성은 재사용성과 관련이 있다.
    - 어떤 **의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것**이다.
    - `DiscountPolicy`라는 추상 클래스를 사용하는 기존의 코드는 코드의 변경 없이도 재사용이 가능하므로 바람직한 의존성이라고 볼 수 있다.
    - 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.
    - 즉 컨텍스트에 독립적인 의존성은 바람직한 의존성이고, 특정 컨텍스트에 결합된 의존성은 바람직하지 않은 의존성이다.
    - 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성이다.
    - 예를 들어 아래 코드에서 `PercentDiscountPolicy`를 `AmountDiscountPolicy`로 변경하려면(즉, 다른 환경에서 재사용 하려면) `Movie`의 `_discount_policy` 인스턴스 변수에 `AmountDiscountPolicy`를 할당하도록 변경해야 한다(내부 구현을 변경해야 한다).

  ```python
  class Movie:
      def __init__(self, title: str, running_time: time, fee: Money, percent_discount_policy: PercentDiscountPolicy):
          # ...
          self._discount_policy = percent_discount_policy
  
      def calculate_movie_fee(self, screening: Screening):
          return self._fee.minus(self._discount_policy.calculate_discount_amount(screening))
  ```

  - 결합도
    - 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합도(loose coupling) 또는 약한 결합도(weak coupling)를 가진다고 말한다.
    - 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도(tight coupling) 또는 강한 결합도(strong coupling)를 가진다고 말한다.
    - 어떤 의존성이 재사용을 방해한다면 결합도가 강하다고 표현하고, 재사용을 쉽게 허용한다면 결합도가 느슨하다고 표현한다.
  - 지식이 결합을 낳는다.
    - 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.
    - 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다.
    - 결합도를 느슨하게 유지하려면 협력하려는 대상에 대해 더 적게 알아야 한다.
    - 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에 최대한 감추는 것이 중요하다.



- **추상화에 의존하라**
  - 추상화는 결합도를 낮추는 데 도움을 준다.
    - 추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.
    - 따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.
  - 영화 예매 시스템에서
    - `DiscountPolicy` 클래스는 `PercentDiscountPolicy`와  `AmountDiscountPolicy`가 어떤 방식으로 할인 요금을 계산하는지를 감춰주기 때문에 두 클래스의 추상화다.
    - 따라서 `Movie`의 관점에서 알아야 하는 지식의 양은 `PercentDiscountPolicy`와  `AmountDiscountPolicy` 보다 추상화 된 `DiscountPolicy`가 더 적다.
    - `Movie`와 `DiscountPolicy` 사이의 결합도가 더 느슨한 이유는 추상화에 의존하기 때문이다.
  - 추상 클래스와 구체 클래스
    - 추상 클래스는 메서드의 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다.
    - 따라서 클라이언트가 알아야 하는 지식의 양이 더 적기 때문에 구체 클래스보다 추상 클래스에 의존하는 것이 결합도가 더 낮다.
    - 하지만 추상 클래스의 클라이언트는 여전히 협력하는 대상이 속한 클래스 상속 계층이 무엇인지에 대해서는 알고 있어야한다.
  - 인터페이스
    - 인터페이스에 의존하면 상속 계층을 모르더라도 협력이 가능해진다.
    - 인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다.
    - 이는 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있도록 컨텍스트를 확장할 수 있게 해준다.
  
  - 실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아진다.
    - **결합도를 느슨하게 만들기 위해서는 구체적인 클래스보다 추상 클래스에, 추상 클래스보다 인터페이스에 의존**하도록 만들어야한다.
    - **의존하는 대상이 더 추상적일 수록 결합도는 더 낮아진다.**



- 명시적 의존성
  - 의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법의 차이
    - 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부다.
    - **생성자의 인자로 선언하는 방법은 생성자라는 퍼블릭 인터페이스에 자신이 의존하는 대상에 대한 정보를 드러낸다.**
    - 이는 의존성 해결 방법 중 setter 메서드를 사용하는 방식이나 메서드의 인자로 전달하는 방식의 경우에도 동일하다.
    - 모든 경우에 퍼블릭 인터페이스에 의존성이 명시적으로 노출된다.
    - 반면에 생성자 안에서 직접 생성하는 방식은 의존성이 퍼블릭 인터페이스에 표현되지 않는다.
  - 명시적 의존성과 숨겨진 의존성
    - 의존성을 퍼블릭 인터페이스에 드러내는 것을 명시적 의존성이라 한다.
    - 반면에 의존성을 퍼블릭 인터페이스에 드러내지 않는 것을 숨겨진 의존성이라 한다.
    - 의존성은 명시적으로 표현되어야 한다.
  - 명시적 의존성을 사용해야 하는 이유
    - 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.
    - 또한 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다.
  - 숨겨진 의존성은 디버깅이 어렵고 이해하기 힘들다.
    - 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓기 때문이다.
    - 또한 테스트 코드를 작성하기도 까다롭다.
    - 가장 큰 문제는 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강요한다는 것이다.



- `new`는 해롭다

  - 대부분의 언어에서 클래스의 인스턴스를 생성할 수 있는 `new` 연산자를 제공한다.
  - 결합도 측면에서 `new`가 해로운 이유는 크게 두 가지다.
    - `new` 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 하므로 `new`를 사용하는 클라이언트는 구체 클래스에 의존할 수밖에 없기에 결합도가 높아진다.
    - `new` 연산자는 생성하려는 구체뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 하므로, 클라이언트가 알아야 하는 지식의 양이 늘어나기에 결합도가 높아진다.
  - `Movie`가 `AmountDiscountPolicy`의 인스턴스를 직접 생성한다고 가정해보자.
    - `Movie`는 `AmountDiscountPolicy`의 인스턴스를 생성하기 위해 생성자에 전달되는 인자를 알고 있어야한다.
    - 이는 `Movie` 클래스가 알아야 하는 지식의 양을 늘리기 때문에 `Movie`가 `AmountDiscountPolicy`에 더 강하게 결합되게 만든다.
    - 또한 두 구체 클래스인 `SequenceCondition`과 `PeriodCondition`에도 직접 의존하도록 만든다.
    - 그리고 이 두 클래스를 생성하는 데 필요한 인자들의 정보에 대해서도 `Movie`를 결합시킨다.

  ``` python
  class Movie:
      def __init__(self, title: str, running_time: time, fee: Money):
          self._discount_policy: DiscountPolicy = AmountDiscountPolicy(Money.wons(800),
                                                     [SequenceCondition(1), SequenceCondition(2),
                                                      PeriodCondition(2, datetime(2024, 3, 27, 10), datetime(2024, 3, 27, 12))]
                                                  )
  ```

  - 해결 방법은 인스턴스를 생성하는 로직과 인스턴스를 사용하는 로직을 분리하는 것이다.
    - `AmountDiscountPolicy`를 사용하는 `Movie`는 인스턴스를 생성해서는 안 된다.
    - 단지 해당하는 인스턴스를 사용하기만 해야 한다.
    - 이를 위해 `Movie`는 이미 생성된 `AmountDiscountPolicy`의 인스턴스를 전달받아야 한다(그리고 인스턴스의 생성 책임은 클라이언트로 옮긴다).
    - 외부에서 인스턴스를 전달받는 방법은 앞에서 살펴본 의존성 해결 방법과 동일하다.
    - 생성자의 인자로 전달하거나, setter 메서드를 사용하거나, 실행 시에 메서드의 인자로 전달하면 된다.
    - 아래 코드는 생성자의 인자로 전달하는 방식을 사용했다.

  ```python
  class Movie:
      def __init__(self, title: str, running_time: time, fee: Money, discount_policy: DiscountPolicy):
          self._discount_policy = discount_policy
  ```

  - 협력하는 기본 객체를 설정하고자 할 경우 클래스 안에서 협력 대상을 직접 생성하는 것이 유용할 수 있다.
    - 예를 들어 `Movie`가 대부분의 경우에는 `AmountDiscountPolicy` 인스턴스와 협력하고 가끔싹만 `PercentDiscountPolicy` 인스턴스와 협력한다고 가정해보자.
    - 이런 경우 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트들 사이에 중복 코드가 늘어나고 `Movie`의 사용성도 악화된다.
    - 이 문제를 해결하는 방법은 기본 객체를 생성하는 생성자를 추가하고 이 생성자에서 `DiscountPolicy`의 인스턴스를 인자로 받는 생성자를 체이닝 하는 것이다.
    - Python의 경우 `discount_policy` 인자에 기본값을 주면 된다.

  ```java
  public class Movie {
      private DiscountPolicy discountPolicy;
      
      public Movie(String title, Duration runningTime, Money fee) {
          this(title, runningTime, fee, new AmountDiscountPolicy(...));
      }
      
      public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
          this.discountPolicy = discountPolicy
      }
  }
  ```







# 유연한 설계

## 개방-폐쇄 원칙

- 개방-폐쇄 원칙(Open-Closed Principle, OCP)
  - 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙이다.
    - 로버트 마틴이 고안했다.
    - **소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.**
    - 이 원칙에 따르면 유연한 설계란 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계이다.
  - 핵심 키워드는 확장과 수정이다.
    - "확장에 열려있어야 한다"는 말은 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있어야 한다는 의미이다.
    - "수정에 닫혀 있어야 한다"는 말은 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있어야 한다는 의미이다.



- 컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라
  - **OCP는 런타임 의존성과 컴파일 타임 의존성에 대한 이야기다.**
    - 런타임 의존성은 실행시에 참여하는 객체들 사이의 관계다.
    - 컴파일타임 의존성은 코드에서 드러나는 클래스들 사이의 관계다.
    - 유연하고 재사용 가능한 설계에서 런타임 의존성과 컴파일타임 의존성은 서로 다른 구조를 가진다.
  - 영화 예매 시스템에서 할인 정책은 이미 OCP를 따르고 있다.
    - 예를 들어 2장에서 할인 정책 중 할인을 적용하지 않는 정책이 추가되었을 때를 생각해 보면 `Movie`의 코드는 하나도 수정하지 않고, `DiscountPolicy`를 상속 받는 `NoneDiscountPolicy`를 생성하는 것 만으로 정책을 추가(확장)할 수 있었다.
    - 이게 가능했던 이유는 컴파일타임 의존성과 런타임 의존성이 달랐기 때문이다.
    - `Movie`는 컴파일타임에는 `DiscountPolicy`에 의존하지만, 런타임에는 `DiscountPolicy`의 자식 클래스들에게 의존한다.
  - OCP를 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.
    - 새로운 할인 정책이 추가된다고 해도 `Movie`는 `DiscountPolicy`에만 의존한다.
    - 따라서 컴파일타임 의존성은 변하지 않는다.
    - 하지만 런타임에 `Movie` 인스턴스는 새로 추가된 `NoneDiscountPolicy`의 인스턴스와 협력할 수 있다.
    - 즉 런타임 의존성은 변경된다.
    - 의존성 관점에서 OCP를 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.



- 추상화가 핵심이다.

  - **OCP의 핵심은 추상화에 의존하는 것**이다.
    - 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고, 문맥에 따라 변하는 부분은 생략된다.
    - 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
    - OCP 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다.
    - 공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.
    - 즉 수정할 필요가 없어야 한다.
    - 따라서 추상화 부분은 수정에 대해 닫혀있다.
    - 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.
    - 이것이 추상화가 OCP를 가능하게 만드는 이유다.
  - `DiscountPolicy`는 추상화다.
    - 변하지 않는 부분은 할인 여부를 판단하는 부분(`calculate_discount_amount`)이고, 변하는 부분은 할인된 요금을 계산하는 방법(`get_discount_amount`)이다.
    - 추상화 과정을 통해 생략된 부분은 할인된 요금을 계산하는 방법이며, 상속을 통해 생략된 부분을 구체화함으로써 할인 정책을 확장할 수 있다.

  ```python
  class DiscountPolicy(ABC):
  
      def __init__(self, conditions: list[DiscountCondition]):
          self.conditions = conditions
  
      @abstractmethod
      def get_discount_amount(self, screening: Screening) -> Money:
          ...
  
      def calculate_discount_amount(self, screening: Screening):
          for condition in self.conditions:
              if condition.is_satisfied_by(screening):
                  return self.get_discount_amount(screening)
  
          return Money.wons(0)
  ```

  - 단순히 어떤 개념을 추상화 했다고 해서 수정에 닫혀 있는 설계를 만들 수 있는 것은 아니다.
    - **OCP에서 폐쇄를 가능하게 하는 것은 의존성의 방향**이다.
    - 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.
    - `Movie`는 안정된 추상화인 `DiscountPolicy`에 의존하기 때문에 할인 정책을 추가하기 위해 `DiscountPolicy`의 자식 클래스를 추가하더라도 영향을 받지 않는다.
    - 따라서 `Movie`와 `DiscountPolicy`는 수정에 대해 닫혀 있다.





## 생성 사용 분리

- 객체의 생성과 사용을 분리해야 하는 이유
  - **객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다.**
    - 알아야 하는 지식이 많으면 결합도도 높아지기 때문이다.
    - 결합도가 높아질수록 OCP를 따르는 구조를 설계하기 어려워진다.
  - 유연한 설계를 원한다면 객체 생성과 객체 사용이라는 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.



- Factory
  - 객체의 생성과 사용을 분리하는 가장 간단한 방법은 클라이언트에게 객체 생성 책임을 넘기는 것이다.
    - 그러나, 클라이언트 역시 다른 객체를 사용하고 있을 경우 이 방식은 사용할 수 없다.
    - 만약 객체의 생성만을 전담하는 별도의 객체가 있다면, 해당 객체에게 객체 생성 책임을 넘기면 된다.
  - **생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 factory라고 부른다.**



- 순수한 가공물에 책임 할당하기
  - Factory는 도메인 모델에 속하지 않는다.
    - GRASP 패턴에서 책임 할당의 가장 기본이 되는 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 정보 전문가에게 책임을 할당하는 것이다.
    - 도메인 모델은 정보 전문가를 찾기 위해 참조할 수 있는 일차적인 재료다.
    - 어떤 책임을 할당하고 싶다면 제일 먼저 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야 한다.
    - 그러나 factory는 도메인 모델에 속하지 않는다.
    - Factory는 단지 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에 할당되어 있던 객체 생성 책임을 도메인 개념과는 아무 상관 없는 가공의 객체로 이동시킨 것이다.
  - 도메인 모델의 한계
    - 상기했듯 어떤 책임을 할당하고 싶다면 제일 먼저 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야 한다.
    - 그러나 도메인 모델은 설계를 위한 중요한 출발점이지만 단지 출발점이라는 사실도 명심해야 한다.
    - 실제로 동작하는 소프트웨어는 도메인 개념들을 초월하는 개념들을 필요로 할 수 있다.
  - **순수한 가공물(Pure Fabrication)**
    - **모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제에 봉착하게 될 가능성이 높아진다.**
    - 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 **임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결**해야 한다.
    - 크레이그 라만은 이처럼 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 순수한 가공물이라고 부른다.
    - Factory도 순수한 가공물에 속한다.
  - **행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 순수 가공물을 추가하고 이 객체에게 책임을 할당**하라.
    - 순수 가공물은 보통 특정한 행동을 표현하는 것이 일반적이다.
    - 따라서 순수 가공물은 표현적 분해보다 행위적 분해에 의해 생성되는 것이 일반적이다.
  - 이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다.
    - 객체지향 애플리케이션은 도메인 개념뿐만 아니라 설계자들이 임의로 창조한 인공적인 추상화들을 포함하고 있다.
    - 애플리케이션 내에서 인공적으로 창조한 객체들이 도메인 개념을 반영하는 객체들보다 오히려 더 많은 비중을 차지하는 것이 일반적이다.
    - 먼저 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하되, 도메인 개념이 만족스럽지 못하다면 인공적인 객체를 창조해야 한다.





## 의존성 주입

- 의존성 주입(Dependency Injection)

  - **사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법**을 의존성 주입이라 부른다.
    - 의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.
    - 예를 들어 생성과 사용을 분리한 후 객체를 생성하는 쪽에서 사용하는 쪽으로 생성된 객체를 전달하는 것 역시 의존성 주입이다.
  - 의존성 주입은 의존성 해결 방법과 관련이 깊다.
    - 의존성 해결은 컴파일타임 의존성과 런타임 의존성을 해소하기 위한 다양한 메커니즘을 포괄한다.
    - 의존성 주입은 의존성을 해결하기 위해 **의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내**서 필요한 런타임 의존성을 외부에서 전달받을 수 있도록 만드는 방법을 포괄하는 명칭이다.
    - 따라서 의존성 주입에서는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.
    - 생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결
    - setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결
    - 메서드 주입(method injection): 메서드 실행 시 인자를 이용한 의존성 해결
    - 단, 메서드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있다.
  - 프로퍼티 주입
    - setter 주입은 Java에서 유래한 것으로, JavaBeans 명세는 속성을 설정하는 메서드는 set이라는 접두사로 시작해야 한다고 규정하고 있으며, Java에서는 이러한 메서드를 setter라 부른다.
    - C#에는 Java의 setter 메서드를 대체할 수 있는 프로퍼티라는 기능을 제공한다.
    - 따라서 C#에서는 setter 주입 대신 프로퍼티 주입이라는 용어를 사용한다.
    - setter 주입과 프로퍼티 주입은 개념적으로 동일하기에 같은 기법으로 간주해도 무방하다.
  - 인터페이스 주입
    - 주입할 의존성을 명시하기 위해 인터페이스를 사용하는 방식이다.
    - 근본적으로 setter 주입과 동일하지만, 어떤 대상을 어떻게 주입할 것인지를 인터페이스를 통해 명시적으로 선언한다는 차이만 있을 뿐이다.
    - Java에서 의존성 대상을 좀 더 명시적으로 정의하고 편리하게 관리하기 위해 도입된 방법이다.

  ```java
  public interface DiscountPolicyInjectable {
      public void inject(DiscountPolicy discountPolicy)
  }
  
  
  public class Movie implements DiscountPolicyInjectable {
      private DiscountPolicy discountPolicy;
      
      @override
      public void inject(DiscountPolicy discountPolicy) {
          this.discountPolicy = discountPolicy
      }
  }
  ```



- 숨겨진 의존성은 나쁘다.

  - SERVICE LOCATOR 패턴
    - 의존성 주입 이외에 의존성을 해결할 수 있는 방법이다.
    - 의존성을 해결할 객체들을 보관하는 일종의 저장소를 만드는 방식으로, 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해 줄 것을 요청한다.
    - SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다.
  - 예시
    - `Movie`는 `DiscountPolicy`에 의존한다.
    - `ServiceLocator`는 `DiscountPolicy` 객체를 미리 생성해둔다.
    - `Movie`는 `ServiceLocator`에게 `DiscountPolicy`라는 의존성을 해결해줄 것을 요청한다.
    - `Movie`는 `ServiceLocator`로 부터 받는 `DiscountPolicy`의 구체 타입은 알지 못한다.
  
  
  ```python
  class ServiceLocator:
      def __init__(self):
          self._discount_policy = None
  
      @classmethod
      def discount_policy(self) -> DiscountPolicy:
          return self._discount_policy
      
      @classmethod
      def provide(self, discount_policy = DiscountPolicy):
          self._discount_policy = discount_policy
  
  
  class Movie:
      def __init__(self, title: str, running_time: time, fee: Money):
          self._title = title
          self._running_time = running_time
          self._fee = fee
          self._discount_policy = ServiceLocator.discount_policy()
      
      # ...
  
  
  ServiceLocator.provide(AmountDiscountPolicy(Money.wons(800),
                              [SequenceCondition(1), SequenceCondition(2),
                              PeriodCondition(2, datetime(2024, 3, 27, 10), datetime(2024, 3, 27, 12))]
                          ))
  Movie("About Time", time(2, 3), Money.wons(10000))
  ```
  
  - SERVICE LOCATOR 패턴은 안티 패턴인가?
    - **SERVICE LOCATOR 패턴은 의존성을 감춘다는 단점을 가지고 있다.**
    - 위 예시에서 `Movie`는 `DiscountPolicy`에 의존하고 있지만 **`Movie`의 퍼블릭 인터페이스에 그 사실이 노출되지는 않는다.**
    - 또한 테스트를 작성한다고 할때,  `ServiceLocator`는 내부적으로 정적 변수를 사용해 주입할 객체들을 관리하기 때문에 모든 단위 테스트 케이스에 걸쳐 `ServiceLocator`의 상태를 공유하게 되는데, 이는 **각 단위 테스트는 서로 고립되어야 한다는 단위 테스트의 기본 원칙을 위반**한다.
    - 문제의 원인은 숨겨진 의존성이 캡슐화를 위반했기 때문이다.
    - **의존성을 구현 내부로 감추도록 강요하는 SERVICE LOCATOR는 캡슐화를 위반할 수밖에 없다.**
    - 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다.
    - 클래스의 사용법을 익히기 위해서 구현 내부를 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.
    - 가능하다면 의존성을 명시적으로 표현할 수 있는 기법을 사용해야 한다.
  - SERVICE LOCATOR 패턴이 유용한 경우
    - 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우.
    - 깊은 호출 계층에 걸쳐 동일한 계층을 계속해서 전달해야 하는 경우.





## 의존성 역전 원칙

- 추상화와 의존성 역전

  - **상위 수준이 하위 수준에 의존할 경우 변경에 취약해진다.**
    - 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 되기 때문이다.
    - 아래 코드에서 `Movie`는 가격 계산이라는 더 높은 수준의 개념을 구현한다.
    - 그에 비에 `AmountDiscountPolicy`는 특정한 금액만큼을 할인해주는 더 구체적인 수준의 메커니즘을 담당하고 있다.
    - 다시 말해 상위 수준 클래스가 하위 수준 클래스에 의존하는 것이다.

  ```python
  class Movie:
      def __init__(self, discount_policy):
          self._discount_policy: AmountDiscountPolicy = discount_policy
  ```

  - **객체 사이의 협력에서 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다.**
    - `Movie`와 `AmountDiscountPolicy` 사이의 협력이 가지는 본질은 영화의 가격을 계산하는 것이다.
    - 어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다.
    - 다시 말해 **어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스이다.**
  - 의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.
    - 위 코드의 문제점은 의존성의 방향이 잘못됐다는 것이다.
    - 의존성은 `Movie`에서 `AmountDiscountPolicy` 쪽으로 흘러서는 안 된다.
    - `AmountDiscountPolicy`에서 `Movie`로 흘러야 한다.
  - 상위 수준이 하위 수준에 의존할 경우 재사용성에도 문제가 생긴다.
    - `Movie`를 재사용하기 위해서는 `AmountDiscountPolicy` 역시 함께 재사용해야 한다.
    - 대부분의 경우 재사용하려는 대상은 상위 수준의 클래스이다
    - 상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용할 때 하위 수준의 클래스도 필요하기 때문에 재사용이 어려워진다.
  - **상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 된다.**
    - 상위 수준의 변경에 의해 하위 수준이 변경되는 것은 납득할 수 있다.
    - 그러나 하위 수준의 변경으로 인해 상위 수준이 변경되는 것은 안 된다.
    - 하위 수준의 문제로 인해 상위 수준에 위치하는 클래스들을 재사용하는 것이 어려워서도 안 된다.
  - 추상화에 의존해야한다.
    - 모든 의존성의 방향이 추상화를 향해야한다.
    - 그래야 유연하고 재사용 가능한 설계가 가능하다.
    - 구체 클래스는 의존성의 시작점이어야 하며, 의존성의 목적지가 되어서는 안 된다.



- **의존성 역전 원칙(Dependency Inversion Principle, DIP)**
  - 아래 내용을 의존성 역전 원칙이라 부른다.
    - **상위 수준은 모듈의 하위 수준에 의존해서는 안 되며, 둘 모두 추상화에 의존해야 한다.**
    - **추상화는 구체적인 사항에 의존해서는 안되며, 구체적인 사항이 추상화에 의존해야 한다.**
  - 역전
    - 이 용어를 최초로 착안한 로버트 마틴은 의존성 역전 원칙을 따르는 설계의 **의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문**이라고 설명한다.
    - 전통적인 소프트웨어 개발 방법에서는 상위 수준의 모듈이 하위 수준의 모듈에 의존하고, 정책이 구체적인 것에 의존하는 경향이 있었다.
    - 따라서 전통적인 소프트웨어의 의존성의 방향을 역전시켜야 한다는 의미로 역전이라는 단어를 사용했다.



- DIP와 패키지

  - 역전은 의존성의 방향뿐 아니라 인터페이스의 소유권에도 적용된다.
    - 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다.
    - Java는 패키지를 이용해 모듈을 구현하고, C#은 네임스페이스를 이용해 모듈을 구현한다.
  - 문제 상황
    - `Movie`, `AmountDiscountPolicy`, `PercentDiscountPolicy`가 모두 `DiscountPolicy`에 의존하는 상황에서, `Movie`만 다른 패키지에 위치하고, 다른 클래스들은 모두 같은 패키지에 위치한다고 가정해보자.
    - 세 클래스가 모두 `DiscountPolicy`에 의존하므로 OCP를 준수하고, DIP도 준수한다고 생각할 것이다.
    - 그러나 `Movie`를 다양한 컨텍스트에서 재사용하기 위해서는 `AmountDiscountPolicy`, `PercentDiscountPolicy`와 같은 불필요한 클래스도 함께 배포되어야 한다.
    - 그 이유는 다음과 같다.
    - `Movie`를 정상적으로 컴파일하기 위해서는 `DiscountPolicy` 클래스가 필요하다.
    - 문제는 `DiscountPolicy`가 포함되어 있는 패키지 안에 `AmountDiscountPolicy`, `PercentDiscountPolicy` 클래스가 포함되어 있다는 것이다.
    - 이는 `DiscountPolicy` 클래스에 의존하기 위해서는 반드시 같은 패키지에 포함된 `AmountDiscountPolicy`, `PercentDiscountPolicy` 클래스도 함께 존재해야 한다는 것을 의미한다.
  - 컴파일 측면에서 의존성은 다를 수 있다.
    - 의존성의 정의에 따라 `Movie`는 `DiscountPolicy`를 수정하지 않을 경우에는 영향을 받지 말아야 한다.
    - 그러나 이는 코드 수정에 있어서는 사실이지만 컴파일 측면에서는 아니다.
    - `DiscountPolicy`가 포함된 패키지 안의 어떤 클래스가 수정되더라도 패키지 전체가 재배포되어야 한다.
    - 이로 인해 이 패키지(`DiscountPolicy`가 포함된 패키지)에 의존하는 Movie 클래스가 포함된 패키지 역시 재컴파일 되어야 한다.
    - 만약 `Movie`에 의존하는 또 다른 패키지가 있다면 컴파일은 의존성을 따라 애플리케이션 코드 전체로 번져갈 것이다.
    - 따라서 **불필요한 클래스들을 같은 패키지에 두는 것은 전체적인 빌드 시간을 가파르게 상승시킨다.**

  - **Separated Interface 패턴**
    - `Movie`의 재사용을 위해 필요한 것이 `DiscountPolicy`뿐이라면 둘을 같은 패키지로 모으고 `AmountDiscountPolicy`, `PercentDiscountPolicy`를 별도의 패키지에 위치시켜 의존성 문제를 해결할 수 있다.
    - 즉, 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시키고, 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모으면 된다.
    - 마틴 파울러는 이 기법을 separated interface 패턴이라 부른다.
  - 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.
    - 전통적인 설계 패러다임은 인터페이스의 소유권을 클라이언트 모듈이 아닌 서버 모듈에 위치시킨다.
    - 그러나 **잘 설계된 객체지향 애플리케이션에서는 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시킨다.**
    - 이는 객체지향 프레임워크의 모듈 구조를 설계하는 데 가장 중요한 핵심 원칙이다.





## 유연성에 대한 조언

- 유연한 설계는 유연성이 필요할 때만 옳다.

  - 설계의 미덕은 단순함과 명확함으로부터 나온다.
    - 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계가 유연한 설계다.
    - 하지만 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.
    - 단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하지만, 유연한 설계는 이와 다른 길을 걷는다.
    - 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다.

  - **유연한 설계라는 말의 이면에는 복잡한 설계라는 의미가 숨어 있다.**
    - 유연성은 항상 복잡성을 수반한다.
    - 유연하지 않은 설계는 단순하고 명확하지만, 유연한 설계는 복잡하고 암시적이다.
    - 유연한 설계의 이런 양면성은 객관적으로 설계를 판단하기 어렵게 만든다.
    - 설계가 복잡한 이유는 무엇인지, 어떤 변경에 대비하기 위해 설계를 복잡하게 만들었는지, 정말 유연성이 필요한지 등에 대답하는 것은 어려운 일이다.
    - 복잡성이 필요한 이유와 합리적인 근거를 제시하지 않는다면 설계를 만족스러운 해법으로 받아들이지 않을 것이다.
  - 설계가 유연할수록 클래스의 구조와 객체 구조 사이의 거리는 점점 멀어진다.
    - 절차적인 프로그래밍 방식으로 작성된 코드는 코드에 표현된 정적인 구조가 곧 실행 시점의 동적인 구조를 의미한다.
    - 그러나 객체지향 코드에서 클래스의 구조는 발생 가능한 모든 객체 구조를 담는 틀일 뿐이다.
    - 특정 시점의 객체 구조를 파악하는 유일한 방법은 클래스를 사용하는 클라이언트 코드 내에서 객체를 생성하거나 변경하는 부분을 직접 살펴보는 것이다.
    - 결국 유연함은 단순성과 명확성의 희생 위에서 자라난다.
  - **변경은 예상이 아닌 현실이어야 한다.**
    - 미래에 변경이 일어날지도 모른다는 막연한 불안감은 복잡한 설계를 낳는다.
    - 아직 일어나지 않은 변경은 변경이 아니다.
    - 불필요한 유연성은 불필요한 복잡성을 낳는다.
  - 단순하고 명확한 해법이 만족스럽다면 유연성을 제거하라
    - 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.
    - 유연한 설계의 필요성이 더 크다면 컴파일타임과 런타임의 구조를 다르게 만들어라.



- 협력과 책임이 중요하다.
  - 설계를 유연하게 만들기 위해서는 역할, 책임, 협력에 초점을 맞춰야 한다.
    - 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 사라진다.
    - 객체들이 메지시 전송자의 관점에서 동일한 책임을 수행하는지 여부를 판단할 수 없다면 공통의 추상화를 도출할 수 없다.
    - 동일한 역할을 통해 객체들을 대체 가능하게 만들지 않았다면 협력에 참여하는 객체들을 교체할 필요가 없다.
  - **객체의 역할과 책임이 객체 생성보다 먼저다.**
    - 너무 성급하게 객체를 생성하는 것에 집중할 경우 객체 생성과 관련된 불필요한 세부사항에 객체를 결합시키게 된다.
    - **객체를 생성할 책임을 담당할 객체나 객체 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야만 한다.**
    - 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다.
    - 책임 관점에서 객체들 간에 균형이 잡혀 있는 상태라면 생성과 관련된 책임을 지게 될 객체를 선택하는 것은 간단한 작업이 된다.
    - 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높다.
  - 의존성을 관리하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.





# 핵심

- 의존성은 함께 변경될 수 있는 가능성을 의미한다.



- 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야한다.



- 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 factory라고 부른다.



- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라 부른다.



- 상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 된다.



- 객체를 생성할 책임을 담당할 객체나 객체 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야만 한다.
