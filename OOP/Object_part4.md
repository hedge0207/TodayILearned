# 메시지와 인터페이스

- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지다.
  - 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환해야한다.
  - 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.



- 협력과 메시지

  - 클라이언트-서버 모델
    - 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
    - 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
    - 객체는 자신의 희망을 메시지라는 형태로 전송하고 메시지를 수신한 객체는 요청을 적절히 처리한 후 응답한다.
    - 두 객체 사이의 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다.
    - 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라 부르며, 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
    - 협력의 관점에서 객체는 객체가 수신하는 메시지의 집합과 외부의 객체에게 전송하는 메시지의 집합이라는 두 종류의 메시지 집합으로 구성된다.
    - 대부분의 사람들은 객체가 수신하는 메시지의 집합에만 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.
  - 메시지와 메시지 전송
    - 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송 또는 메시지 패싱이라 부른다.
    - 이 때 메시지를 전송하는 객체를 메시지 전송자라고 부르고, 메시지를 수신하는 객체를 메시지 수신자라고 부른다.
    - 메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.
    - 예를 들어 `is_satisfied_by(screening)`은 오퍼레이션명(`is_satisfied_by`)과 인자(`screening`)으로 구성된 메시지이며, `condition.is_satisfied_by(screening)`는 메시지 수신자(`condition`)가 추가된 메시지 전송이다.
  - 메시지와 메서드
    - 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
    - **메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.**
    - 기술적인 관점에서 객체 사이의 메시지 전송은 전통적인 방식의 함수 호출이나 프로시저 호출과는 다르다.
    - 전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 구문을 작성한다.
    - 즉 코드의 의미가 컴파일 시점과 실행 시점에 동일하다.
    - 반면에 객체는 메시지와 메서드라는 서로 다른 개념을 실행 시점에 연결해야 하기에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
    - 메시지와 메서드의 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.
    - **메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 되며 수신자에 대해 몰라도 된다.**
    - 메시지 수신자 역시 전송자에 대해 알 필요가 없으며, 단지 메시지가 도착했다는 사실만 알면 된다.
    - **메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 결정할 수 있는 자율권을 누린다.**
    - **실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.**
  - 퍼블릭 인터페이스와 오퍼레이션
    - 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.
    - 외부에서 볼 때 객체의 안쪽은 미지의 영역이며, 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
    - 이처럼 **객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다.**
    - 프로그래밍 언어적 관점에서 **퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라 부른다.**
    - 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화이며, 흔히 **오퍼레이션이라 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분**이다.
    - 그에 비해 **메시지를 수신했을 때 실제로 실행되는 코드는 메서드**라고 부른다.
    - 예를 들어 `DiscountDondition` 인터페이스에 정의 된 `is_satisfied_by`는 오퍼레이션에 해당하고, `SequenceCondition`과 `PeriodCondition`의 `is_satisfied_by`는 실제 구현을 포함하기에 메서드라고 부른다.
    - 객체가 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고, 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
    - 따라서 퍼블릭 인터페이스와 메시지의 관점에서 보면 '메서드 호출' 보다는 '오퍼레이션 호출'이라는 용어를 사용하는 것이 더 적절하다.

  - 시그니처
    - 오퍼레이션(또는 메서드)의 이름과 파라미터 항목을 합쳐서 시그니처라고 부른다(일부 언어에서는 반환 타입까지 시그니처에 포함되기도 한다).
    - 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.
    - 메서드는 시그니처에 구현을 더한 것이다.
    - 일반적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.
    - 하나의 오퍼레이션에 오직 하나의 메서드만 존재하는 경우 굳이 둘을 구분할 필요가 없다.
    - 그러나 다형성을 위해서는 하나의 오퍼레이션에 대해 다양한 메서드를 구현해야한다.
    - 따라서 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.



- 인터페이스와 설계 품질
  - **좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.**
    - 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
    - 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.
  - 위 조건을 만족시키는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다.
    - 책임 주도 설계는 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지하여 인터페이스는 최소한의 오퍼레이션만 포함하게 된다.
    - 또한 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 하여 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.
  - 퍼블릭 인터페이스의 품질에 영향을 미치는 대표적인 원칙과 기법들은 아래와 같은 것들이 있다.
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리



- **디미터 법칙(Law of Demeter)**

  - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 법칙이다.
    - 낯선 자에게 말하지 말라
    - 오직 인접한 이웃하고만 말하라.
  - 디미터 법칙을 따르게 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야 한다.
    - 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다.
    - M에 의해 생성된 객체.
    - M이 호출하는 메서드에 의해 생성된 객체.
    - 전역 변수로 선언된 객체.
    - M의 인자로 전달된 클래스(C 자체를 포함)
    - C의 인스턴스 변수의 클래스
  - 결국 쉽게 말해 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다.
    - this 객체
    - 메서드의 매개 변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체
  - 부끄럼타는 코드(shy code)
    - 디미터 법칙을 따르면 부끄럼타는 코드를 작성할 수 있다.
    - 부끄럼 타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 의미한다.
    - 디미터 법칙을 따르는 코드는 메시지 수진자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.
    - 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.
  - 디미터 법칙과 캡슐화
    - 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다.
    - **디미터 법칙이 가치 있는 이유는 캡슐화를 위해 따라야 하는 구체적인 지침을 제공하기 때문이다.**
    - 캡슐화가 클래스 내부 구현을 감춰야한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
  - **기차 충돌(train wreck)**
    - 아래 코드는 디미터 법칙을 위반하는 코드의 전형적인 모습을 표현한 것이다.
    - 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다.
    - 이러한 코드를 기차 충돌이라 부르는데 여러 대의 기차가 한 줄로 늘어서 충돌한 것 처럼 보이기 때문이다.
    - 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
    - 따라서 수신자의 캡슐화는 무너지고, 전송자가 수신자의 내부 구현에 강하게 결합된다.
    - 아래 코드에서 메시지 전송자는 `screening.get_movie()` 오퍼레이션의 결과로 `.calculate_fee()` 메시지를 이해할 수 있는 객체가 온다는 것을 알고 있다.
    - 이는 `Screening`의 내부에 `calculate_fee()` 메시지를 이해할 수 있는 객체가 있다는 것이 외부로 노출 된 것이다.
    - 따라서 수신자인 `Screening`의 캡슐화는 무너지고, 전송자는 `Screening`에 강하게 결합된다.
  
  ```python
  screening.get_movie().caclulate_fee()
  ```
  
  - **디미터 법칙은 결합도와 관련된 것이며, 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.**
    - 무비판적으로 디미터 법칙을 수용하면 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다.
    - 자료구조는 당연히 내부 구조를 노출하므로 자료구조에 디미터 법칙을 적용해선 안 된다.



- **묻지 말고 시켜라(Tell, Don't Ask)**
  - 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.
    - 묻지 말고 시켜라는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.
    - 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.
    - 외부 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
  
  - **묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.**
    - 객체지향의 기본은 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.
    - 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.
    - 이 원칙을 따를 경우 자연스럽게 정보 전문가에게 책임을 할당하게 되고 응집도 높은 클래스를 얻을 확률이 높아진다.
  - 묻지 말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.
    - 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해야한다.
    - 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재한다면 객체가 책임져야 하는 행동이 객체 외부로 누수된 것이다.
    - 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하여 인터페이스를 향상시켜야 한다.
    - 하지만 단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다.
    - 여기에 더해서 객체가 어떻게 작업을 수행하는지를 노출해서는 안 된다.



- **의도를 드러내는 인터페이스(Intention Revealing Interface)**

  - 메서드의 이름을 짓는 방법
    - 켄트 벡은 메서드를 명명하는 두 가지 방법을 설명했다.
    - 첫 번째 방법은 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 것이다.
    - 두 번째 방법은 메서드가 무엇을 수행하는지를 나타내도록 이름을 짓는 것이다.
    - 결론부터 말하면, 두 방법 중 후자가 더 나은 방법이다.
    - 전자의 경우 메서드의 내부 구현을 설명하는 이름으로, 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민하게 한다.
    - 반면에 후자의 경우 객체가 협력 안에서 수행하는 책임에 관해 고민하도록 해준다.
  - 메서드가 작업을 어떻게 수행하는지 나타내도록 명명하기
    - 아래와 같이 메서드가 작업을 어떻게 수행하는지 나타내도록 명명하는 것은 좋지 않은 방법이다.
    - 첫 번째 이유는 메서드에 대해 제대로 커뮤니케이션 하지 못한다는 것이다.
    - 클라이언트의 관점에서는 아래 두 메서드 모두 할인 조건을 판단하는 동일한 작업을 수행함에도, 이름이 다르기에 두 메서드의 내부 구현을 정확히 모른다면 두 메서드가 동일한 작업을 수행한다는 사실을 알기 힘들다.
    - 두 번째 이유는 메서드 수준에서 캡슐화를 위반한다는 것이다.
    - 이 메서드들은 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다.
    - 즉, `PeriodCondtion`를 사용하는 코드를 `SequenceCondition`를 사용하는 코드로 변경하려면 단순히 참조하는 객체를 변경하는 것뿐만 아니라 호출하는 메서드를 변경해야한다.
    - 만약 할인 여부를 판단하는 방법이 변경된다면 메서드의 이름 역시 변경해야 하며, 이는 메시지를 전송하는 클라이언트의 코드도 함께 변경해야 한다는 것을 의미한다.

  ```python
  class PeriodCondtion:
      def is_satisfied_by_period(self, screening: Screening):
          ...
          
          
  class SequenceCondition:
      def is_satisfied_by_sequence(self, screening: Screening):
          ...
  ```

  - **메서드가 무엇을 하는지 나타내도록 명명하기**
    - 메서드의 구현이 한 가지인 경우에는 무엇을 하는지를 드러내는 이름을 짓는 것이 어려울 수도 있다.
    - 그러나 무엇을 하는지 드러내는 이름은 코드를 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 만들게 해준다.
    - 이 방식은 객체가 협력 안에서 수행하는 책임에 관해 고민하도록 한다.
    - 이를 통해 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.
    - 메서드가 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커 진다.
    - 그 결과 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 얻게 된다.

  ```python
  class DiscountCondition(ABC):
      @abstractmethod
      def is_satisfied_by(self, screening: Screening):
          ... 
  
  
  class PeriodCondtion(DiscountCondition):
      def is_satisfied_by(self, screening: Screening):
          ...
          
          
  class SequenceCondition(DiscountCondition):
      def is_satisfied_by(self, screening: Screening):
          ...
  ```

  - **오퍼레이션의 이름은 협력이라는 문맥을 반영해야한다.**
    - 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야한다.
    - 다시 말해 **객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야한다.**
  - 의도를 드러내는 선택자(Intention Revealing Selector)
    - 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 의도를 드러내는 선택자라고 부른다.
    - 켄트 벡은 메서드에 의도를 드러낼 수 있는 이름을 붙이기 위해 다음과 같이 생각할 것을 조언한다,
    - 동일한 행동을 하지만 구현은 매우 다른 두 번째 메서드를 상상하고, 해당 메서드에 동일한 이름을 붙인다고 상상한다.
    - 이렇게 하면 가능한 한 가장 추상적인 이름을 메서드에 붙이게 될 것이다.
  - 의도를 드러내는 인터페이스는 의도를 드러내는 선택자를 인터페이스 레벨로 확장한 것이다.
    - 에릭 에반스가 켄트 벡의 의도를 드러내는 선택자를 확장하여 제시했다.
    - 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다.
    - 타입 이름, 메서드 이름, 인자 이름이 모두 결합되어 의도를 드러내는 인터페이스를 형성한다.
    - 퍼블릭 인터페이스에는 관계와 규칙을 실행하는 방법이 아닌 이벤트와 규칙 그 자체만 명시한다.



- 함께 모으기

  - 디미터 법칙을 위반하는 티켓 판매 도메인
    - 디미터 법칙에 따르면 인자로 전달된 `audience`와 인스턴스 변수인 `ticket_seller`에게 메시지를 전송하는 것은 문제가 없다.
    - 문제는 `Theater`가 `audience`와 `ticket_seller` 내부에 포함된 객체에도 직접 접근하여 디미터 법칙을 위반한다는 것이다.

  ```python
  class Theater:
      def __init__(self, ticket_seller: TicketSeller):
          self.ticket_seller = ticket_seller
      
      def enter(self, audience: Audience):
          if audience.get_bag().has_invitation():
              ticket = self.ticket_seller.get_ticket_office().get_ticket()
              audience.get_bag().set_ticket(ticket)
          else:
              ticket = self.ticket_seller.get_ticket_office().get_ticket()
              audience.get_bag().minus_amount(ticket.get_fee())
              self.ticket_seller.get_ticket_office().plus_amount(ticket.get_fee())
              audience.get_bag().set_ticket(ticket)
  ```

  - 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현 분리 원칙을 위반한다.
    -  `Audience`가 `Bag`을 포함한다는 사실은 `Audience`의 내부 구현에 속하며 `Audience`는 자신의 내부 구현을 자유롭게 변경할 수 있어야 한다.
    - 그러나 퍼블릭 인터페이스에 `get_bag`을 포함시키는 순간 객체의 구현이 퍼블릭 인터페이스를 통해 외부로 새어나가게 된다.
    - 따라서 디미터 법칙을 위반하는 것은 클라이언트에게 구현을 노출한다는 것을 의미하며, 그 결과 작은 변경에도 쉽게 무너지는 불안정한 코드를 얻게 된다.
  - 디미터 법칙을 위반한 코드는 사용하기도 어렵다.
    - 클라이언트 객체의 개발자는 `Audience`의 퍼블릭 인터페이스뿐만 아니라 `Audience`의 내부 구현까지 알고 있어야 하기 때문이다.
    - `TicketSeller`의 경우 그 정도가 더 심한데, `Theater`는 `TicketSeller`가 `get_ticket_office` 메시지를 수신할 수 있다는 사실뿐만 아니라 내부에 `TicketOffice`를 포함하고 있다는 사실도 알아야 한다. 또한 `Theater`는 반환된 `TicketOffice`가 `get_ticket` 메시지를 수신할 수 있으며, 이 메서드가 반환하는 `Ticket` 인스턴스가 `get_fee` 메시지를 이해할 수 있다는 사실도 알고 있어야한다.
  - `Theater`에 묻지 말고 시켜라 적용하기
    - 디미터 법칙을 위반한 코드를 수정하는 일반적인 방법은 내부 구조를 묻는 대신 `Audience`와 `TicketSeller`가 직접 자신의 책임을 수행하도록 시키는 것이다.
    - 즉, `Audience`와 `TicketSeller`는 묻지 말고 시켜라 스타일을 따르는 퍼블릭 인터페이스를 가져야 한다.

  ```python
  class TicketSeller:
      def __init__(self, ticket_office: TicketOffice):
          self.ticket_office = ticket_office
      
      def get_ticket_office(self) -> TicketOffice:
          return self.ticket_office
          
      def set_ticket(self, audience: Audience):
          if audience.get_bag().has_invitation():
              ticket = self.ticket_office.get_ticket()
              audience.get_bag().set_ticket(ticket)
          else:
              ticket = self.ticket_office.get_ticket()
              audience.get_bag().minus_amount(ticket.get_fee())
              self.ticket_office.plus_amount(ticket.get_fee())
              audience.get_bag().set_ticket(ticket)
              
              
  class Theater:
      def __init__(self, ticket_seller: TicketSeller):
          self.ticket_seller = ticket_seller
      
      def enter(self, audience: Audience):
          self.ticket_seller.set_ticket(audience)
  ```

  - `TicketSeller`에 묻지 말고 시켜라 적용하기
    - 마찬가지로 `Audience`가 `Ticket`을 보유하도록 만들어 `TicketSeller`가 묻지 않고 시킬 수 있도록 한다.
  
  ```python
  class Audience:
      def __init__(self, bag: Bag=None):
          self.bag = bag
      
      def get_bag(self) -> Bag:
          return self.bag
      
      def set_ticket(self, ticket: Ticket):
          if self.bag.has_invitation():
              self.bag.set_ticket(ticket)
              return 0
          else:
              self.bag.set_ticket(ticket)
              self.bag.minus_amount(ticket.get_fee())
              return ticket.get_fee()
  
  
  class TicketSeller:
      def __init__(self, ticket_office: TicketOffice):
          self.ticket_office = ticket_office
      
      def get_ticket_office(self) -> TicketOffice:
          return self.ticket_office
          
      def set_ticket(self, audience: Audience):
          self.ticket_office.plus_amount(audience.set_ticket(self.ticket_office.get_ticket()))
  ```
  
  - `Audience`에 묻지 말고 시켜라 적용하기
    - `Audience`는 `Bag`에게 원하는 일을 시키기 전에 `has_invitation` 메서드를 이용하여 초대권이 있는지를 확인하므로 묻지 말고 시켜라 원칙을 위반한다.
  
  ```python
  class Bag:
      def __init__(self, amount=None, invitation: Invitation=None):
          if not amount and not invitation:
              raise Exception()
          
          self.amount = amount
          self.invitation = invitation
          self.ticket: Ticket = None
          
      def has_invitation(self):
          return self.invitation is not None
      
      def set_ticket(self, ticket: Ticket):
          if self.has_invitation():
              self.ticket = ticket
              return 0
          else:
              self.ticket = ticket
              self.minus_amount(ticket.get_fee())
              return ticket.get_fee()
          
      def minus_amount(self, amount: int):
          self.amount -= amount
          
          
  class Audience:
      def __init__(self, bag: Bag=None):
          self.bag = bag
      
      def set_ticket(self, ticket: Ticket):
          return self.bag.set_ticket(ticket)
  ```
  
  - 디미터 법칙과 묻지 말고 시켜라 원칙에 따라 리팩터링한 후에 `Audience`는 자신의 상태를 스스로 관리하고 결정하는 자율적인 객체가 됐다.
    - 두 원칙을 따르면 자연스럽게 자율적인 객체로 구성된 유연한 협력을 얻게 된다.
    - 구현이 객체의 퍼블릭 인터페이스에 노출되지 않기 때문에 객체 사이의 결합도는 낮아진다.
    - 책임이 잘못된 곳에 할당될 가능성이 낮아지기 때문에 객체의 응집도 역시 높아진다.



- 인터페이스에 의도를 드러내자

  - 현재의 인터페이스는 클라이언트의 의도를 명확하게 드러내지 못 한다.
    - `TicketSeller`의 `set_ticket` 메서드는 클라이언트의 의도를 전달하지 못한다.
    - 이는 `Audience`의 `set_ticket`과 `Bag`의 `set_ticket` 역시 마찬가지다.

  - 따라서 의도를 보다 분명히 드러낼 수 있도록 수정한다.

  ```python
  class TicketSeller:
      def sell_to(self, audience: Audience):
          ...
          
          
  class Audience:
      def buy(self, ticket: Ticket):
          ...
          
          
  class Bag:
      def hold(self, ticket: Ticket):
          ...
  ```




- 원칙의 함정

  - 위에서 살펴본 것들은 절대적인 법칙이 아닌 원칙이다.

    - 설계는 트레이드오프의 산물이므로 원칙을 맹목적으로 추종해선 안 된다.
    - 원칙들이 서로 충돌하는 경우에도 원칙에 정당성을 부여하고 억지로 끼워 맞춰서는 안 된다.

    - 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시해야한다.
  - 디미터 법칙은 하나의 도트(`.`)를 강제하는 규칙이 아니다.
    - 디미터 법칙은 "하나의 도트만을 사용하라"는 말로 요약되기도 한다.
    - 만약 하나의 도트만을 사용해야 한다는 디미터 원칙을 곧이 곧대로 받아들이면 아래와 같은 코드는 디미터 원치글 위반하는 코드가 될 것이다. 
    - `IntStream.of(1,2,3).filter(x -> x >2).distinct().count();`
    - 그러나 이는 디미터 법칙을 잘못 이해한 것으로, 위 코드에서 `of`, `filter`, `distinct` 메서드는 모두 `IntStream`이라는 동일한 클래스의 인스턴스를 반환한다.
    - 즉 이들은 `IntStream`의 인스턴스를 또 다른 `IntStream` 인스턴스로 변환다.
    - 따라서 이 코드는 디미터 법칙을 위반하지 않는다.
    - 이런 종류의 코드를 마주쳤을 때 과연 여러 개의 토드를 사용한 코드가 객체의 내부 구조를 노출하는가를 먼저 생각해 봐야 한다.
  - 맹목적인 위임 메서드의 추가는 응집도를 낮출 수 있다.
    - 수정 전의 `Theater.enter`를 보면 `Audience` 내부에 포함된 `Bag`에 대해 질문한 후 반환된 결과를 이용해 `Bag`의 상태를 변경한다.
    - 이 코드는 분명히 `Audience`의 캡슐화를 위반하기 때문에 `Theater`는 `Audience`의 내부 구조에 강하게 결합된다.
    - 이 문제를 해결할 수 있는 방법은 질문하고, 판단하고, 상태를 변경하는 모든 코드를 `Audience` 내부로 옮기는 것이다.
    - 즉 `Audience`에게 위임 메서드를 추가하는 것이다.
    - 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 응집도를 높일 수 있는 효과적인 방법이다.
    - 그러나 묻지 말고 시켜라와 디미터의 법칙을 준수하는 것이 항상 긍정적인 결과를 가져오는 것은 아니다.
    - 모든 상황에 맹목적으로 위임 메서드를 추가할 경우 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 되어 상관 없는 책임들을 한꺼번에 떠안게 되고, 결과적으로 응집도가 낮아진다.
  - 때로는 묻는 것이 더 좋은 방법일 수 있다.
    - 예를 들어 아래 코드에서 `is_satisfied_by` 메서드는 `Screening`에게 질의한 상영 시작 시간을 이용해 할인 여부를 결정한다.
    - 이 코드는 얼핏 보기에 `Screening`의 내부 상태를 가져와서 사용하기 때문에 캡슐화를 위반한 것으로 보일 수 있다.
    - 따라서 할인 여부를 판단하는 로직을 `Screening`의 `is_discountable` 메서드로 옮기고 `PeriodCondition`이 이 메서드를 호출하도록 변경하여 묻디 말고 시켜라 스타일을 준수하는 퍼블릭 인터페이스를 얻을 수 있다고 생각할 것이다.
    - 그러나 이 경우 `Screening`이 할인 조건을 판단하는 책임을 떠안게 되며, 이는 `Screening`의 본질적인 책임이 아니다.
    - 따라서 `Screening`의 응집도가 낮아지게 된다.
    - 또한 `PeriodCondition`의 인스턴스 변수를 인자로 받기 때문에 `PeriodCondition`의 인스턴스 변수 목록이 변경될 경우에도 영향을 받기 되어 결합도도 높아진다.
    - 따라서 묻지 말고 시켜라 스타일을 준수하여 `Screening`의 캡슐화를 높이는 것 보다, 묻는 것이 전체적인 응집도와 결합도를 높이는 방법이다.
  
  ```python
  class PeriodCondition(DiscountCondition):
      def is_satisfied_by(self, screening: Screening):
          return screening._when_screened.weekday() == self._day_of_week and \
                 self._start_time <= screening._when_screened() and \
                 self._end_time >= screening._when_screened()
      
      
  # 아래와 같이 변경하면 Screening의 응집도가 낮아지게 되고, PeriodCondition과 결합도도 높아진다.
  class Screening:
      def is_satisfied_by(self, day_of_week, start_time, end_time):
          return self._when_screened.weekday() == day_of_week and \
                 start_time <= self._when_screened() and \
                 end_time >= self._when_screened()
  ```



- 명령-쿼리 분리 원칙(Command-Query Separation, CQS)
  - 루틴
    - 어떤 절차를 묶어 호출하도록 이름을 부여한 기능 모듈을 루틴이라 부른다.
    - 루틴은 다시 프로시저(procedure)와 함수(function)로 구분할 수 있다.
    - 프로시저와 함수를 같은 의미로 혼용하는 경우가 많지만 사실 둘은 다른 개념이다.
    - 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
    - 함수는 부수효과를 발생시킬 수 없지만 값을 반환할 수 있다.
  - 명령과 쿼리
    - 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.
    - 객체의 상태를 수정하는 오퍼레이션을 명령이라 부르고, 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.
    - 개념적으로 명령은 프로시저와 동일하고 쿼리는 함수와 동일하다.
  - 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.
    - 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.
    - 명령과 쿼리를 분리하기 위해서는 아래의 두 규칙을 준수해야 한다.
    - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
    - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
  - 명령과 쿼리를 분리해야 하는 이유
    - 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어렵다.
    - 겉보기에는 쿼리처럼 보이지만 부수효과를 가지는 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다.
    - 반면에 둘을 분리할 경우 쿼리는 객체의 상태를 변경하지 않기 때문에 결과를 예측하기 쉬워진다.
    - 또한 쿼리들의 순서를 자유롭게 변경할 수도 있다.
  - 버트란드 마이어의 기계 메타포
    - 객체는 블랙박스이며 객체의 인터페이스는 객체의 관찰 가능한 상태를 보기 위한 일련의 디스플레이와 객체의 상태를 변경하기 위해 누를 수 있는 버튼의 집합이라고 가정한다.
    - 인터페이스는 두 가지 형태의 버튼으로 구성된다.
    - 둥근 버튼은 기계의 현재 상태를 출력하지만 상태는 변경하지 않는다.
    - 네모 버튼은 기계의 상태는 변경하지만 변경된 상태에 관한 정보는 제공하지 않는다.
    - 즉 둥근 버튼은 쿼리이고 네모 버튼은 명령이다.



- 명령-쿼리 분리와 참조 투명성(referential transparency)

  - 컴퓨터와 수학 세계를 나누는 가장 큰 특징은 부수효과(side effect)의 존재 유무다.
    - 프로그램에서 부수 효과를 발생시키는 두 가지 대표적인 문법은 대입문과 함수(정확히는 프로시저)다.
    - 수학의 경우 x의 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다.
    - 수학에서 함수는 입력이 동일하면 결과 역시 항상 동일하지만, 프로그래밍에서는 함수 내부에 부수효과가 포함되어 있을 경우 입력값이 동일하더라도 그 결과값이 매번 달라질 수 있다.
  - 참조 투명성
    - 수학은 참조 투명성을 엄격하게 준수하는 체계다.
    - 어떤 함수 $f(n)$이 존재할 때 $n$의 값으로 1을 대입하면 그 결과가 3이라고 가정했을 때 $f(1)$을 3으로 바꿔도 식의 결과는 바뀌지 않는다.
    - 예를 들어 $f(1)+1=4$에서 $f(1)$을 3으로 바꿔도 결과는 달라지지 않는다($3+1=4$).
    - 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 달라지지 않는 특성을 의미한다.
    - 예시에서 $f(1)$은 표현식이고 $f(1)$의 값은 3이다.
    - $f(1)$를 $f(1)$의 값인 3으로 바꾸더라도 결과는 달라지지 않으므로 참조 투명성을 만족한다.
  - 참조 투명성은 식의 순서를 변경하더라도 결과가 달라지지 않는다는 것을 의미한다.
    - 예를 들어 $f(1)+1$과 $1+f(1)$의 결과는 동일하다.
    - 식의 순서를 변경할 수 있는 이유는 식들이 모두 참조 투명성을 만족하기 때문이다.
  - 불변성(immutability)
    - 수학의 함수는 동일한 입력에 대해 항상 동일한 값을 반환하기 때문에 수학의 함수는 참조 투명성을 만족시키는 이상적인 예다.
    - 참조 투명성은 식을 값으로 대체하는 것을 허용하기에 참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.
    - $f(1)$은 어떤 경우에라도 3이며, 이처럼 어떤 값이 변하지 않는 성질을 불변성이라고 부른다.
    - 어떤 값이 불변한다는 말은 부수 효과가 없다는 말과 동일하다.

  - 부수효과, 참조 투명성, 불변성 사이의 관계
    - 수학에서 함수는 어떤 값도 변경하지 않기 때문에 부수효과가 존재하지 않는다.
    - 수학에서 함수는 부수효과가 없으므로 불변성을 가진다.
    - 수학에서 함수는 불변성을 가지므로 모든 로직이 참조 투명성을 만족시킨다.
    - 결국 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다.

  - 참조 투명성을 만족하는 식의 장점
    - 모든 함수를 이미 알고 있는 하나의 결과값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
    - 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
  - 객체지향 패러다임은 객체의 상태 변경이라는 부수효과를 기반으로 한다.
    - 따라서 객체지향에서 참조 투명성은 예외에 가깝다.
    - 그러나 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다.
  - 함수형 프로그래밍
    - 명령형 프로그래밍은 부수효과를 기반으로 한다.
    - 상태를 변경시키는 연산들을 적절한 순서대로 나열함으로써 프로그램을 작성한다.
    - 대부분의 객체지향 프로그래밍 언어들은 메시지에 의한 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 분류된다.
    - 반면에 함수형 프로그래밍은 부수효과가 존재하지 않는 수학적인 함수에 기반한다.
    - 따라서 함수형 프로그래밍에서는 참조 투명성의 장점을 극대화할 수 있으며 명령형 프로그래밍에 비해 실행 결과를 이해하고 예측하기가 더 쉽다.
    - 최근에는 다양한 객체지향 언어들이 함수형 프로그래밍 패러다임을 접목시키고 있다.



- 책임에 초점을 맞춰야한다.

  - 객체가 수행할 책임에 초점을 맞추면 위에서 살펴본 것들을 자연스럽게 지킬 수 있다.
    - 메시지를 먼저 선택한 후에 메시지를 처리할 객체를 선택해야한다.
    - 객체 구현 이전에 객체 사이의 협력에 초점을 맞춰 협력 방식을 단순하고 유연하게 만들어야 한다.
    - 정말 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지다.
  - 디미터 법칙과 책임
    - 협력이라는 맥락 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 결합도를 낮출 수 있다.
    - 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체 내부의 구조에 대해 고민할 필요가 없어진다.
    - 따라서 디미터 법칙을 위반할 위험을 최소화할 수 있다.
  - 묻지 말고 시켜라 스타일과 책임
    - 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.
    - 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
  - 의도를 드러내는 인터페이스와 책임
    - 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트 관점에서 메시지의 이름을 정한다는 것이다.
    - 당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명히 드러날 수밖에 없다.

  - 명령-쿼리 분리 원칙과 책임
    - 객체의 협력을 고민할 경우 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 대해 고민하게 된다.
    - 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.







# 객체 분해

- 분해
  - 추상화
    - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 의미한다.
    - 본질적인 정보만 남기고 불필요한 세부 사항을 걸러냄으로써 문제를 단순화할 수 있게 해준다.
  - 분해는 큰 문제를 해결 가능한 작은 문제로 나누는 추상화 기법을 의미한다.
  - 객체지향 패러다임에서의 분해
    - 객체지향 패러다임은 역할과 책임을 수행하는 자율적인 객체들의 공동체를 구축하는 것이다.
    - 여기서 역할과 책임을 수행하는 객체가 객체지향 패러다임이 이용하는 추상화다.
    - 기능을 협력하는 공동체를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 분해를 의미한다.



- 프로시저 추상화와 데이터 분해

  - 프로그래밍 언어와 추상화
    - 프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력으로 이루어졌다.
    - 어셈블리어는 숫자로 된 기계어에 인간이 이해할 수 있는 상징을 부여하려는 노력의 결과였으며, 고수준 언어는 기계적인 사고를 강요하는 낮은 수준의 명령어들을 탈피하고자 한 시도의 결과였다.
    - 추상화의 발전은 다양한 프로그래밍 패러다임의 탄생으로 이어졌다.
    - 프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정된다.
    - 결국 프로그래밍 패러다임은 적잘한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌지를 결정하는 원칙과 방법의 집합이다.
    - 따라서 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.
  - 프로시저 추상화와 데이터 추상화
    - 현대적인 프로그래밍 언어를 특징 짓는 두 가지 중요한 메커니즘이다.
    - 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.
    - 프로시저 추상화는 소프트웨어가 무엇을 해야 하는지를 추상화한다.
    - 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다.
    - 프로시저 추상화를 중심으로 시스템을 분해하는 것을 기능 분해(functional decomposition) 혹은 알고리즘 분해(algorithm decomposition)이라 부른다.
    - 데이터 중심으로 시스템을 분해하는 것은 두 가지로 나뉘는데 타입을 추상화(type abstraction)과 데이터를 중심으로 프로시저를 추상화(procedure abstracion)하는 것으로, 전자를 추상 데이터 타입(Abstract Data Type)이라 부르고 후자를 객체지향(Object-Oriented)라 부른다.

  - 프로그래밍 언어 관점에서의 객체지향
    - 프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법이다.
    - 그리고 이런 객체를 구현하기 위해 대부분의 객체지향 언어는 클래스라는 도구를 제공한다.
    - 따라서 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다.





## 프로시저 추상화와 기능 분해

- 메인 함수로서의 시스템

  - 프로시저

    - 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.
    - 프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다.
    - 따라서 프로시저는 잠재적으로 정보 은닉의 가능성을 제시하지만, 프로시저만으론 정보은닉 체계를 구축하는 데는 한계가 있다.

  - 기능 분해

    - 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐다.
    - 이 같은 시스템 분해 방식을 알고리즘 분해 또는 기능 분해라고 부른다.

    - 기능 분해의 관점에서 추상화의 단위는 프로시저이며, 시스템은 프로시저를 단위로 분해된다.

  - 시스템은 하나의 커다란 메인 함수다.

    - 프로시저 중심의 기능 분해 관점에서 시스템은 입력 값을 계산해서 출력 값을 반환하는 수학의 함수와 동일하다.
    - 이 관점에서 시스템은 더 작은 작업으로 분해될 수 있는 커다란 메인 함수다.

  - 하향식 접근법(Top-Down Approach)
    - 전통적인 기능 분해 방법은 하향식 접근법을 따른다.
    - 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.
    - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.
    - 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다.
  - 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다.
    - 기능이 우선이고 데이터는 기능의 뒤를 따른다.
    - 기능 분해를 위한 하향식 접근법은 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.
    - 이것은 유지보수에 다양한 문제를 야기한다.



- 급여 관리 시스템

  - 간단한 급여 관리 시스템을 구현할 것이다.

    - 직원들이 실제로 지급받게 되는 급여는 아래 공식에 따라 계산된다.
    - 급여 = 기본급 - (기본급*세율)

    - 급여 관리 시스템을 구현하기 위해 기능 분해 방법을 이용할 것이다.

  - 기능 분해 방법

    - 먼저 최상위의 추상적인 함수를 정의한다.
    - 최상위의 추상적인 함수 정의는 시스템의 기능을 표현하는 하나의 문장으로 나타낸다.
    - 이후 이전 문장을 보다 구체화하는 정제 과정을 거친다.
    - 각 정제 단계는 이전 문장의 추상화 수준을 감소시켜야한다.
    - 즉 모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 문장들의 조합으로 분해되어야 한다.
    - 각 단계에서 불완전하고 좀 더 구체화될 수 있는 문장이 남아있는지 검토한다.
    - 만약 좀 더 정제 가능한 문장이 있으면 동일한 과정을 거쳐 구현이 가능할 정도로 충분히 저수준의 문장이 될 때까지 기능을 분해한다.
    - 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것이다.

  - 최상위의 추상적인 함수 정의하기

    - 최상위의 추상적인 함수 정의는 시스템의 기능을 표현하는 하나의 문장으로 나타낸다.
    - 급여 관리 시스템에 대한 추상적인 최상위 문장은 아래와 같다.
    - 이 문장은 급여 관리 시스템을 시작하는 메인 프로시저로 구현될 것이다.

  ```
  직원의 급여를 계산한다.
  ```

  - 기능 분해 방법에 따라 프로시저를 좀 더 세분화된 절차로 구체화한다.
    - 급여를 계산하는 데 필요한 정보를 고려하여 좀 더 세분화한다.

  ```
  직원의 급여를 계산한다.
  	사용자로부터 소득세율을 입력받는다.
  	직원의 급여를 계산한다.
  	양식에 맞게 결과를 출력한다.
  ```

  - 아직 더 정제 가능한 문장이 남아있으므로 추가적으로 정제한다.

  ```
  직원의 급여를 계산한다.
  	사용자로부터 소득세율을 입력받는다.
  		"세율을 입력하세요: "라는 문장을 화면에 출력한다.
  		키보드를 통해 세율을 입력받는다.
      직원의 급여를 계산한다.
      	전역 변수에 저장된 직원의 기본급 정보를 얻는다.
      	급여를 계산한다.
      양식에 맞게 결과를 출력한다.
      	"이름: {직원명}, 급여: {금액}" 형식에 따라 출력 문자열을 생성한다.
  ```



- 급여 관리 시스템 구현

  - 급여 관리 시스템의 최상위 문장을 메인 함수로 매핑한다.
    - 직원의 이름을 받아 직원의 급여를 계산한다.

  ```python
  def main(name):
      ...
  ```

  - 세분화한 내용을 이용해 메인 함수의 내부를 채운다.

  ```python
  """
  직원의 급여를 계산한다.
  	사용자로부터 소득세율을 입력받는다.
      직원의 급여를 계산한다.
      양식에 맞게 결과를 출력한다.
  """
  
  def main(name):
      tax_rate = get_tax_rate()
      pay = calculate_pay_for(name, tax_rate)
      describe_result(name, pay)
  ```

  - 소득세율을 입력받는 함수를 구현한다.

  ```python
  """
  사용자로부터 소득세율을 입력받는다.
  	"세율을 입력하세요: "라는 문장을 화면에 출력한다.
  	키보드를 통해 세율을 입력받는다.
  """
  
  def get_tax_rate():
      print("세율을 입력하세요: ")
      return float(input())
  ```

  - 급여를 계산하는 코드를 구현한다.

  ```python
  """
  직원의 급여를 계산한다.
      전역 변수에 저장된 직원의 기본급 정보를 얻는다.
      급여를 계산한다.
  """
  
  employees = ["A", "B", "C"]
  base_pays = [300, 450, 400]
  
  def calculate_pay_for(name, tax_rate):
      index = employees.find(name)
      base_pay = base_pays[index]
      return base_pay - (base_pay * tax_rate)
  ```

  - 결과를 출력하는 코드를 구현한다.

  ```python
  """
  양식에 맞게 결과를 출력한다.
      "이름: {직원명}, 급여: {금액}" 형식에 따라 출력 문자열을 생성한다.
  """
  
  def describe_result(name, pay):
      print(f"이름: {name}, 급여: {pay}")
  ```

  - 위와 같이 하향식 기능 분해로 설계한 시스템은 메인 함수를 루트로 하는 트리로 표현할 수 있다.
    - 트리에서 각 노드는 시스템을 구성하는 프로시저를 의미한다.
    - 한 노드의 자식 노드는 부모 노드를 구현하는 절차중의 한 단계를 의미한다.



- 하향식 분해가 유용한 경우
  - 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다.
    - 그러나 설계를 문서화하는 데 적절한 방법이 좋은 구조를 설계할 수 있는 방법과 동일한 것은 아니다.
    - 마이클 잭슨은 "하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이나 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다"라고 말한다.
  - 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임일 수 있다.
    - 특히 프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데는 훌륭한 방법이다.
    - 그러나 실제로 동작하는 커다란 소프트웨어를 설꼐하는 데 적합한 방법은 아니다.





### 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성되어 있지 않다.
  - 어떤 시스템도 최초에 릴리스 됐던 당시의 모습을 그대로 유지하지 않는다.
    - 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다.
    - 이는 시스템이 오직 하나의 메인함수로 구현된다는 개념과 모순된다.
    - 처음에는 중요하게 생각됐던 메인 함수는 동등하게 중요한 여러 함수들 중 하나로 전락하고 만다.
  - 시스템이 커질수록 모든 기능을 자식 노드로 가지는 하나의 메인 기능을 선택하기 어려워진다.
    - 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않는다.
    - 모든 기능은 기능성의 측면에서는 동등하게 독립적이고 완결된 하나의 기능을 표현한다.
  - 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.



- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.

  - 시스템 안에는 여러 개의 정상(top)이 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.
    - 기존 로직과는 아무 상관이 없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 합수의 구조를 급격하게 변경할 수밖에 없다.
  - 예를 들어 모든 직원의 기본급의 총합을 구한느 기능을 추가해달라는 새로운 요구사항이 접수됐다고 가정해보자.
    - 기존의 메인 함수는 직원 각각의 급여를 계산하는 것이 목적이므로 전체 직원들의 기본급 총액을 계산하는 함수가 들어설 자리가 마땅치 않다.
    - 전체 직원의 급여 총액을 계산하는 함수와 개별 직원의 급여를 계산하는 기존의 `main` 함수는 개념적으로 동등한 수준의 작업을 수행한다.
    - 따라서 `main` 함수 안에서 급여 총액을 계산하는 함수를 호출할 수는 없다.
    - 이 문제를 해결하는 방법은 `main`함수 안의 로직 전체를 하나의 함수로 묶은 후 분기를 주는 것이다.

  ```python
  class Operation(Enum, str):
      PAY = auto()
      SUM = auto()
  
  def calculate_pay(name):
      tax_rate = get_tax_rate()
      pay = calculate_pay_for(name, tax_rate)
      describe_result(name, pay)
      
  def sum_of_base_pay():
      print(sum(base_pays))
      
  def main(operation, name=None):
      if operation == Operation.PAY:
          calculate_pay(name)
      else:
          sum_of_base_pay()
  ```

  - 이처럼 단일 정상인 메인 함수에서 출발한다는 하향식 접근법의 기본 가정은 새로운 함수가 추가될 때 마다 `main` 함수의 내부 구현을 수정하게 한다.



- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
  - 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.
    - 위에서 살펴본 것 처럼 급여를 계산하는 기능은 세분화하면 "사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다."는 말로 표현 가능하다. 
    - 이 말에는 급여를 계산하는 비즈니스 로직과 관련된 관심사와 소득 세율을 입력 받아 결과를 화면에 출력한다는 사용자 인터페이스의 관심사가 한데 섞여 있다.
    - 결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.
    - 따라서 관심사의 분리라는 아키텍처 설계의 목적을 달성하기 어렵다.
  - 문제는 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다는 것이다.
    - 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분이다.
    - 반면 비즈니스 로직은 상대적으로 변경이 적게 발생한다.
    - 하향식 접근법은 비즈니스 로직과 사용자 인터페이스를 한데 섞기 때문에 사용자 인터페이스를 변경하는 경우 비즈니스 로직까지 변경에 영향을 받게 된다.
    - 따라서 하향식 접근법은 근본적으로 불안정한 아키텍처를 낳는다.
  - 위에서 구현한 급여 계산 시스템 역시 같은 문제를 가지고 있다.
    - 콘솔 기반이었던 UI를 GUI 기반으로 변경한다고 가정해보자.
    - 급여를 계산하는 `calculate_pay` 함수를 수정하지 않고도 GUI 기반의 애플리케이션으로 수정할 수는 없다.
    - 또한 콘솔 기반의 UI를 유지한다 하면서 새로운 GUI 기반의 사용자 인터페이스를 추가한다고 해도 함수 수정 없이는 불가능하다.
    - 이 상황에 사용자 인터페이스를 변경하는 유일한 방법은 전체 구조를 재설계하는 것 뿐이다.



- 너무 이른 시기에 함수들의 실행 순서를 고정시켜 유연성과 재사용성이 저하된다.
  - 하향식 분해는 시스템이 무엇을 해야하는지가 아니라 어떻게 해야하는지에 집중하게 한다.
    - 하향식 분해 과정 자체가 하나의 함수를 더 작은 함수로 분해하고 분해된 함수들의 실행 순서를 결정하는 작업이기 때문이다.
  - 하향식 접근법은 시간 제약(temporal constraint)을 강조하여 유연성이 떨어진다.
    - 시간 제약이란 함수들의 실행 순서를 정의하는 것을 의미한다.
    - 메인 함수가 작은 함수들로 분해되기 위해서는 우선 함수들의 순서를 결정해야 한다.
    - 급여 계산에 필요한 함수들의 실행 순서를 미리 결정하지 않는 한 기능 분해를 진행할 수 없다.
    - 문제는 함수의 제어 구조가 빈번한 변경의 대상이라는 점이다.
    - 기능이 추가되거나 변경될 때마다 초기에 결정된 함수들의 제어 구조가 올바르지 않다는 것이 판명된다.
    - 결과적으로 기능을 추가하거나 변경하는 작업은 매번 기존에 결정된 함수의 제어 구조를 변경하도록 만든다.
  - 하향식 접근법을 통해 분해한 함수들은 재사용이 어렵다.
    - 모든 함수는 상위 함수를 분해하는 과정에 따라 식별되며, 그에 따라 상위 함수가 강요하는 문맥 안에서만 의미를 가지기 때문이다.
    - 함수가 재사용 가능하려면 상위 함수보다 더 일반적이어야한다.
    - 하지만 하향식 접근법을 따를 경우 분해된 하위 함수는 항상 상위 함수보다 문맥에 더 종속적이다.
    - 이는 정확하게 재사용성과 반대되는 개념이다.
  - 하향식 설계와 관련된 모든 문제의 원인은 결합도다.
    - 함수는 상위 함수가 강요하는 문맥에 강하게 결합된다.
    - 함수는 함께 절차를 구성하는 다른 함수들과 시간적으로 강하게 결합되어 있다.
    - 강한 결합도는 시스템을 변경에 취약하게 만들고 이해하기 어렵게 만든다.
    - 강하게 결합된 시스템은 아주 사소한 변경만으로도 전체 시스템을 크게 요동치게 만들 수 있다.
    - 현재의 문맥에 강하게 결합된 시스템은 다른 문맥으로 옮겨갔을 때 재사용하기 어렵다.
    - 가장 큰 문제는 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합된다는 것이다.



- 데이터 변경으로 인한 파급 효과

  - 하향식 기능 분해는 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.

    - 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵기 때문이다.

    - 개별 함수가 어떤 데이터를 사용하는지 파악하는 것은 어렵지 않지만 어떤 데이터가 어떤 함수에 의존하는지를 파악하는 것은 어렵다.
    - 그리고 이는 테스트를 어렵게 만든다.
    - 대규모 시스템이서 데이터를 참조하는 함수들을 찾아 정상적으로 동작하는지 여부를 테스트 하는 것은 기술 보다는 운의 문제다.

  - 급여 관리 시스템의 변경사항

    - 아르바이트 직원에 대한 급여를 계산하는 기능을 추가해야 한다고 가정해보자.
    - 아르바이트 직원은 고정된 급여를 받는 것이 아니라 일한 시간에 시급을 곱한 금액만큼을 지급받는다.

  - 변경에 따른 데이터 추가 및 변경

    - 아르바이트 직원의 이름과 시급은 정규 직원의 이름과 기본급을 보관하던 전역 변수 `employees`와 `base_pays`에 보관하기로 했다.
    - 각 전역변수 내에서 특정 인덱스의 값이 정규직의 것인지 아르바이트 직원의 것인지 여부를 저장하는 새로운 전역 변수 `hourlys`를 추가한다.
    - 또한 아르바이트 직원의 한달 간 업무 누적 시간을 저장할 전역 변수 `timeCards`도 추가한다.

  ```python
  employees = ["A", "B", "C", "D", "E"]
  base_pays = [300, 450, 400, 1, 1.2]
  # 정규직은 False다.
  hourlys = [False, False, False, True, True]
  # 정규직은 0이다.
  time_cards = [0, 0, 0, 120, 110]
  ```

  - 변경에 따른 함수 변경
    - `employees`와 `base_pays`를 사용하는 함수 중에서 아르바이트 직원을 함께 처리해야 하는 함수를 찾아 수정해야 한다.
    - 물론 `hourlys`와 `time_cards`에 저장된 값도 함께 사용하도록 수정해야 한다.

  ```python
  def calculate_hourly_pay_for(name, tax_rate):
      index = employees.find(name)
      base_pay = base_pays[index] * time_cards[index]
      return base_pay - (base_pay * tax_rate)
  ```

  - 아르바이트 직원인지 여부를 판단하는 함수를 추가한다.

  ```python
  def is_hourly(name):
      return hourlys[employees.find(name)]
  ```

  - `calculate_pay` 함수를 수정한다.

  ```python
  def calculate_pay(name):
      tax_rate = get_tax_rate()
      if is_hourly(name):
          pay = calculate_hourly_pay(name, tax_rate)
      else:
          pay = calculate_pay_for(name, tax_rate)
      describe_result(name, pay)
  ```

  - 모든 직원의 기본급 총합을 더하는 `sum_of_base_pay` 함수도 수정해야한다.

    - 요구사항은 아르바이트 직원에 대한 급여를 계산하는 기능을 추가였지만, 전혀 상관 없는 모든 직원의 기본급 총합을 더하는 함수도 수정을 해야 한다.

    - 만약 `sum_of_base_pay` 함수가 데이터 변경에 영향을 받는다는 사실을 몰라 수정하지 못했다면, 이는 버그로 이어지게 된다.

  - 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.

    - 이를 위해서는 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서 제공되는 함수만 이용해 데이터에 접근해야 한다.
    - 즉, 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다.
    - 이것이 의존성 관리의 핵심이다.





## 모듈과 추상 데이터 타입

- 정보 은닉과 모듈

  - 정보 은닉

    - 시스템을 모듈 단위로 분해하기 위한 기본 원리다.
    - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.
    - 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리다.
    - 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.

  - 모듈과 기능분해

    - 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.
    - 기능 분해가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면, 모듈 분해는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다.
    - 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.

  - 모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

    - 복잡성: 모듈이 너무 복잡한 경우 이해와 사용이 어렵다. 외부에 추상화할 수 있는 간단한 인터페이스를 제공하여 모듈의 복잡도를 낮춰야한다.

    - 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

  - 데이터 캡슐화와 정보 은닉

    - 시스템의 가장 일반적인 비밀은 데이터다.
    - 그리고 이 점이 데이터 캡슐화와 정보 은닉을 같은 개념이라고 혼동하게 만든다.
    - 그러나 이 둘은 엄연히 다른 개념이다.
    - 데이터 캡슐화는 데이터와 메서드를 하나의 단위로 통합하고 퍼블릭 메서드를 통해서만 접근하도록 하는 것을 말한다.
    - 정보 은닉이 데이터를 포함한 변경과 관련된 모든 비밀을 감추는 반면, 데이터 캡슐화는 비밀의 한 종류인 데이터를 감추는 캡슐화의 한 종류일 뿐이다.



- 모듈의 장점과 한계
  - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
    - 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.
    - 어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 된다.
    - 모듈은 데이터 변경으로 인한 파급 효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기가 더 용이하다.
  - 비즈니스 로직과 인터페이스에 대한 관심사를 분리한다.
    - 사용자 인터페이스를 모듈 외부에 구현하여 모듈에서는 비즈니스 로직만 구현하면 된다.
    - 사용자 인터페이스가 변경되더라도 모듈 내부의 비즈니스 로직은 변경되지 않는다.
  - 전역 변수와 전역 함수를 네임스페이스 오염을 방지한다.
    - 모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.
    - 변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있게 된다.
    - 따라서 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.
  - 모듈 내부는 높은 응집도를 유지하고, 모듈과 모듈 사이는 높은 결합도를 유지한다.
    - 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.
    - 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이므로 높은 응집도를 유지한다.
    - 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신하므로 낮은 결합도를 유지한다.
  - 모듈의 한계
    - 태생적으로 변경을 관리하기 위한 구현 기법이기에 한계점이 명확하다.
    - 가장 큰 단점은 인스턴스의 개념을 제공하지 않는다는 점이다.
    - 좀 더 높은 수준의 추상화를 위해서는 인스턴스 단위로 다룰 수 있어야한다.
  - 모듈의 한계를 극복하기 위해 추상 데이터 타입의 개념이 등장했다.



- 추상 데이터 타입

  - 타입

    - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.
    - 타입은 저장된 값에 대해 수행할 수 있는 연산의 집합을 결정하기 때문에 변수의 값이 어떻게 행동할 것이라는 것을 예측할 수 있게 한다.

  - 데이터 추상화

    - 기능 분해 방식을 사용하던 절차형 언어들은 적은 수의 내장 타입만 제공했으며, 새로운 타입을 추가하는 것이 불가능하거나 제한적이었다.
    - 프로시저 추상화로는 프로그램의 표현력을 향상시키는 데 한계가 있다고 생각한 바바라 리스코프는 데이터 추상화의 개념을 제안했다.
    - 추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.
    - 이는 오퍼레이션을 이용해 추상 데이터 타입을 정의할 수 있음을 의미한다.
    - 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 행위가 구현되는 세부 사항에 대해서는 무시한다.

  - 추상 데이터 타입의 의의

    - 사람들은 '직원의 급여를 계산한다'라는 하나의 커다란 절차를 이용해 사고하기 보다는 '직원', '급여'와 같은 추상적인 개념들을 머릿속에 떠올린 후 이들을 이용해 '계산'에 필요한 절차를 생각하는 데 익숙하다.
    - 추상 데이터 타입은 프로시저 추상화 대신 데이터 추상화를 기반으로 소프트웨어를 개발하게 한 최초의 발걸음이다.
    - 추상 데이터 타입은 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킨다.
    - 모듈과는 달리 추상 데이터 타입은 인스턴스를 생성할 수 있기에 개별 인스턴스를 독립적인 개체로 다루게 해준다.

  - 추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다.
  
    - 타입 정의를 선언할 수 있어야 한다.
    - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
    - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
    - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
  
  
  - 추상 데이터 타입의 한계
    - 추상 데이터 타입 정의를 기반으로 객체를 생성하는 것은 가능하지만 여전히 데이터와 기능을 분리해서 바라본다는 문제가 있다.
    - 추상 데이터 타입은 말 그대로 시스템의 상태를 저장할 데이터를 표현한다.
    - 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다.
    - 추상 데이터 타입은 데이터에 대한 관점을 설계의 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있다.
  - 추상 데이터 타입의 본래 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것이다.
    - 프로그래밍 언어 관점에서 추상 데이터 타입은 프로그래밍 언어의 내장 데이터 타입과 동일하다.
    - 추상 데이터 타입에 대한 위와 같은 관점은 클래스와 추상 데이터 타입이 동일한 것인가 하는 의문에 빠지게 한다.



## 클래스

- 클래스는 추상 데이터 타입인가?
  - 클래스를 추상 데이터 타입으로 보는 관점이 있다.
    - 클래스와 추상 데이터 타입 모두 데이터 추상화를 기반으로 시스템을 분해하기에 이 관점이 꼭 틀린 것은 아니다.
    - 두 메커니즘 모두 외부에서는 객체의 내부 속성에 접근할 수 없으며 오직 퍼블릭 인터페이스를 통해서만 외부와 의사소통 할 수 있다.
  - 명확한 의미에서 둘은 동일하지 않다.
    - 가장 핵심적인 차이는 클래스는 상속과 다형성을 지원하는데, 추상 데이터 타입은 그렇지 않다는 점이다.
    - 상속과 다형성을 지원하는 객체지향 프로그래밍과 구분하기 위해 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍을 객체 기반 프로그래밍이라고 부르기도 한다.
    - 윌리엄 쿡은 추상 데이터 타입은 타입을 추상화(type abastraction)한 것이고 클래스는 절차를 추상화(procedural abstraction)한 것이라고 말한다.



- 타입 추상화
  - 추상 데이터 타입의 경우 하나의 대표적인 타입이 다수의 세부적인 타입을 감추기 때문에 윌리엄 쿡은 이를 타입 추상화라 불렀다.
  - 타입 추상화는 개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄하도록 함으로써 하나의 물리적인 타입 안에 전체 타입을 감춘다.
    - 따라서 타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다.
    - 타입 추상화를 기반으로 하는 대표적인 기법이 바로 추상 데이터 타입이다.
  - 예를 들어 정규직과 아르바이트를 포함하는 `Employee`라는 추상 데이터 타입이 있다고 가정해보자.
    - `Employee`를 사용하는 클라이언트는 `Employee`의 operation(`calculate_pay` 등)을 호출할 수 있지만, 내부에 정규직이나 아르바이트가 있다는 사실은 알 수 없다.
    - `name`을 인자로 넘겨서 `calculate_pay`를 호출했을 때, 클라이언트는 `calculate_pay`라는 오퍼레이션이 정규직의 임금을 계산할지, 아르바이트의 임금을 계산할지 알 지 못한다.
    -  `calculate_pay`라는 오퍼레이션은 정규직과 아르바이트라는 개념적인 타입에 대한 구현을 포괄하기에(즉, 두 타입에 대한 임금 계산을 포괄하기에) 클라이언트 입장에서는 `Employee`라는 물리적인 타입 안에 정규직과 아르바이트라는 전체 타입이 감춰져 있다.
    - 결국 개념적인 타입에 대한 구현을 포괄하는 오퍼레이션을 기준으로 두 개의 타입이 통합된 것이다.
    - 두 직원 타입은 `Employee` 내부에 감춰져 있으며 암묵적이다.



- 객체지향

  - 객체지향과 타입 추상화의 차이
    - 추상 데이터 타입은 오퍼레이션을 기준으로 타입들을 추상화하지만, 클래스는 타입을 기준으로 절차를 추상화한다.
    - 즉, 추상 데이터 타입은 오퍼레이션이 실행될 때 어떤 타입을 대상으로 실행되는지를 추상화하고, 클래스는 어떤 타입의 오퍼레이션을 실행할 때 어떤 오퍼레이션이 실행될지를 추상화한다.
    - 객체지향 에서는 정규직과 아르바이트를 두 개의 타입으로 명시적으로 정의하고 두 직원 유형과 관련된 오퍼레이션의 실행 절차를 두 타입에 분배한다.
    - 결과적으로 객체지향은 정규직과 아르바이트 직원 각각에 대한 클래스를 정의하고 각 클래스들이 필요한 오퍼레이션을 적절하게 구현하게 한다.
  - 객체지향은 절차 추상화다.
    - 정규직과 아르바이트를 두 클래스로 분리할 경우 공통 로직을 어디에 둘 것인지가 문제가 된다.
    - 공통 로직을 포함할 부모 클래스를 정의하고 두 직원 유형의 클래스가 부모 클래스를 상속받게 한다.
    - 클라이언트는 부모 클래스의 참조자에 대해 메시지를 전송하면 실제 클래스가 무엇인가에 따라 적절한 절차가 실행된다.
    - 즉 동일한 메시지에 대해 서로 다르게 반응하는데, 이것이 바로 다형성이다.
    - 실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.
    - 즉, 객체 지향은 절차를 추상화한다.



- 변경을 기준으로 선택하라
  - 타입을 기준으로 절차를 추상화해야한다.
    - 단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지는 않는다.
    - 타입을 기준으로 절차를 추상화해야 객체지향 분해라 할 수 있다.
  - 객체지향은 타입 변수를 이용한 조건문을 다형성으로 대체한다.
    - 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다.
    - 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.
    - 흔히 객체지향이란 조건문을 제거하는 것이라는 편협한 견해가 널리 퍼진 이유가 바로 이 때문이다.
    - 조건문을 사용하는 방식을 기피하는 이유 역시 변경 때문으로, 타입이 추가될 때마다 조건문에 분기가 추가되어야 하기 때문이다.
  - 개방-폐쇄 원칙(Open-Closed Principle, OCP)
    - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 의미한다.
    - 이것이 객체지향 설계가 전통적인 방식에 비해 변경하고 확장하기 쉬운 구조를 설계할 수 있는 이유다.
  - 추상 데이터 타입이 틀렸다는 것이 아니다.
    - 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.
    - 새로운 타입을 빈번하게 추가해야 한다면 객체지향을 선택해야 한다.
    - 반면에 새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택해야 한다.
    - 객체지향의 경우 새로운 오퍼레이션을 추가하기 위해서는 상속 계층에 속하는 모든 클래스를 한 번에 수정해야 한다.
    - 이와 달리 추상 데이터 타입의 경우에는 전체 타입에 대한 구현 코드가 하나의 구현체 내에 포함되어 있기 때문에 새로운 오퍼레이션을 추가하는 작업이 상대적으로 간단하다.







# 핵심

- 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.



- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.
