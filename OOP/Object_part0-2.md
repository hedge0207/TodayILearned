## 객체 지도

- 모르는 길을 찾는 방법
  - 일반적으로 모르는 길을 찾을 때 사람들은 두 가지 방법 중 하나를 이용해 길을 찾는다.
    - 다른 사람에게 길을 묻는다.
    - 지도를 보고 길을 찾는다.
  - 기능적이고 해결책 지향적인 접근법
    - 다른 사람에게 길을 묻는 것이 이에 해당한다.
    - 이 방식은 일반적이지도, 재사용 가능하지도 않다.
    - 강이나 건물 같은 랜드마크가 없다면 경로를 설명하기 어려울 뿐만 아니라 길을 물어본 위치에 따라서 설명이 달라진다.
    - 또한 현재 위치에서 목적지로 이동하는 현재의 요구만을 충족시킬 수 있다.
  - 구조적이고 문제 지향적인 접근법
    - 지도를 보고 길을 찾는 것이 이에 해당한다.
    - 지도에는 길을 찾는데 필요한 모든 정보가 포함되어 있기 때문에 랜드마크도 필요 없고 어느 위치에서 지도를 펼치든 동일한 정보를 제공한다.
    - 길을 찾는 데 필요한 구체적인 기능이 아니라 길을 찾을 수 있는 구조를 제공한다.
    - 목적지로 가는 길을 찾는 현재의 요구뿐 아니라 다양한 목적을 위해 재사용 될 수 있다.
  - 지도가 범용적인 이유는 지도를 사용하려는 사람들이 원하는 "기능"에 비해 지도에 표시된 "구조"가 더 안정적이기 때문이다.
    - 사람들이 원하는 기능은 현재 위치에서 목적지까지 가고 싶다는 것이다.
    - 그런데 이는 사용자의 현재 위치에 따라, 목적지에 따라 지속적으로 변경하므로 안정적이지 않다.
    - 반면에 지도는 상대적으로 변하지 않는 지형 정보를 기반으로 하기에 보다 안정적이다.
  - 객체지향은 자주 변경되는 기능이 아니라 안정적인 구조를 기반으로 시스템을 구조화한다.
    - 전통적인 소프트웨어 개발 방법은 변경이 빈번하게 발생하는 기능에 안정적인 구조를 종속시키는 방법으로, 위 예시에서는 길을 묻는 방식과 유사하다.
    - 반면에 객체지향 개발 방법은 안정적인 구조에 변경이 빈번하게 발생하는 기능을 종속시키는 지도의 방법과 유사하다.
    - 기능이 아니라 구조를 기반으로 모델을 구축하는 것이 더 범용적이고 이해하기 쉬우며 변경에 안정적이다.
    - 따라서 변경되는 기능이 아니라 안정적인 구조에 따라 역할, 책임, 협력을 구성해야한다.



- 기능 설계와 구조 설계
  - 기능과 구조
    - 모든 소프트웨어 제품의 설계에는 기능과 구조라는 두 가지 측면이 존재한다.
    - 기능 측면의 설계는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다.
    - 구조 측면의 설계는 제품의 형태가 어떠해야 하는지에 초점을 맞춘다.
    - 훌륭한 기능이 소프트웨어를 만드는 충분조건이라고 한담면 훌륭한 구조는 훌륭한 소프트웨어를 만드는 필요조건이다.
    - 설계에는 이 두 가지 측면이 모두 녹아들어야한다.
  - 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것이다.
    - 설계가 어려운 이유는 기능이 변경되기 때문이다.
    - 미래의 변경에 대비할 수는 있지만 미래의 변경을 예측할 수는 없다.
    - 따라서 미래에 대비하는 가장 좋은 방법은 변경을 수용할 수 있는 여지를 설계에 마련해 놓는 것이다.



- 구조 설계
  - 구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
  - 도메인 모델
    - 사용자가 프로그램을 사용하는 대상 분야를 도메인이라 한다.
    - 모델은 대상을 단순화해서 표현한 것으로, 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.
    - 결국 도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태라고 할 수 있다.
    - 도메인 모델은 소프트웨어 개발과 관련된 이해관계자들이 도메인에 대해 생각하는 관점이다.
  - 멘탈 모델
    - 도메인 모델은 단순히 다이어그램이 아닌 이해관계자들이 바라보는 멘탈 모델이다.
    - 멘탈 모델은 사람들이 자신, 타인, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다.
    - 멘탈 모델은 사용자 모델, 디자인 모델, 시스템 이미지로 구분된다.
    - 사용자 모델: 사용자가 제품에 대해 갖고 있는 개념들의 모습.
    - 디자인 모델: 설계자가 마음 속에 갖고 있는 시스템에 대한 개념화.
    - 시스템 이미지: 최종 제품.
    - 사용자 모델과 디자인 모델이 동일하다면 이상적이겠지만 사용자와 설계자는 직접 상호작용 할 수 없으며 최종 제품인 시스템을 통해서만 의사소통 할 수 있다.
    - 따라서 설계자는 디자인 모델을 기반으로 사용자 모델을 정확하게 반영하도록 노력해야한다.
    - 도메인 모델은 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지를 포괄하도록 추상화한 소프트웨어 모델이다.

  - 도메인의 모습을 담을 수 있는 객체지향
    - 도널드 노먼(Donald Norman)은 제품을 설계할 때 제품에 관한 모든 것이 사용자들이 제품에 대해 가지고 있는 멘탈 모델과 정확히 일치해야한다고 주장한다.
    - 요약하자면 최종 제품은 사용자의 관점을 반영해야 한다는 것이다.
    - 이는 소프트웨어 개발에도 동일하게 적용할 수 있다.
    - 최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야한다.
    - 이는 곧 애플리케이션이 도메인 모델을 기반으로 설계되어야 한다는 것을 의미한다.
    - 도메인 모델이란 사용자들이 도메인을 바라보는 관점이며, 설계자가 시스템의 구조를 바라보는 관점인 동시에, 소프트웨어 안에 구현된 코드의 모습 그 자체이기 때문이다.
    - 객체지향은 사람들이 만지고 느끼고 볼 수 있는 실체를 시스템 안의 객체로 재창조할 수 있게 해준다.
    - 따라서 객체지향을 사용하면 사용자들이 이해하고 있는 도메인의 구조와 최대한 유사하게 코드를 구조화할 수 있다.
    - 결과적으로 객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만드는 것이 가능하다.
    - 객체지향의 이러한 특징을 연결완전성 또는 표현적 차이라고한다.
  - 소프트웨어 객체는 현실 객체에 대한 추상화가 아니다.
    - 소프트웨어 객체와 현실 객체 사이의 관계를 가장 효과적으로 표현할 수 있는 단어는 바로 은유다.
    - 소프트웨어 객체는 현실 객체를 모방한 것이 아니라 은유를 기반으로 재창조한 것이다.
    - 따라서 소프트웨어 객체는 현실 객체가 갖지 못한 특성을 가질 수도 있고 현실 객체가 하지 못하는 행동을 할 수도 있다.
  - 표현적 차이
    - 비록 소프트웨어 객체가 현실 객체를 왜곡한다고 하더라도 소프트웨어 객체는 현실 객체의 특성을 토대로 구축된다.
    - 이와 같은 현실 객체와 소프트웨어 객체 사이의 의미적 거리를 가리켜 표현적 차이 또는 의미적 차이라고 한다.
    - 핵심은 은유를 통해 현실 객체와 소프트웨어 객체 사이의 차이를 최대한 줄이는 것이다.
  - 은유를 통해 투영해야 하는 대상은 현실 객체가 아닌 사용자가 도메인에 대해 생각하는 개념들이다.
    - 대부분의 소프트웨어 도메인은 현실에 존재하지 않는 가상의 세계를 대상으로 한다.
    - 가상의 세계를 창조하는 작업에서 현실 객체를 은유하는 것은 불가능하다.
    - 따라서 소프트웨어 객체를 창조하기 위해서 은유해야 하는 대상은 도메인 모델이다.
    - 소프트웨어 객체는 그 대상이 현실적인지 여부와 무관하게 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야한다.
    - 도메인 모델을 기반으로 설계하고 구현함으로써 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있게 되고, 결과적으로 표현적 차이는 줄어들게 되며 사용자의 멘탈 모델이 코드에 녹아들게 된다.
  - 표현적 차이의 중요성
    - 표현적 차이가 중요한 이유는 소프트웨어를 이해하고 수정하기 쉽게 만들어주기 때문이다.
    - 코드의 구조가 도메인의 구조를 반영하기 때문에 도메인을 이해하면 코드를 이해하기가 훨씬 수월해진다.
    - 도메인 속의 개념과 관계가 코드 속에 녹아 있기 때문이다.
  - 불안정한 기능을 담는 안정적인 도메인 모델
    - 도메인 모델을 기반으로 코드를 작성하는 두 번재 이유는 도메인 모델이 제공하는 구조가 상대적으로 안정적이기 때문이다.
    - 도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것이다.
    - 도메인에 대한 사용자의 관점을 반영하는 이유는 사용자들이 누구보다도 도메인의 본질적인 측면을 가장 잘 이해하고 있기 때문이다.
    - 본질적이라는 것은 변경이 적고 그 특성이 오랜 시간 유지된다는 것을 의미한다.
    - 사용자 모델에 포함된 개념과 규칙은 비교적 변경될 확률이 적기 때문에 사용자가 모델을 기반으로 설계와 코드를 만들면 변경에 쉽게 대처할 수 있는 가능성이 커진다.
    - 이는 도메인 모델이 기능을 담을 수 있는 안정적인 구조를 제공할 수 있음을 의미한다.
    - 결론적으로 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있다.
    - 도메인 모델은 기능을 구현할 때 참조할 수 있는 궁극적인 지도다.
  - 도메인 모델이 안정적인 이유
    - 도메인 모델을 구성하는 개념은 비즈니스가 완전히 없어지거나 완전히 개편되지 않는 한 안정적으로 유지된다.
    - 도메인 모델을 구성하는 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지된다.



- 연결 완전성
  - 객체지향의 가장 큰 장점은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다는 것이다.
    - 따라서 도메인 모델링에서 사용한 객체와 개념을 프로그래밍 설계에서의 객체와 클래스로 매끄럽게 변환할 수 있다.
    - 객체지향의 이와 같은 특성을 연결완전성이라 한다.
  - 연결완전성의 역방향 역시 성립한다.
    - 즉 코드의 변경으로부터 도메인 모델의 변경 사항을 유추할 수 있다.
    - 객체지향에서는 도메인 모델과 코드 모두 동일한 모델링 패러다임을 공유하기 때문에 코드의 수정이 곧 모델의 수정이 된다.
    - 이처럼 코드에서 모델로의 매끄러운 흐름을 가역성이라 한다.
  - 도메인 모델은 문서나 다이어그램이 아니다.
    - 도메인 모델은 사람들의 머릿속에 들어 있는 공유된 멘탈 모델이다.
    - 따라서 별도의 문서나 다이어그램을 가지고 있지 않더라도 사람들의 머릿속에 유사한 모델이 공유될 수 있다면 그것으로 충분하다.
    - 사람들이 동일한 용어와 동일한 개념을 사용해 의사소통하고 코드로부터 도메인 모델을 유추할 수 있게 하는 것이 도메인 모델의 진정한 목표다.



- 기능 설계
  - 실제로 사용자에게 중요한 것은 도메인 모델이 아니라 소프트웨어이 기능이다.
    - 소프트웨어의 존재 이유는 상용자가 원하는 목표를 달성할 수 있는 다양한 기능을 제공하는 것이다.
    - 따라서 사용자에게 제공할 기능을 기술한 정보가 필요하다.
  - 유스케이스
    - 기능적 요구사항이란 시스템이 사용자에게 제공해야하는 기능의 목록을 정리한 것이다.
    - 훌륭한 기능적 요구사항을 얻기 위해서는 목표를 가진 사용자와 사용자의 목표를 만족시키기 위해 일련의 절차를 수행하는 시스템 간의 상호작용 관점에서 시스템을 바라봐야한다.
    - 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라한다.
    - 유스케이스는 이바 야콥슨의 『Object-Oriented Software Engineering - A Use Case Driven Approach』에서 처음 소개된 이후 앨리스터 코오번에 의해 체계화 됐다.
  - 앨리스터 코오번은 유스케이스를 아래와 같이 설명한다.
    - 유스케이스는 시스템의 이해관계자들 간의 계약을 행위 중심으로 파악한다.
    - 유스케이스는 이해관계자들 중에서 일차 액터라 불리는 행위자의 요청에 대한 시스템의 응답으로서, 다양한 조건하에 있는 시스템의 행위를 서술한다.
    - 일차 액터는 어떤 목표를 달성하기 위해 시스템과의 상호 작용을 시작한다.
    - 시스템은 모든 이해관계자들의 요구에 응답하고 이해관계를 보호해야한다.
    - 특별한 요청과 관계되는 조건에 따라 서로 다른 일련의 행위 혹은 시나리오가 전개될 수 있다.
    - 유스케이스는 이렇게 서로 다른 시나리오를 묶어 준다.



- 유스케이스의 특성

  - 유스케이스는 텍스트다.
    - 유스케이스는 다이어그램이 아니다.
    - 중요한 것은 유스케이스 안에 포함되어 있는 상호작용의 흐름이다.
    - 유스케이스의 핵심은 사용자와 시스템 간의 상호작용을 일련의 이야기 흐름으로 표현하는 것이다.
  - 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.
    - 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다.
    - 시나리오를 유스케이스 인스턴스라고도 한다.
  - 유스케이스는 단순한 feature 목록과 다르다.
    - Feature는 시스템이 수행해야하는 기능의 목록을 단순하게 나열한 것이다.
    - 유스케이스는 feature를 포함하는 이야기를 제공함으로써 시스템의 기능에 대해 의사소통할 수 있는 문맥을 얻을 수 있다.
    - 유스케이스의 강점은 단순히 기능을 나열하는 것이 아니라 이야기를 통해 연관된 기능들을 함께 묶을 수 있다는 점이다.
  - 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함해선 안 된다.
    - 유스케이스는 자주 변경되는 사용자 인터페이스 요소는 배제하고 사용자 관점에서 시스템의 행위에 초점을 맞춘다.
    - 이처럼 사용자 인터페이스를 배제한 유스케이스 형식을 본질적인 유스케이스라고 한다.
  - 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.
    - 유스케이스의 목적은 연관된 시스템의 기능을 이야기 형식으로 모으는 것이지 내부 설계를 설명하는 것이 아니다.
    - 과거의 객체지향 서적에서는 유스케이스에 나타나는 명사를 클래스로, 동사를 메서드로 대응시키는 방식으로 객체지향 설계를 설명하기도 했지만 객체지향 설계는 그렇게 간단하지 않다.

  - 유스케이스는 설계 기법도, 객체지향 기법도 아니다.
    - 유스케이스가 단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다는 점에 주목해야한다.
    - 유스케이스는 시스템의 내부 구조나 실행 메커니즘에 대한 어떤 정보도 제공하지 않는다.
    - 유스케이스는 객체지향과도 상관이 없다.
    - 유스케이스는 객체지향 이외의 패러다임에서도 적용 가능하며, 객체지향도 유스케이스 이외의 방법으로 요구사항을 명시할 수도 있다.
    - 유스케이스는 객체의 구조나 책임에 대한 어떤 정보도 제공하지 않는다.
    - 다만 유스케이스 텍스트 안에서 도메인 모델에서 사용할 용어에 대한 힌트를 얻을 수는 있다.



- 객체지향에서 도메인 모델과 유스케이스의 활용

  - 정리
    - 도메인 모델은 안정적인 구조를 개념화하기 위해, 유스케이스는 불안정한 기능을 서술하기 위해 가장 일반적으로 사용되는 도구다.
    - 변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배해야한다.
  - 유스케이스에서 사용자와 상호작용하는 시스템을 하나의 거대한 객체로 본다.
    - 사용자에게 시스템이 수행하기로 약속한 기능은 결국 시스템의 책임으로 볼 수 있다.
    - 사용자의 관점에서 시스템은 자신이 전송한 메시지에 응답하는 데 필요한 책임을 수행하는 일종의 객체다.
  - 시스템이라는 객체 안에는 더 작은 규모의 객체가 포함될 수 있다.
    - 시스템이 수행해야 하는 커다란 규모의 책임은 시스템에 포함된 더 작은 규모의 객체들의 협력을 통해 구현할 수 있다.
    - 시스템에 할당된 커다란 책임은 시스템 안의 작은 규모 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화된다.
  - 도메인 모델을 사용하여 세분화될 책임을 수행할 객체를 선택한다.
    - 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택한다.

  - 즉 유스케이스를 통해 시스템의 책임을 정의하고, 도메인 모델을 통해 은유와 구조를 결정한다.
    - 유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공한다.
    - 도메인 모델은 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다.
  - 책임-주도 설계는 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 유스케이스와 도메인 모델을 통합한다.
    - 물론 책임-주도 설계에 유스케이스와 도메인 모델이 반드시 필요한 것은 아니고, 유스케이스와 도메인 모델이 책임-주도 설계에서만 사용되는 것도 아니다.
    - 핵심은 견고한 객체지향 애플리케이션을 설계하기 위해서는 사용자의 관점에서 시스템의 기능을 명시하고, 사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 변환하는 체계적인 절차를 따라야 한다는 것이다.
  - 객체의 이름은 도메인 모델에 포함된 개념으로부터 차용하고, 책임은 도메인 모델에 정의한 개념의 정의에 부합하도록 할당한다.
    - 예를 들어 이자를 계산하는 책임을 가진 객체는 이자율이 될 것이며 이자는 이자율에 의해 생성될 것이다.
    - 책임 할당의 기본 원칙은 책임을 수행하는 데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것이다.
    - 이를 통해 상태와 행동을 캡슐화하는 자율적인 객체를 생성할 수 있다.





## 함께 모으기

- 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점
  - 마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 대해 설명한다.
    - 아래 세 가지 관점에서 소프트웨어를 개발해야한다는 것이 아니다.
    - 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다.
    - 클래스가 은유하는 개념은 도메인 관점을 반영한다.
    - 클래스의 공용 인터페이스는 명세 관점을 반영한다. 
    - 클래스의 속성과 메서드는 구현 관점을 반영한다.
    - 클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야한다.
    - 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야한다.
  - 개념 관점(Conceptual Perspective)
    - 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
    - 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며, 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.
    - 이 관점은 사용자가 도메인을 바라보는 관점을 반영한다.
    - 따라서 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.
  - 명세 관점(Specification Perspective)
    - 사용자의 도메인을 벗아나 개발자의 영역인 소프트웨어로 초점을 옮긴 관점이다.
    - 도메인의 개념이 아니라 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞춘다.
    - 명세 관점에서 프로그래머는 객체가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춘다.
    - 협력 안에서 메시지를 선택하고 메시지를 수신할 객체를 선택하는 것은 객체의 인터페이스, 즉 명세 관점에서 객체를 바라보는 것이다.
    - "구현이 아니라 인터페이스에 대해 프로그래밍하"라는 격언을 따르기 위해서는 명세 관점과 구현 관점을 명확하게 분리해야한다.
  - 구현 관점(Implementation Perspective)
    - 실제 작업을 수행하는 코드와 연관된 관점이다.
    - 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것에 초점이 맞춰져있다.
    - 따라서 프로그래머는 객체가 책임을 어떻게 수행할 것인가에 초점을 맞춘다.



- 커피 전문점 도메인
  - 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현할 것이다.
  - 상황
    - 커피 전문점에는 아메리카노, 카푸치노, 카라멜 마끼아또, 에스프레소라는 4가지 메뉴을 판매한다.
    - 커피 전문점에는 메뉴의 이름과 가격이 적혀 있는 메뉴판이 있다.
    - 주문을 받는 사람이 따로 있지는 않으며, 바리스타가 커피 제조와 주문 접수를 모두 수행한다.



- 도메인 모델 작성하기
  - 커피 전문점이라는 세상
    - 커피 전문점에는 메뉴판이 있으며, 객체지향의 관점에서 메뉴판은 하나의 객체다.
    - 메뉴판은 네 개의 메뉴로 구성되어 있는데, 각각의 메뉴 항목 역시 객체로 볼 수 있다.
    - 따라서 메뉴판은 네 개의 메뉴 항목 객체들을 포함하는 객체라고 볼 수 있다.
    - 손님은 메뉴판을 보고 바리스타에게 원하는 커피를 주문하며, 객체지향의 관점에서 손님 역시 하나의 객체다.
    - 바리스타는 주문을 받은 메뉴에 따라 적절한 커피를 제조하며, 객체지향의 관점에서는 바리스타 역시 객체다.
    - 바리스타가 제조하는 커피 역시 객체지향의 관점에서는 객체다.
    - 결국 커피 전문점이라는 도메인은 손님, 메뉴판, 메뉴 항목, 바리스타, 커피로 구성된 세상이다.
  - 객체들 사이의 관계를 밝혀내기
    - 손님은 메뉴판에서 주문할 커피를 선택할 수 있어야하므로, 두 객체 사이에 관계가 존재한다.
    - 손님은 바리스타에게 주문을 해야 하므로 손님과 바리스타 사이에도 관계가 존재한다.
    - 바리스타는 커피를 제조해야 하므로 두 객체 사이에도 관계가 존재한다.
  - 동적인 객체를 정적인 타입으로 추상화하여 복잡성을 낮추기
    - 손님 객체는 손님 타입의 인스턴스로 볼 수 있다.
    - 바리스타 객체도 바리스타 타입의 인스턴스로 볼 수 있다.
    - 메뉴판 객체도 메뉴판 타입의 인스턴스다.
    - 아메리카노 메뉴, 에스프레소 메뉴, 카라멜 마끼아또 메뉴, 카푸치노 메뉴는 모두 메뉴 항목 타입의 인스턴스로 볼 수 있다.
    - 아메리카노, 에스프레소, 카라멜 마끼아또, 카푸치노는 모두 커피 타입의 인스턴스로 볼 수 있다.
  - 타입 간의 관계 밝혀내기
    - 하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성되어 있다.
    - 메뉴판과 메뉴 항목 객체는 따로 존재하지 않으며 하나의 단위로 움직인다.
    - 이런 관점에서 메뉴 항목 객체가 메뉴판 객체에 포함되어 있다고 할 수 있으며, 이를 메뉴판 타입과 메뉴 항목 타입 사이에 메뉴 항목이 메뉴 판에 포함되는 포함(containment) 관계 혹은 합성(composition) 관계가 있다고 한다.
    - 손님 타입은 메뉴판 타입을 알고 있어야 원하는 커피를 선택할 수 있다.
    - 메뉴판 타입은 손님의 일부가 아니므로 포함하지는 않는다.
    - 이 처럼 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우 이를 연관(association) 관계라 한다.
    - 바리스타 타입은 커피를 제조해야 하므로 커피를 알고 있어야하지만, 이 역시 포함 관계는 아니므로 둘 사이에도 연관 관계가 있다.
    - 마지막으로 손님과 바리스타 사이에도 연관 관계가 있다.
  - 실제로 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이가 어떤 관계가 연관 관계인지는 중요하지 않다.
    - 초점은 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.
    - 실제로는 각 타입들 사이에 관계가 존재한다는 사실만 알고 있으면 된다.



- 설계하기
  - 커피를 주문하기 위한 협력 찾기
    - 객체지향 설계의 첫 번째 목표는 훌륭한 협력을 설계하는 것이다.
    - 협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.
    - 즉 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다.
    - 메시지를 수신할 객체는 메시지를 처리할 책임을 맡게 되고 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.
  - 설계는 아래의 순서를 따른다.
    - 어떤 메시지가 필요한지를 찾는다.
    - 메시지를 처리할 타입을 찾는다.
    - 해당 타입의 인스턴스를 생성한다.
    - 인스턴스가 메시지를 처리하는 중에 스스로 처리할 수 없는 일이 있는지를 확인한다.
    - 만약 스스로 처리할 수 없는 일이 있다면, 그 일을 처리하기 위해 어떤 메시지가 필요한지를 찾는다.
    - 위 과정을 반복한다.
  - 메시지1. 커피를 주문하라
    - 커피를 주문하기 위해 필요한 첫 번째 메시지는 "커피를 주문하라"일 것이다.
    - 메시지를 찾았으니 메시지를 처리하기에 적합한 객체, 즉 커피를 주문할 책임을 져야 하는 객체를 선택해야한다.
    - 소프트웨어 객체는 현실 객체의 은유이므로, 어떤 객체를 **은유**해야 할지를 생각해보면 된다.
    - 위에서 커피 전문점을 추상화한 도메인 모델을 작성했으므로, 모메인 모델에 책임을 수행하기에 적절한 타입이 있는지 살펴본다.
    - 위에서 우리는 "커피를 주문하라"는 메시지를 처리하기에 적합한 손님 타입을 도메인 모델로 작성했다.
    - 따라서 메시지를 처리할 객체로 손님 타입의 인스턴스를 선택한다.
    - 손님은 주문을 위해 메뉴를 선택해야 하지만 손님 객체는 메뉴 항목에 대해서 알지 못한다.
    - 따라서 고객은 자신이 선택할 메뉴 항목을 누군가가 제공해줘야 한다.
    - 메뉴 항목을 제공받기 위해 새로운 메시지가 등장한다.
  - 메시지2. 메뉴 항목을 보여줘라.
    - 메시지를 처리하기에 적합한 객체, 즉 메뉴 항목을 보여줄 수 있는 책임을 져야 하는 객체를 선택해야한다.
    - 위에서 작성한 도메인 모델에서 메뉴판 객체는 각 메뉴 항목에 대해 알고 있으므로, 메뉴 항목을 보여주는 책임을 수행할 수 있는 가장 적절한 후보다.
    - 따라서 메뉴판을 메시지를 수신할 객체로 선택한다.
    - 물론 현실속의 메뉴판은 스스로 자신을 펼쳐서 손님에게 메뉴를 보여줄 수 없지만, 이는 메뉴판을 자율적인 객체로 만들기 위한 **의인화**에 해당한다.
    - 손님은 메뉴판으로부터 메뉴 항목에 대한 정보를 얻었으므로 이제 커피를 제조해달라는 요청을 해야한다.
    - 새로운 요청은 결국 새로운 메시지가 필요하다는 의미다.
  - 메시지3. 커피를 제조하라.
    - 위와 동일한 과정을 거쳐서 메시지를 처리하기 가장 적합한 객체로 바리스타가 선택된다.
    - 바리스타는 커피를 제조하는 데 필요한 모든 정보를 알고 있다.
    - 커피를 만들기 위한 지식은 바리스타 객체의 상태로, 커피를 만드는 기술은 바리스타의 행동으로 간주할 수 있다.
    - 이런 관점에서 바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재다.
    - 커피 주문을 위한 협력은 바리스타가 새로운 커피를 만드는 것으로 끝난다.
    - 바리스타는 커피를 생성하라는 메시지를 생성한다.
  - 메시지4. 커피를 생성하라
    - 커피를 생성하라는 메시지를 처리하기 가장 적합한 객체는 당연히 커피 객체이다.
    - 바리스타의 메시지를 받은 커피 객체는 커피를 생성하고, 모든 협력이 종료된다.



- 인터페이스 정리하기

  - 위에서 설계를 통해 얻어낸 것은 객체들의 인터페이스다.
    - 객체가 수신한 메시지가 객체의 인터페이스를 결정한다는 사실을 기억해야한다.
    - 각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다.
    - 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.
    - 예를 들어 손님 객체의 인터페이스 안에는 '커피를 주문하라'라는 오퍼레이션이 포함되어야 하고, 메뉴판 객체의 인터페이스에는 '메뉴 항목을 보여줘라'는 오퍼레이션을, 바리스타 객체의 인터페이스는 '커피를 제조하라'는 오퍼레이션을, 커피 객체의 인터페이스는 '커피를 생성하라'는 오퍼레이션을 제공한다.
  - 객체들의 협력은 실행 시간에 컴퓨터 안에서 일어나는 상황을 동적으로 묘사한 모델이다.
    - 실제로 소프트웨어 구현은 동적인 객체가 아닌 정적인 타입을 이용해 이뤄진다.
    - 따라서 객체들을 포괄하는 타입을 정의한 후 식별된 오퍼레이션을 타입의 인터페이스에 추가해야 한다.
  - 객체의 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.
    - 협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부라는 사실을 기억해야한다.
    - 따라서 인터페이스에 포함된 오퍼레이션 역시 외부에서 접근 가능하도록 공용으로 선언되어 있어야한다.
  - 아래는 Python으로 구현한 인터페이스이다.

  ```python
  class Customer:
      def order(self, menu_name: str):
          ...
          
          
  class MenuItem:
      ...
      
      
  class Menu:
      def choose(self):
          ...
          
          
  class Barista:
      def make_coffee(self, menu_item: MenuItem):
          ...
          
  class Coffee:
      def __init__(self, menu_item: MenuItem):
          ...
  ```



- 구현하기

  - 클래스의 인터페이스를 식별했으므로 이제 오퍼레이션을 수행하는 방법을 메서드로 구현한다.
  - 먼저 `Customer`의 협력을 살펴본다.
    - `Menu`에게 메뉴의 항목들을 보여달라고 요청해야한다.
    - 메뉴 항목을 보고 메뉴를 `Barista`에게 전달해서 원하는 커피를 제조하도록 요청해야한다.
    - 문제는 어떻게 `Menu`와 `Barista` 객체에 접근할 것인지이다.
    - 객체가 다른 객체에게 메시지를 전송하기 위해서는 먼저 객체에 대한 참조를 얻어야한다.
    - 따라서 `Customer`는 어떤 방법으로든 자신과 협력하는 객체들에 대한 참조를 알고 있어야한다.
  - `Customer` 클래스를 구현한다.
    - 협력하는 객체들을 `order()` 메서드의 인자로 받는 방식으로 구현할 것이다.
    - 이렇게 구현하면, 인터페이스가 변경되게 된다.

  ```python
  class Customer:
      # 본래 menu_name만 인자로 받았으나, Menu와 Barista 객체도 인자로 받도록 인터페이스가 변경되었다.
      def order(self, menu_name: str, menu: Menu, barista: Barista):
          menu_item = menu.choose(menu_name)
          if menu_item is not None:
              coffee = barista.make_coffe(menu_item)
  ```

  - `Menu`  클래스를 구현한다.
    - `Menu`는 인자로 받은 메뉴 이름에 해당하는 메뉴 항목을 찾아야 하는 책임이 있다.
    - 이 책임을 수행하기 위해서는 내부적으로 `MenuItem`을 관리하고 있어야한다.

  ```python
  class Menu:
      def __init__(self, menu_items: list[MenuItem]):
          self.menu_items = menu_items
      
      def choose(self, menu_name: str):
          for menu_item in self.menu_items:
              if menu_name == menu_item.get_name():
                  return menu_item
  ```

  - `Barista` 클래스를 구현한다.
    - `MenuItem`을 이용하여 커피를 제조한다.

  ```python
  class Barista:
      def make_coffee(self, menu_item: MenuItem) -> Coffee:
          return Coffee(menu_item)
  ```

  - `Coffee` 클래스를 구현한다.
    - 자기 자신을 생성하기 위한 생성자를 제공한다.
    - 커피 이름과 가격을 속성으로 가지고, 생성자 안에서 `MenuItem`에 요청을 보내 커피 이름과 가격을 얻은 후 `Coffee`의 속성에 저장한다.

  ```py
  class Coffee:
      def __init__(self, menu_item: MenuItem):
          self.name = menu_item.get_name()
          self.price = menu_item.cost()
  ```

  - `MenuItem` 클래스를 구현한다.
    - 원래 인터페이스에 없던 `cost`와 `get_name`을 추가한다.	

  ```python
  class MenuItem:
      def __init__(self, name: str, price: int):
          self.name = name
          self.price = price
          
      def cost(self) -> int:
          return self.price
      
      def get_name(self) -> int:
          return self.name
  ```



- 구현시의 변경 사항들
  - `Customer` 클래스를 구현하는 도중에 인터페이스가 변경되었다.
    - 구현하지 않고 머릿속으로 구상한 설계는 코드로 구현하는 단계에서 대부분 변경된다.
    - 설계 작업은 구현을 위한 스케치를 작성하는 단계지 구현 그 자체일 수는 없다.
    - 중요한 것은 설계가 아니라 코드다.
    - 따라서 협력을 구상하는 단계에 너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 한다.
    - 코드를 통한 피드백 없이는 깔끔한 설계를 얻을 수 없다.
  - `MenuItem`의 목록을 `Menu`의 속성으로 포함시킨 결정 역시 클래스를 구현하는 도중에 내려졌다.
    - 객체의 속성은 객체 내부 구현에 속하기 때문에 캡슐화 되어야 한다.
    - 객체의 속성이 캡슐화 된다는 이야기는 인터페이스에는 객체의 내부 속성에 대한 어떤 힌트도 제공되어서는 안 된다는 것을 의미한다.
    - 이를 위한 가장 좋은 방법은 인터페이스를 정하는 단계에서는 객체가 어떤 속성을 가지는지, 또 그 속성이 어떤 자료구조로 구현됐는지를 고려하지 않는 것이다.
    - 객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야한다.
    - 객체가 어떤 책임을 수행해야 하는지를 결정한 후에야 책임을 수행하는 데 필요한 객체의 속성을 결정하라.
    - 이것이 객체의 구현 세부 사항을 공용 인터페이스에 노출시키지 않고 인터페이스와 구현을 깔끔하게 분리할 수 있는 기본적인 방법이다.
  - `MenuItem`의 `cost`, `get_name` 메서드 역시 구현 도중에 식별되었다.
    - 인터페이스는 객체가 다른 객체와 직접적으로 상호작용하는 통로다.
    - 인터페이스를 통해 실제로 상호작용을 하지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다.
  - 설계가 제대로 그려지지 않는다면 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라
    - 테스트-주도 설계로 코드를 구현하는 사람들이 하는 작업이 바로 이것이다.
    - 그들은 테스트 코드를 작성해 가면서 협력을 설계한다.



- 위에서 작성한 코드와 세 가지 관점

  - 개념 관점
    - 개념 관점에서 위 코드를 바라보면 클래스들에 초점을 맞춰 보게 된다.
    - 이 클래스들은 살펴보면 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다는 사실을 쉽게 알 수 있다.
    - 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다.
    - 예를 들어 커피를 제조하는 과정을 변경해야 한다면, 커피를 제조하는 책임을 수행하는 `Barista` 클래스를 수정해야 한다는 것을 쉽게 알 수 있다.
    - 소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁을수록 기능을 변경하기 위해 읽어야 하는 코드의 양도 점점 줄어든다.
  - 명세 관점
    - 클래스의 인터페이스에 초점을 맞춰 보게 된다.
    - 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.
    - 공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이다.
    - 인터페이스를 수정함면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수밖에 없다.
    - 객체의 인터페이스는 수정하기 어렵다는 사실을 기억하라.
    - 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

  - 구현 관점
    - 클래스의 내부 구현에 초점을 맞춰 보게 된다.
    - 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다.
    - 따라서 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에 영향을 미쳐서는 안 된다(물론 현실적으로는 어려울 수 있다).
    - 이것은 메서드와 속성이 철저하게 클래스 내부로 캡슐화되어야 한다는 것을 의미한다.
  - 위 세 가지 관점이 명확하게 드러날 수 있게 코드를 작성해야 한다.
    - 다른 사람이 코드를 읽으면서 세 가지 관점을 쉽게 포착하지 못한다면 세 가지 관점이 명확히 드러날 수 있게 코드를 개선하라.



- 도메인 개념을 참조하는 이유
  - 어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택할 것인가?
    -  도메인 개념 중에 가장 적절한 것을 선택하는 것이다.
    - 도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.
    - 이것은 시스템의 유지보수성에 커다란 영향을 미친다.
  - 소프트웨어는 항상 변하며, 설계는 변경을 위해 존재한다.
    - 여러 개의 클래스로 기능을 분할하고 클래스 안에서 인터페이스와 구현을 분리하는 이유는 변경이 발생했을 때 코드를 좀 더 수월하게 수정하길 원하기 때문이다.
    - 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.



- 인터페이스와 구현을 분리하라
  - 명세 관점과 구현 관점이 뒤섞이지 않게 하라.
    - 명세 관점은 클래스의 안정적인 측면을 드러내야 한다.
    - 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.
  - 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수밖에 없다.
  - 실제 훌륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스다.
    - 명세 관점이 설계를 주도하게 되면 설계의 품질이 향상될 수 있다.
  - 중요한 점은 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다는 것이다.
    - 캡슐화를 위반하여 구현을 인터페이스 밖으로 노출해선 안 된다.
    - 인터페이스와 구현을 뒤섞어놓아서도 안 된다.



## 추상화 기법

> 아래 내용 중 '분류와 인스턴스화'는 3장 '타입과 추상화'에서 이미 살펴본 내용이다.

- 추상화의 목적
  - 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.
  - 사람들은 도메인에 존재하는 개념들을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용한다.
    - 특성을 공유하는 객체들을 동일한 타입으로 분류하는 것은 객체지향 패러다임에서 사용하는 추상화 기법의 한 예다.
  - 객체지향의 가장 큰 장점은 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점이다.



- 분류와 인스턴스화
  - 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다.
  - 개념과 범주
    - 사람들은 공통점을 바탕으로 서로 다른 것들을 하나의 개념으로 분류할 수 있다.
    - 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.
    - 개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.
    - 객체들을 공통적인 특성을 기반으로 범주로 묶고 개념을 적용하는 것은 범주라는 정신적 렌즈를 통해 세상을 바라보는 것과 유사하다.
    - 자동차라는 렌즈를 통해 바라본 세상은 자동차 범주에 속한 객체만이 보일 것이고, 나무라는 렌즈를 통해 바라본 세상은 나무 범주에 속한 객체만이 보일 것이다.
  - 분류
    - 세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다.
    - 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.
    - 어떤 객체를 자동차라는 개념으로 분류하는 것은 자동차라는 개념을 적용할 수 있는 집합의 일원으로 해당 객체를 초함시키는 것을 의미한다.
  - 분류의 목적은 복잡성을 낮추는 것이다.
    - 세상에 존재하는 서로 다른 상태를 가진 무수히 많은 객체들을 개별적으로 다루지 않고 범주로 묶음으로써 세상에 존재하는 복잡성을 낮출 수 있다.
    - 분류를 통해 개별 현상을 하나의 개념으로 다룬다.
    - 이 때 수 많은 개별적인 현상들을 객체라 하고, 하나의 개념을 타입이라 한다.
    - 다시 말해 분류는 객체를 타입과 연관시키는 것이다.
    - 요약하면 어떤 객체가 타입의 정의에 부합할 경우 그 객체는 해당 타입으로 분류되며 자동으로 타입의 인스턴스가 된다.
  - 분류의 역은 타입에 해당하는 객체를 생성하는 과정이다.
    - 인스턴스화 또는 예시라고한다.
  - 타입
    - 객체지향의 세계에서 개념을 가리키는 표준 용어는 타입이다.
    - 따라서 타입은 개념과 동의어이며, 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어를 의미한다.
    - 이런 관점에서 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로, 객체를 타입의 인스턴스라고 한다.
    - 객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야한다.
    - 어떤 객체긔 타입이 자동차라고 말할 수 있으려면 자동차가 무엇인지에 대한 명확한 정의가 필요하다.
  - 타입을 객체의 분류장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.
    - 심볼: 타입을 가리키는 간략한 이름이나 명칭.
    - 내연: 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타엡에 속하는지 여부를 알 수 있다.
    - 외연: 타입에 속하는 모든 객체들의 집합.
    - 내연은 어떤 객체가 의미적으로 자동차라는 타입에 속하는지 여부를 판단할 수 있는 정의를 제공한다.
    - 만약 어떤 객체가 내연을 만족한다면 그 객체는 외연의 한 원소로 포함된다.
    - 심볼은 내연과 외연에 모호하지 않은 이름을 붙임으로써 타입을 쉽게 참조하고 커뮤니케이션할 수 있게 한다.
  - 외연과 집합
    - 타임은 외연의 타입에 속하는 객체들의 집합으로 표현한다.
    - 집합은 외연을 가리키는 또 다른 명칭이다.
    - 객체들은 동시에 서로 다른 집합에 포함될 수도 있다.
  - 단일 분류(single classification)와 다중 분류(multiple classification)
    - 한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류라고 한다.
    - 한 객체가 한 시점에 여러 타입에 속하는 것을 다중 분류라고 한다.
    - 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.
    - 대부분의 언어에서 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다.
    - 이 관점에서 다중 분류와 다중 상속을 혼동해서는 안 된다.
    - 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만, 타입 정의를 생략할 수는 없다.
    - 반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.
  - 동적 분류(dynamic classification)와 정적 분류(static classification)
    - 객체를 특정한 타입으로 분류하면 해당 객체는 타입의 집합에 포함된다.
    - 만약 객체가 타입을 변경할 수 이싸면 어떻게 될까?
    - 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 이를 동적 분류라 한다.
    - 객체가 자신의 타입을 변경할 수 없는 경우 이를 정적 분류라 한다.
    - 다중 분류와 동적 분류는 서로 배타적인 개념이 아니다.
    - 개념적인 관점에서 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는 데 유용하다.
    - 클래스 기반의 객체지향 언어에서 타입은 클래스를 이용해서 구현된다.



- 일반화와 특수화
  
  - 좀 더 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다.
  
    - 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 일반화라고 한다.
    - 계층의 하위에 위치한 범주를 계층의 상위에 위치한 범주의 특수화라고 한다.
  
  - 서브타입
  
    - 객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다.
    - 따라서 좀 더 일반적인 타입을 이용해 좀 더 세부적인 타입을 정의함으로써 타입 간의 계층 구조를 구축할 수 있다.
    - 어떤 타입이 다른 타입보다 일반적이라면 이를 슈퍼타입이라 한다.
    - 어떤 타입이 다른 타입보다 좀 더 특수하다면 이를 서브타입이라 한다.
    - 슈퍼타입은 서브타입의 일반화고, 서브타입은 슈퍼타입의 특수화다.
  
    - 일반화와 특수화의 계층 구조에서 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가진다.
    - 서브타입은 슈퍼타입의 본질적인 속성들을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다는 것을 쉽게 예상할 수 있다.
    - 이 같은 일반화의 특징을 이용하면 부분적인 사실을 통해 복잡한 사실에 대한 논리적인 추론이 가능해진다.
  
  - 어떤 타입이 다른 타입의 서브 타입이 되기 위해서는 100% 규칙과 Is-a 규칙을 준수해야한다.
  
    - 100% 규칙은 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다는 규칙으로, 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야한다.
    - Is-a 규칙은 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함되어야 한다는 규칙이다.
  
  - 일반화의 원칙
  
    - 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(comformance)해야 한다는 것이다.
    - 순응에는 구조적인 순응(structural comformance)과 행위적인 순응(behavioral comformance)의 두 가지 종류가 있다.
    - 두 가지 모두 특정 기대 집합에 대해 서브타입의 슈퍼 타입에 대한 대체 가능성을 의미한다.
    - 구조적인 순응의 경우 기대 집합은 속성과 연관관계에 대한 것이며, 행위적인 순응의 경우 기대 집합은 행위가 동일한 계약을 기반으로 하느냐에 관한 것이다.
  
  - 구조적 순응
  
    - 구조적 순응은 타입의 내연과 관련된 100% 규칙을 의미한다.
    - 즉 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야한다.
    - 따라서 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다.
  
  - 행위적 순응
  
    - 타입의 행위에 관한 것으로, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야한다.
    - 행위적인 순응을 흔히 리스코프 치환 원칙이라고 한다.



- 상속
  - 프로그래밍 언어를 사용하여 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 이용하는 것이다.
    - 그러나 안타깝게도 모든 상속 관계가 일반화 관계인 것은 아니다.
    - 프로그램 내의 두 클래스 간에 상속 관계가 존재할 때 이 관계를 반드시 일반화 관계라고 할 수는 없다.
  - 코드 재사용
    - 상속의 또 다른 용도는 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다.
    - 만약 한 클래스가 다른 클래스를 상속한다면 상속하는 타입은 부모 클래스의 데이터와 메서드를 사용하고, 수정하고, 확장할 수 있다.
    - **어떤 프로그래밍 언어도 상속이 대체 가능성을 만든다는 것을 보장하지 않는다.**
  - 서브타이핑과 서브클래싱
    - 서브클래스가 슈퍼클래스를 **대체할 수 있을 경우** 이를 **서브타이핑**이라고 한다.
    - 서브클래스가 슈퍼클래스를 **대체할 수 없는 경우** 이를 **서브클래싱**이라고 한다.
    - 서브타이핑은 설계의 유연성이 목표인 반면, 서브클래싱은 코드의 중복 제거와 재사용이 목적이다.
    - **흔히 서브타이핑을 인터페이스 상속이라 하고, 서브 클래싱을 구현 상속이라 한다.**
  - 상속은 서브타이핑을 프로그래밍 언어로 구현하는 데 사용될 수 있지만 모든 상속이 서브타이핑인 것은 아니다.
    - 일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며, 대체 가능성을 내포한다.
    - 가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.
  - 위임(delegation)
    - 여러 클래스로 구성 된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임을 사용하는 것이다.
    - 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 부모 클래스로 위임한다.
    - 만약 부모 클래스도 이해할 수 없다면 자신의 부모 클래스로 다시 위임한다.
    - 클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때까지 계속된다.



- 집합과 분해
  - 계층적인 복잡성
    - 복잡성은 계층의 형태를 띄며, 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 안정적인 형태의 수와 분포에 의존한다.
    - 예를 들어 수 많은 부품이 들어가는 시계를 조립한다고 생각해보자.
    - 아무리 복잡한 구조를 가진 시계라고 해도, 결국 몇 개의 부품 들이 모여 작은 하나의 기능을 이루고, 몇 개의 부품들의 집합이  모여 시계를 완성하게 된다.
    - 이처럼 시계 구조의 복잡성은 계층의 형태를 띈다.
    - 또한 작은 기능을 이루는 부품들을 많이 만들어 둘 수록 시계 전체를 완성하는 데 걸리는 시간은 줄어들게 된다.
  - 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 집합이라 하고, 전체를 부분으로 분할하는 행위를 분해라 한다.
    - 집합의 가치는 많은 수의 사물들의 형상을 하나의 단위로 다룸으로써 복잡성을 줄일 수 있다는 데 있다.
    - 집합은 불필요한 세부 사항을 배제하고 큰 그림에서 대상을 다룰 수 있게 한다.
    - 즉 불필요한 세부 사항을 추상화한다.그러나 필요한 시점에는 전체를 분해함으로써 그 안에 포함된 부분들을 새로운 전체로 다룰 수 있다.
    - 전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다.
  - 집합은 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.
    - 집합은 불필요한 세부 사항을 감춰준다.
    - 외부에서는 전체에 관해서만 알고, 내부 사항에 대해서는 알지 못하기 때문에 내부의 구성을 변경하더라도 외부에 영향을 미치지 않는다.
  - 합성 관계
    - 객체와 객체 사이의 전체-부분 관계를 구현하기 위해 사용하는 관계이다.
    - 합성 관계는 부분을 전체 안에 캡슐화함으로써 복잡도를 줄여준다.
    - 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화한다.
  - 패키지
    - 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지 혹은 모듈이라고 한다.
    - 패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다.
    - 또한 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다.
    - 응집도 높은 클래스 집합을 하나의 패키지로 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 적어진다.

